// DO NOT EDIT.
// swift-format-ignore-file
//
// Generated by the Swift generator plugin for the protocol buffer compiler.
// Source: chat/v1/stream.proto
//
// For information on using the generated types, please see the documentation:
//   https://github.com/apple/swift-protobuf/

import Foundation
import SwiftProtobuf

// If the compiler emits an error on this type, it is because this file
// was generated by a version of the `protoc` Swift plug-in that is
// incompatible with the version of SwiftProtobuf to which you are linking.
// Please ensure that you are building against the same version of the API
// that was used to generate this file.
fileprivate struct _GeneratedWithProtocGenSwiftVersion: SwiftProtobuf.ProtobufAPIVersionCheck {
  struct _2: SwiftProtobuf.ProtobufAPIVersion_2 {}
  typealias Version = _2
}

/// Request type for use in the `StreamEvents` endpoint.
struct Protocol_Chat_V1_StreamEventsRequest {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  /// Describes which event source to subscribe to.
  var request: Protocol_Chat_V1_StreamEventsRequest.OneOf_Request? = nil

  /// Subscribe to the guild event source.
  var subscribeToGuild: Protocol_Chat_V1_StreamEventsRequest.SubscribeToGuild {
    get {
      if case .subscribeToGuild(let v)? = request {return v}
      return Protocol_Chat_V1_StreamEventsRequest.SubscribeToGuild()
    }
    set {request = .subscribeToGuild(newValue)}
  }

  /// Subscribe to the action event source.
  var subscribeToActions: Protocol_Chat_V1_StreamEventsRequest.SubscribeToActions {
    get {
      if case .subscribeToActions(let v)? = request {return v}
      return Protocol_Chat_V1_StreamEventsRequest.SubscribeToActions()
    }
    set {request = .subscribeToActions(newValue)}
  }

  /// Subscribe to the homeserver event source.
  var subscribeToHomeserverEvents: Protocol_Chat_V1_StreamEventsRequest.SubscribeToHomeserverEvents {
    get {
      if case .subscribeToHomeserverEvents(let v)? = request {return v}
      return Protocol_Chat_V1_StreamEventsRequest.SubscribeToHomeserverEvents()
    }
    set {request = .subscribeToHomeserverEvents(newValue)}
  }

  var unknownFields = SwiftProtobuf.UnknownStorage()

  /// Describes which event source to subscribe to.
  enum OneOf_Request: Equatable {
    /// Subscribe to the guild event source.
    case subscribeToGuild(Protocol_Chat_V1_StreamEventsRequest.SubscribeToGuild)
    /// Subscribe to the action event source.
    case subscribeToActions(Protocol_Chat_V1_StreamEventsRequest.SubscribeToActions)
    /// Subscribe to the homeserver event source.
    case subscribeToHomeserverEvents(Protocol_Chat_V1_StreamEventsRequest.SubscribeToHomeserverEvents)

  #if !swift(>=4.1)
    static func ==(lhs: Protocol_Chat_V1_StreamEventsRequest.OneOf_Request, rhs: Protocol_Chat_V1_StreamEventsRequest.OneOf_Request) -> Bool {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch (lhs, rhs) {
      case (.subscribeToGuild, .subscribeToGuild): return {
        guard case .subscribeToGuild(let l) = lhs, case .subscribeToGuild(let r) = rhs else { preconditionFailure() }
        return l == r
      }()
      case (.subscribeToActions, .subscribeToActions): return {
        guard case .subscribeToActions(let l) = lhs, case .subscribeToActions(let r) = rhs else { preconditionFailure() }
        return l == r
      }()
      case (.subscribeToHomeserverEvents, .subscribeToHomeserverEvents): return {
        guard case .subscribeToHomeserverEvents(let l) = lhs, case .subscribeToHomeserverEvents(let r) = rhs else { preconditionFailure() }
        return l == r
      }()
      default: return false
      }
    }
  #endif
  }

  /// Event source for guilds' events.
  struct SubscribeToGuild {
    // SwiftProtobuf.Message conformance is added in an extension below. See the
    // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
    // methods supported on all messages.

    /// the guild id to subscribe to
    var guildID: UInt64 = 0

    var unknownFields = SwiftProtobuf.UnknownStorage()

    init() {}
  }

  /// Event source for actions' events.
  struct SubscribeToActions {
    // SwiftProtobuf.Message conformance is added in an extension below. See the
    // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
    // methods supported on all messages.

    var unknownFields = SwiftProtobuf.UnknownStorage()

    init() {}
  }

  /// Event source for homeserver events.
  struct SubscribeToHomeserverEvents {
    // SwiftProtobuf.Message conformance is added in an extension below. See the
    // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
    // methods supported on all messages.

    var unknownFields = SwiftProtobuf.UnknownStorage()

    init() {}
  }

  init() {}
}

/// Used in the `StreamEvents` endpoint.
struct Protocol_Chat_V1_StreamEventsResponse {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  /// Possible events.
  var event: Protocol_Chat_V1_StreamEventsResponse.OneOf_Event? = nil

  /// A chat event.
  var chat: Protocol_Chat_V1_StreamEvent {
    get {
      if case .chat(let v)? = event {return v}
      return Protocol_Chat_V1_StreamEvent()
    }
    set {event = .chat(newValue)}
  }

  /// A emote event.
  var emote: Protocol_Emote_V1_StreamEvent {
    get {
      if case .emote(let v)? = event {return v}
      return Protocol_Emote_V1_StreamEvent()
    }
    set {event = .emote(newValue)}
  }

  /// A profile event.
  var profile: Protocol_Profile_V1_StreamEvent {
    get {
      if case .profile(let v)? = event {return v}
      return Protocol_Profile_V1_StreamEvent()
    }
    set {event = .profile(newValue)}
  }

  var unknownFields = SwiftProtobuf.UnknownStorage()

  /// Possible events.
  enum OneOf_Event: Equatable {
    /// A chat event.
    case chat(Protocol_Chat_V1_StreamEvent)
    /// A emote event.
    case emote(Protocol_Emote_V1_StreamEvent)
    /// A profile event.
    case profile(Protocol_Profile_V1_StreamEvent)

  #if !swift(>=4.1)
    static func ==(lhs: Protocol_Chat_V1_StreamEventsResponse.OneOf_Event, rhs: Protocol_Chat_V1_StreamEventsResponse.OneOf_Event) -> Bool {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch (lhs, rhs) {
      case (.chat, .chat): return {
        guard case .chat(let l) = lhs, case .chat(let r) = rhs else { preconditionFailure() }
        return l == r
      }()
      case (.emote, .emote): return {
        guard case .emote(let l) = lhs, case .emote(let r) = rhs else { preconditionFailure() }
        return l == r
      }()
      case (.profile, .profile): return {
        guard case .profile(let l) = lhs, case .profile(let r) = rhs else { preconditionFailure() }
        return l == r
      }()
      default: return false
      }
    }
  #endif
  }

  init() {}
}

/// Describes an event.
struct Protocol_Chat_V1_StreamEvent {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  /// Which event to send.
  var event: Protocol_Chat_V1_StreamEvent.OneOf_Event? = nil

  /// Send the guild added to list event.
  var guildAddedToList: Protocol_Chat_V1_StreamEvent.GuildAddedToList {
    get {
      if case .guildAddedToList(let v)? = event {return v}
      return Protocol_Chat_V1_StreamEvent.GuildAddedToList()
    }
    set {event = .guildAddedToList(newValue)}
  }

  /// Send the guild removed from list event.
  var guildRemovedFromList: Protocol_Chat_V1_StreamEvent.GuildRemovedFromList {
    get {
      if case .guildRemovedFromList(let v)? = event {return v}
      return Protocol_Chat_V1_StreamEvent.GuildRemovedFromList()
    }
    set {event = .guildRemovedFromList(newValue)}
  }

  /// Send the action performed event.
  var actionPerformed: Protocol_Chat_V1_StreamEvent.ActionPerformed {
    get {
      if case .actionPerformed(let v)? = event {return v}
      return Protocol_Chat_V1_StreamEvent.ActionPerformed()
    }
    set {event = .actionPerformed(newValue)}
  }

  /// Send the message sent event.
  var sentMessage: Protocol_Chat_V1_StreamEvent.MessageSent {
    get {
      if case .sentMessage(let v)? = event {return v}
      return Protocol_Chat_V1_StreamEvent.MessageSent()
    }
    set {event = .sentMessage(newValue)}
  }

  /// Send the message updated event.
  var editedMessage: Protocol_Chat_V1_StreamEvent.MessageUpdated {
    get {
      if case .editedMessage(let v)? = event {return v}
      return Protocol_Chat_V1_StreamEvent.MessageUpdated()
    }
    set {event = .editedMessage(newValue)}
  }

  /// Send the message deleted event.
  var deletedMessage: Protocol_Chat_V1_StreamEvent.MessageDeleted {
    get {
      if case .deletedMessage(let v)? = event {return v}
      return Protocol_Chat_V1_StreamEvent.MessageDeleted()
    }
    set {event = .deletedMessage(newValue)}
  }

  /// Send the channel created event.
  var createdChannel: Protocol_Chat_V1_StreamEvent.ChannelCreated {
    get {
      if case .createdChannel(let v)? = event {return v}
      return Protocol_Chat_V1_StreamEvent.ChannelCreated()
    }
    set {event = .createdChannel(newValue)}
  }

  /// Send the channel updated event.
  var editedChannel: Protocol_Chat_V1_StreamEvent.ChannelUpdated {
    get {
      if case .editedChannel(let v)? = event {return v}
      return Protocol_Chat_V1_StreamEvent.ChannelUpdated()
    }
    set {event = .editedChannel(newValue)}
  }

  /// Send the channel deleted event.
  var deletedChannel: Protocol_Chat_V1_StreamEvent.ChannelDeleted {
    get {
      if case .deletedChannel(let v)? = event {return v}
      return Protocol_Chat_V1_StreamEvent.ChannelDeleted()
    }
    set {event = .deletedChannel(newValue)}
  }

  /// Send the guild updated event.
  var editedGuild: Protocol_Chat_V1_StreamEvent.GuildUpdated {
    get {
      if case .editedGuild(let v)? = event {return v}
      return Protocol_Chat_V1_StreamEvent.GuildUpdated()
    }
    set {event = .editedGuild(newValue)}
  }

  /// Send the guild deleted event.
  var deletedGuild: Protocol_Chat_V1_StreamEvent.GuildDeleted {
    get {
      if case .deletedGuild(let v)? = event {return v}
      return Protocol_Chat_V1_StreamEvent.GuildDeleted()
    }
    set {event = .deletedGuild(newValue)}
  }

  /// Send the member joined event.
  var joinedMember: Protocol_Chat_V1_StreamEvent.MemberJoined {
    get {
      if case .joinedMember(let v)? = event {return v}
      return Protocol_Chat_V1_StreamEvent.MemberJoined()
    }
    set {event = .joinedMember(newValue)}
  }

  /// Send the member left event.
  var leftMember: Protocol_Chat_V1_StreamEvent.MemberLeft {
    get {
      if case .leftMember(let v)? = event {return v}
      return Protocol_Chat_V1_StreamEvent.MemberLeft()
    }
    set {event = .leftMember(newValue)}
  }

  /// Send the typing event.
  var typing: Protocol_Chat_V1_StreamEvent.Typing {
    get {
      if case .typing(let v)? = event {return v}
      return Protocol_Chat_V1_StreamEvent.Typing()
    }
    set {event = .typing(newValue)}
  }

  /// Send the role created event.
  var roleCreated: Protocol_Chat_V1_StreamEvent.RoleCreated {
    get {
      if case .roleCreated(let v)? = event {return v}
      return Protocol_Chat_V1_StreamEvent.RoleCreated()
    }
    set {event = .roleCreated(newValue)}
  }

  /// Send the role deleted event.
  var roleDeleted: Protocol_Chat_V1_StreamEvent.RoleDeleted {
    get {
      if case .roleDeleted(let v)? = event {return v}
      return Protocol_Chat_V1_StreamEvent.RoleDeleted()
    }
    set {event = .roleDeleted(newValue)}
  }

  /// Send the role moved event.
  var roleMoved: Protocol_Chat_V1_StreamEvent.RoleMoved {
    get {
      if case .roleMoved(let v)? = event {return v}
      return Protocol_Chat_V1_StreamEvent.RoleMoved()
    }
    set {event = .roleMoved(newValue)}
  }

  /// Send the role updated event.
  var roleUpdated: Protocol_Chat_V1_StreamEvent.RoleUpdated {
    get {
      if case .roleUpdated(let v)? = event {return v}
      return Protocol_Chat_V1_StreamEvent.RoleUpdated()
    }
    set {event = .roleUpdated(newValue)}
  }

  /// Send the role perms updated event.
  var rolePermsUpdated: Protocol_Chat_V1_StreamEvent.RolePermissionsUpdated {
    get {
      if case .rolePermsUpdated(let v)? = event {return v}
      return Protocol_Chat_V1_StreamEvent.RolePermissionsUpdated()
    }
    set {event = .rolePermsUpdated(newValue)}
  }

  /// Send the user roles updated event.
  var userRolesUpdated: Protocol_Chat_V1_StreamEvent.UserRolesUpdated {
    get {
      if case .userRolesUpdated(let v)? = event {return v}
      return Protocol_Chat_V1_StreamEvent.UserRolesUpdated()
    }
    set {event = .userRolesUpdated(newValue)}
  }

  /// Send the permission updated event.
  var permissionUpdated: Protocol_Chat_V1_StreamEvent.PermissionUpdated {
    get {
      if case .permissionUpdated(let v)? = event {return v}
      return Protocol_Chat_V1_StreamEvent.PermissionUpdated()
    }
    set {event = .permissionUpdated(newValue)}
  }

  /// The channels have been completely reordered.
  var channelsReordered: Protocol_Chat_V1_StreamEvent.ChannelsReordered {
    get {
      if case .channelsReordered(let v)? = event {return v}
      return Protocol_Chat_V1_StreamEvent.ChannelsReordered()
    }
    set {event = .channelsReordered(newValue)}
  }

  /// Send the channel position updated event.
  var editedChannelPosition: Protocol_Chat_V1_StreamEvent.ChannelPositionUpdated {
    get {
      if case .editedChannelPosition(let v)? = event {return v}
      return Protocol_Chat_V1_StreamEvent.ChannelPositionUpdated()
    }
    set {event = .editedChannelPosition(newValue)}
  }

  /// Send the message pinned event.
  var messagePinned: Protocol_Chat_V1_StreamEvent.MessagePinned {
    get {
      if case .messagePinned(let v)? = event {return v}
      return Protocol_Chat_V1_StreamEvent.MessagePinned()
    }
    set {event = .messagePinned(newValue)}
  }

  /// Send the message unpinned event.
  var messageUnpinned: Protocol_Chat_V1_StreamEvent.MessageUnpinned {
    get {
      if case .messageUnpinned(let v)? = event {return v}
      return Protocol_Chat_V1_StreamEvent.MessageUnpinned()
    }
    set {event = .messageUnpinned(newValue)}
  }

  /// Send the reaction updated event.
  var reactionUpdated: Protocol_Chat_V1_StreamEvent.ReactionUpdated {
    get {
      if case .reactionUpdated(let v)? = event {return v}
      return Protocol_Chat_V1_StreamEvent.ReactionUpdated()
    }
    set {event = .reactionUpdated(newValue)}
  }

  /// Send the owner added event.
  var ownerAdded: Protocol_Chat_V1_StreamEvent.OwnerAdded {
    get {
      if case .ownerAdded(let v)? = event {return v}
      return Protocol_Chat_V1_StreamEvent.OwnerAdded()
    }
    set {event = .ownerAdded(newValue)}
  }

  /// Send the owner removed event.
  var ownerRemoved: Protocol_Chat_V1_StreamEvent.OwnerRemoved {
    get {
      if case .ownerRemoved(let v)? = event {return v}
      return Protocol_Chat_V1_StreamEvent.OwnerRemoved()
    }
    set {event = .ownerRemoved(newValue)}
  }

  /// Send the guild invite received event.
  var inviteReceived: Protocol_Chat_V1_StreamEvent.InviteReceived {
    get {
      if case .inviteReceived(let v)? = event {return v}
      return Protocol_Chat_V1_StreamEvent.InviteReceived()
    }
    set {event = .inviteReceived(newValue)}
  }

  /// Send the guild invite rejected event.
  var inviteRejected: Protocol_Chat_V1_StreamEvent.InviteRejected {
    get {
      if case .inviteRejected(let v)? = event {return v}
      return Protocol_Chat_V1_StreamEvent.InviteRejected()
    }
    set {event = .inviteRejected(newValue)}
  }

  var unknownFields = SwiftProtobuf.UnknownStorage()

  /// Which event to send.
  enum OneOf_Event: Equatable {
    /// Send the guild added to list event.
    case guildAddedToList(Protocol_Chat_V1_StreamEvent.GuildAddedToList)
    /// Send the guild removed from list event.
    case guildRemovedFromList(Protocol_Chat_V1_StreamEvent.GuildRemovedFromList)
    /// Send the action performed event.
    case actionPerformed(Protocol_Chat_V1_StreamEvent.ActionPerformed)
    /// Send the message sent event.
    case sentMessage(Protocol_Chat_V1_StreamEvent.MessageSent)
    /// Send the message updated event.
    case editedMessage(Protocol_Chat_V1_StreamEvent.MessageUpdated)
    /// Send the message deleted event.
    case deletedMessage(Protocol_Chat_V1_StreamEvent.MessageDeleted)
    /// Send the channel created event.
    case createdChannel(Protocol_Chat_V1_StreamEvent.ChannelCreated)
    /// Send the channel updated event.
    case editedChannel(Protocol_Chat_V1_StreamEvent.ChannelUpdated)
    /// Send the channel deleted event.
    case deletedChannel(Protocol_Chat_V1_StreamEvent.ChannelDeleted)
    /// Send the guild updated event.
    case editedGuild(Protocol_Chat_V1_StreamEvent.GuildUpdated)
    /// Send the guild deleted event.
    case deletedGuild(Protocol_Chat_V1_StreamEvent.GuildDeleted)
    /// Send the member joined event.
    case joinedMember(Protocol_Chat_V1_StreamEvent.MemberJoined)
    /// Send the member left event.
    case leftMember(Protocol_Chat_V1_StreamEvent.MemberLeft)
    /// Send the typing event.
    case typing(Protocol_Chat_V1_StreamEvent.Typing)
    /// Send the role created event.
    case roleCreated(Protocol_Chat_V1_StreamEvent.RoleCreated)
    /// Send the role deleted event.
    case roleDeleted(Protocol_Chat_V1_StreamEvent.RoleDeleted)
    /// Send the role moved event.
    case roleMoved(Protocol_Chat_V1_StreamEvent.RoleMoved)
    /// Send the role updated event.
    case roleUpdated(Protocol_Chat_V1_StreamEvent.RoleUpdated)
    /// Send the role perms updated event.
    case rolePermsUpdated(Protocol_Chat_V1_StreamEvent.RolePermissionsUpdated)
    /// Send the user roles updated event.
    case userRolesUpdated(Protocol_Chat_V1_StreamEvent.UserRolesUpdated)
    /// Send the permission updated event.
    case permissionUpdated(Protocol_Chat_V1_StreamEvent.PermissionUpdated)
    /// The channels have been completely reordered.
    case channelsReordered(Protocol_Chat_V1_StreamEvent.ChannelsReordered)
    /// Send the channel position updated event.
    case editedChannelPosition(Protocol_Chat_V1_StreamEvent.ChannelPositionUpdated)
    /// Send the message pinned event.
    case messagePinned(Protocol_Chat_V1_StreamEvent.MessagePinned)
    /// Send the message unpinned event.
    case messageUnpinned(Protocol_Chat_V1_StreamEvent.MessageUnpinned)
    /// Send the reaction updated event.
    case reactionUpdated(Protocol_Chat_V1_StreamEvent.ReactionUpdated)
    /// Send the owner added event.
    case ownerAdded(Protocol_Chat_V1_StreamEvent.OwnerAdded)
    /// Send the owner removed event.
    case ownerRemoved(Protocol_Chat_V1_StreamEvent.OwnerRemoved)
    /// Send the guild invite received event.
    case inviteReceived(Protocol_Chat_V1_StreamEvent.InviteReceived)
    /// Send the guild invite rejected event.
    case inviteRejected(Protocol_Chat_V1_StreamEvent.InviteRejected)

  #if !swift(>=4.1)
    static func ==(lhs: Protocol_Chat_V1_StreamEvent.OneOf_Event, rhs: Protocol_Chat_V1_StreamEvent.OneOf_Event) -> Bool {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch (lhs, rhs) {
      case (.guildAddedToList, .guildAddedToList): return {
        guard case .guildAddedToList(let l) = lhs, case .guildAddedToList(let r) = rhs else { preconditionFailure() }
        return l == r
      }()
      case (.guildRemovedFromList, .guildRemovedFromList): return {
        guard case .guildRemovedFromList(let l) = lhs, case .guildRemovedFromList(let r) = rhs else { preconditionFailure() }
        return l == r
      }()
      case (.actionPerformed, .actionPerformed): return {
        guard case .actionPerformed(let l) = lhs, case .actionPerformed(let r) = rhs else { preconditionFailure() }
        return l == r
      }()
      case (.sentMessage, .sentMessage): return {
        guard case .sentMessage(let l) = lhs, case .sentMessage(let r) = rhs else { preconditionFailure() }
        return l == r
      }()
      case (.editedMessage, .editedMessage): return {
        guard case .editedMessage(let l) = lhs, case .editedMessage(let r) = rhs else { preconditionFailure() }
        return l == r
      }()
      case (.deletedMessage, .deletedMessage): return {
        guard case .deletedMessage(let l) = lhs, case .deletedMessage(let r) = rhs else { preconditionFailure() }
        return l == r
      }()
      case (.createdChannel, .createdChannel): return {
        guard case .createdChannel(let l) = lhs, case .createdChannel(let r) = rhs else { preconditionFailure() }
        return l == r
      }()
      case (.editedChannel, .editedChannel): return {
        guard case .editedChannel(let l) = lhs, case .editedChannel(let r) = rhs else { preconditionFailure() }
        return l == r
      }()
      case (.deletedChannel, .deletedChannel): return {
        guard case .deletedChannel(let l) = lhs, case .deletedChannel(let r) = rhs else { preconditionFailure() }
        return l == r
      }()
      case (.editedGuild, .editedGuild): return {
        guard case .editedGuild(let l) = lhs, case .editedGuild(let r) = rhs else { preconditionFailure() }
        return l == r
      }()
      case (.deletedGuild, .deletedGuild): return {
        guard case .deletedGuild(let l) = lhs, case .deletedGuild(let r) = rhs else { preconditionFailure() }
        return l == r
      }()
      case (.joinedMember, .joinedMember): return {
        guard case .joinedMember(let l) = lhs, case .joinedMember(let r) = rhs else { preconditionFailure() }
        return l == r
      }()
      case (.leftMember, .leftMember): return {
        guard case .leftMember(let l) = lhs, case .leftMember(let r) = rhs else { preconditionFailure() }
        return l == r
      }()
      case (.typing, .typing): return {
        guard case .typing(let l) = lhs, case .typing(let r) = rhs else { preconditionFailure() }
        return l == r
      }()
      case (.roleCreated, .roleCreated): return {
        guard case .roleCreated(let l) = lhs, case .roleCreated(let r) = rhs else { preconditionFailure() }
        return l == r
      }()
      case (.roleDeleted, .roleDeleted): return {
        guard case .roleDeleted(let l) = lhs, case .roleDeleted(let r) = rhs else { preconditionFailure() }
        return l == r
      }()
      case (.roleMoved, .roleMoved): return {
        guard case .roleMoved(let l) = lhs, case .roleMoved(let r) = rhs else { preconditionFailure() }
        return l == r
      }()
      case (.roleUpdated, .roleUpdated): return {
        guard case .roleUpdated(let l) = lhs, case .roleUpdated(let r) = rhs else { preconditionFailure() }
        return l == r
      }()
      case (.rolePermsUpdated, .rolePermsUpdated): return {
        guard case .rolePermsUpdated(let l) = lhs, case .rolePermsUpdated(let r) = rhs else { preconditionFailure() }
        return l == r
      }()
      case (.userRolesUpdated, .userRolesUpdated): return {
        guard case .userRolesUpdated(let l) = lhs, case .userRolesUpdated(let r) = rhs else { preconditionFailure() }
        return l == r
      }()
      case (.permissionUpdated, .permissionUpdated): return {
        guard case .permissionUpdated(let l) = lhs, case .permissionUpdated(let r) = rhs else { preconditionFailure() }
        return l == r
      }()
      case (.channelsReordered, .channelsReordered): return {
        guard case .channelsReordered(let l) = lhs, case .channelsReordered(let r) = rhs else { preconditionFailure() }
        return l == r
      }()
      case (.editedChannelPosition, .editedChannelPosition): return {
        guard case .editedChannelPosition(let l) = lhs, case .editedChannelPosition(let r) = rhs else { preconditionFailure() }
        return l == r
      }()
      case (.messagePinned, .messagePinned): return {
        guard case .messagePinned(let l) = lhs, case .messagePinned(let r) = rhs else { preconditionFailure() }
        return l == r
      }()
      case (.messageUnpinned, .messageUnpinned): return {
        guard case .messageUnpinned(let l) = lhs, case .messageUnpinned(let r) = rhs else { preconditionFailure() }
        return l == r
      }()
      case (.reactionUpdated, .reactionUpdated): return {
        guard case .reactionUpdated(let l) = lhs, case .reactionUpdated(let r) = rhs else { preconditionFailure() }
        return l == r
      }()
      case (.ownerAdded, .ownerAdded): return {
        guard case .ownerAdded(let l) = lhs, case .ownerAdded(let r) = rhs else { preconditionFailure() }
        return l == r
      }()
      case (.ownerRemoved, .ownerRemoved): return {
        guard case .ownerRemoved(let l) = lhs, case .ownerRemoved(let r) = rhs else { preconditionFailure() }
        return l == r
      }()
      case (.inviteReceived, .inviteReceived): return {
        guard case .inviteReceived(let l) = lhs, case .inviteReceived(let r) = rhs else { preconditionFailure() }
        return l == r
      }()
      case (.inviteRejected, .inviteRejected): return {
        guard case .inviteRejected(let l) = lhs, case .inviteRejected(let r) = rhs else { preconditionFailure() }
        return l == r
      }()
      default: return false
      }
    }
  #endif
  }

  /// Event sent when a new message is sent.
  struct MessageSent {
    // SwiftProtobuf.Message conformance is added in an extension below. See the
    // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
    // methods supported on all messages.

    /// ID that is sent by your client it can use to confirm that the message is sent.
    var echoID: UInt64 {
      get {return _echoID ?? 0}
      set {_echoID = newValue}
    }
    /// Returns true if `echoID` has been explicitly set.
    var hasEchoID: Bool {return self._echoID != nil}
    /// Clears the value of `echoID`. Subsequent reads from it will return its default value.
    mutating func clearEchoID() {self._echoID = nil}

    /// Guild ID of the guild where this event happened.
    var guildID: UInt64 = 0

    /// Channel ID of the channel where this event happened.
    var channelID: UInt64 = 0

    /// Message ID of the message that was updated.
    var messageID: UInt64 = 0

    /// The actual message.
    var message: Protocol_Chat_V1_Message {
      get {return _message ?? Protocol_Chat_V1_Message()}
      set {_message = newValue}
    }
    /// Returns true if `message` has been explicitly set.
    var hasMessage: Bool {return self._message != nil}
    /// Clears the value of `message`. Subsequent reads from it will return its default value.
    mutating func clearMessage() {self._message = nil}

    var unknownFields = SwiftProtobuf.UnknownStorage()

    init() {}

    fileprivate var _echoID: UInt64? = nil
    fileprivate var _message: Protocol_Chat_V1_Message? = nil
  }

  /// Event sent when a message's text content is updated.
  struct MessageUpdated {
    // SwiftProtobuf.Message conformance is added in an extension below. See the
    // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
    // methods supported on all messages.

    /// Guild ID of the guild where this event happened.
    var guildID: UInt64 = 0

    /// Channel ID of the channel where this event happened.
    var channelID: UInt64 = 0

    /// Message ID of the message that was updated.
    var messageID: UInt64 = 0

    /// When this message was edited, in milliseconds since unix epoch
    var editedAt: UInt64 = 0

    /// New message content.
    var newContent: Protocol_Chat_V1_FormattedText {
      get {return _newContent ?? Protocol_Chat_V1_FormattedText()}
      set {_newContent = newValue}
    }
    /// Returns true if `newContent` has been explicitly set.
    var hasNewContent: Bool {return self._newContent != nil}
    /// Clears the value of `newContent`. Subsequent reads from it will return its default value.
    mutating func clearNewContent() {self._newContent = nil}

    var unknownFields = SwiftProtobuf.UnknownStorage()

    init() {}

    fileprivate var _newContent: Protocol_Chat_V1_FormattedText? = nil
  }

  /// Event sent when a message is deleted.
  struct MessageDeleted {
    // SwiftProtobuf.Message conformance is added in an extension below. See the
    // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
    // methods supported on all messages.

    /// Guild ID of the guild where this event happened.
    var guildID: UInt64 = 0

    /// Channel ID of the channel where this event happened.
    var channelID: UInt64 = 0

    /// Message ID of the message that was deleted.
    var messageID: UInt64 = 0

    var unknownFields = SwiftProtobuf.UnknownStorage()

    init() {}
  }

  /// Event sent when a new channel is created.
  struct ChannelCreated {
    // SwiftProtobuf.Message conformance is added in an extension below. See the
    // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
    // methods supported on all messages.

    /// Guild ID of the guild where this event happened.
    var guildID: UInt64 = 0

    /// Channel ID of the channel where this event happened.
    var channelID: UInt64 = 0

    /// Name of this channel.
    var name: String = String()

    /// The position in the channel list.
    var position: Protocol_Harmonytypes_V1_ItemPosition {
      get {return _position ?? Protocol_Harmonytypes_V1_ItemPosition()}
      set {_position = newValue}
    }
    /// Returns true if `position` has been explicitly set.
    var hasPosition: Bool {return self._position != nil}
    /// Clears the value of `position`. Subsequent reads from it will return its default value.
    mutating func clearPosition() {self._position = nil}

    /// The kind of this channel.
    var kind: Protocol_Chat_V1_ChannelKind = .textUnspecified

    /// Metadata for this channel.
    var metadata: Protocol_Harmonytypes_V1_Metadata {
      get {return _metadata ?? Protocol_Harmonytypes_V1_Metadata()}
      set {_metadata = newValue}
    }
    /// Returns true if `metadata` has been explicitly set.
    var hasMetadata: Bool {return self._metadata != nil}
    /// Clears the value of `metadata`. Subsequent reads from it will return its default value.
    mutating func clearMetadata() {self._metadata = nil}

    var unknownFields = SwiftProtobuf.UnknownStorage()

    init() {}

    fileprivate var _position: Protocol_Harmonytypes_V1_ItemPosition? = nil
    fileprivate var _metadata: Protocol_Harmonytypes_V1_Metadata? = nil
  }

  /// Event sent when a channel's information is changed.
  struct ChannelUpdated {
    // SwiftProtobuf.Message conformance is added in an extension below. See the
    // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
    // methods supported on all messages.

    /// Guild ID of the guild where this event happened.
    var guildID: UInt64 = 0

    /// Channel ID of the channel that was changed.
    var channelID: UInt64 = 0

    /// The new name of the channel. 
    var newName: String {
      get {return _newName ?? String()}
      set {_newName = newValue}
    }
    /// Returns true if `newName` has been explicitly set.
    var hasNewName: Bool {return self._newName != nil}
    /// Clears the value of `newName`. Subsequent reads from it will return its default value.
    mutating func clearNewName() {self._newName = nil}

    /// The new metadata of the channel.
    var newMetadata: Protocol_Harmonytypes_V1_Metadata {
      get {return _newMetadata ?? Protocol_Harmonytypes_V1_Metadata()}
      set {_newMetadata = newValue}
    }
    /// Returns true if `newMetadata` has been explicitly set.
    var hasNewMetadata: Bool {return self._newMetadata != nil}
    /// Clears the value of `newMetadata`. Subsequent reads from it will return its default value.
    mutating func clearNewMetadata() {self._newMetadata = nil}

    var unknownFields = SwiftProtobuf.UnknownStorage()

    init() {}

    fileprivate var _newName: String? = nil
    fileprivate var _newMetadata: Protocol_Harmonytypes_V1_Metadata? = nil
  }

  /// Event sent when a channel's position in the channel list is changed.
  struct ChannelPositionUpdated {
    // SwiftProtobuf.Message conformance is added in an extension below. See the
    // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
    // methods supported on all messages.

    /// Guild ID of the guild where this event happened.
    var guildID: UInt64 = 0

    /// Channel ID of the channel that was changed.
    var channelID: UInt64 = 0

    /// The new position of the channel.
    var newPosition: Protocol_Harmonytypes_V1_ItemPosition {
      get {return _newPosition ?? Protocol_Harmonytypes_V1_ItemPosition()}
      set {_newPosition = newValue}
    }
    /// Returns true if `newPosition` has been explicitly set.
    var hasNewPosition: Bool {return self._newPosition != nil}
    /// Clears the value of `newPosition`. Subsequent reads from it will return its default value.
    mutating func clearNewPosition() {self._newPosition = nil}

    var unknownFields = SwiftProtobuf.UnknownStorage()

    init() {}

    fileprivate var _newPosition: Protocol_Harmonytypes_V1_ItemPosition? = nil
  }

  /// Event sent when all channels have been reordered
  struct ChannelsReordered {
    // SwiftProtobuf.Message conformance is added in an extension below. See the
    // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
    // methods supported on all messages.

    /// guild_id: the guild whose channels are being reordered
    var guildID: UInt64 = 0

    /// channel_ids: the new order of channel IDs
    var channelIds: [UInt64] = []

    var unknownFields = SwiftProtobuf.UnknownStorage()

    init() {}
  }

  /// Event sent when a channel is deleted.
  struct ChannelDeleted {
    // SwiftProtobuf.Message conformance is added in an extension below. See the
    // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
    // methods supported on all messages.

    /// Guild ID of the guild where this event happened.
    var guildID: UInt64 = 0

    /// Channel ID of the channel that was deleted.
    var channelID: UInt64 = 0

    var unknownFields = SwiftProtobuf.UnknownStorage()

    init() {}
  }

  /// Event sent when a guild's information is changed.
  struct GuildUpdated {
    // SwiftProtobuf.Message conformance is added in an extension below. See the
    // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
    // methods supported on all messages.

    /// Guild ID of the guild that was changed.
    var guildID: UInt64 = 0

    /// The new name of the guild.
    var newName: String {
      get {return _newName ?? String()}
      set {_newName = newValue}
    }
    /// Returns true if `newName` has been explicitly set.
    var hasNewName: Bool {return self._newName != nil}
    /// Clears the value of `newName`. Subsequent reads from it will return its default value.
    mutating func clearNewName() {self._newName = nil}

    /// The new picture of the guild.
    var newPicture: String {
      get {return _newPicture ?? String()}
      set {_newPicture = newValue}
    }
    /// Returns true if `newPicture` has been explicitly set.
    var hasNewPicture: Bool {return self._newPicture != nil}
    /// Clears the value of `newPicture`. Subsequent reads from it will return its default value.
    mutating func clearNewPicture() {self._newPicture = nil}

    /// The new metadata of the guild.
    var newMetadata: Protocol_Harmonytypes_V1_Metadata {
      get {return _newMetadata ?? Protocol_Harmonytypes_V1_Metadata()}
      set {_newMetadata = newValue}
    }
    /// Returns true if `newMetadata` has been explicitly set.
    var hasNewMetadata: Bool {return self._newMetadata != nil}
    /// Clears the value of `newMetadata`. Subsequent reads from it will return its default value.
    mutating func clearNewMetadata() {self._newMetadata = nil}

    var unknownFields = SwiftProtobuf.UnknownStorage()

    init() {}

    fileprivate var _newName: String? = nil
    fileprivate var _newPicture: String? = nil
    fileprivate var _newMetadata: Protocol_Harmonytypes_V1_Metadata? = nil
  }

  /// Event sent when a guild is deleted.
  struct GuildDeleted {
    // SwiftProtobuf.Message conformance is added in an extension below. See the
    // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
    // methods supported on all messages.

    /// Guild ID of the guild that was deleted.
    var guildID: UInt64 = 0

    var unknownFields = SwiftProtobuf.UnknownStorage()

    init() {}
  }

  /// Event sent a user joins to a guild.
  struct MemberJoined {
    // SwiftProtobuf.Message conformance is added in an extension below. See the
    // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
    // methods supported on all messages.

    /// Member ID of the member that joined the guild.
    var memberID: UInt64 = 0

    /// Guild ID of the guild where this event happened.
    var guildID: UInt64 = 0

    var unknownFields = SwiftProtobuf.UnknownStorage()

    init() {}
  }

  /// Event sent when a member of a guild leaves said guild for whatever reason.
  struct MemberLeft {
    // SwiftProtobuf.Message conformance is added in an extension below. See the
    // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
    // methods supported on all messages.

    /// User ID of the member that left the guild.
    var memberID: UInt64 = 0

    /// Guild ID of the guild where this event happened.
    var guildID: UInt64 = 0

    /// Why this member left the guild.
    var leaveReason: Protocol_Chat_V1_LeaveReason = .willinglyUnspecified

    var unknownFields = SwiftProtobuf.UnknownStorage()

    init() {}
  }

  /// Event sent when you join a new guild.
  struct GuildAddedToList {
    // SwiftProtobuf.Message conformance is added in an extension below. See the
    // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
    // methods supported on all messages.

    /// Guild ID of the guild where this event happened.
    var guildID: UInt64 = 0

    /// The homeserver this guild is on.
    var homeserver: String = String()

    var unknownFields = SwiftProtobuf.UnknownStorage()

    init() {}
  }

  /// Event sent when you leave a guild.
  struct GuildRemovedFromList {
    // SwiftProtobuf.Message conformance is added in an extension below. See the
    // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
    // methods supported on all messages.

    /// Guild ID of the guild where this event happened.
    var guildID: UInt64 = 0

    /// The homeserver this guild is on.
    var homeserver: String = String()

    var unknownFields = SwiftProtobuf.UnknownStorage()

    init() {}
  }

  /// Event sent when an action is performed.
  struct ActionPerformed {
    // SwiftProtobuf.Message conformance is added in an extension below. See the
    // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
    // methods supported on all messages.

    /// Guild ID of the guild where this event happened.
    var guildID: UInt64 = 0

    /// Channel ID of the channel where this event happened.
    var channelID: UInt64 = 0

    /// Message ID where this event happened.
    var messageID: UInt64 = 0

    /// User ID of the user that triggered the action
    var userID: UInt64 = 0

    /// The action data payload
    var payload: Protocol_Chat_V1_ActionPayload {
      get {return _payload ?? Protocol_Chat_V1_ActionPayload()}
      set {_payload = newValue}
    }
    /// Returns true if `payload` has been explicitly set.
    var hasPayload: Bool {return self._payload != nil}
    /// Clears the value of `payload`. Subsequent reads from it will return its default value.
    mutating func clearPayload() {self._payload = nil}

    var unknownFields = SwiftProtobuf.UnknownStorage()

    init() {}

    fileprivate var _payload: Protocol_Chat_V1_ActionPayload? = nil
  }

  /// Event sent when a role's position in the role list is changed.
  struct RoleMoved {
    // SwiftProtobuf.Message conformance is added in an extension below. See the
    // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
    // methods supported on all messages.

    /// Guild ID of the guild where this event happened.
    var guildID: UInt64 = 0

    /// Role ID of the role that was moved.
    var roleID: UInt64 = 0

    /// New position of the role.
    var newPosition: Protocol_Harmonytypes_V1_ItemPosition {
      get {return _newPosition ?? Protocol_Harmonytypes_V1_ItemPosition()}
      set {_newPosition = newValue}
    }
    /// Returns true if `newPosition` has been explicitly set.
    var hasNewPosition: Bool {return self._newPosition != nil}
    /// Clears the value of `newPosition`. Subsequent reads from it will return its default value.
    mutating func clearNewPosition() {self._newPosition = nil}

    var unknownFields = SwiftProtobuf.UnknownStorage()

    init() {}

    fileprivate var _newPosition: Protocol_Harmonytypes_V1_ItemPosition? = nil
  }

  /// Event sent when a role is deleted.
  struct RoleDeleted {
    // SwiftProtobuf.Message conformance is added in an extension below. See the
    // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
    // methods supported on all messages.

    /// Guild ID of the guild where this event happened.
    var guildID: UInt64 = 0

    /// Role ID of the role that was deleted.
    var roleID: UInt64 = 0

    var unknownFields = SwiftProtobuf.UnknownStorage()

    init() {}
  }

  /// Event sent when a role is created.
  struct RoleCreated {
    // SwiftProtobuf.Message conformance is added in an extension below. See the
    // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
    // methods supported on all messages.

    /// Guild ID of the guild where this event happened.
    var guildID: UInt64 = 0

    /// Role ID of the role that was created.
    var roleID: UInt64 = 0

    /// The name of the role.
    var name: String = String()

    /// The color of the role.
    var color: Int32 = 0

    /// The hoist status of the role.
    var hoist: Bool = false

    /// The pingable status of the role.
    var pingable: Bool = false

    var unknownFields = SwiftProtobuf.UnknownStorage()

    init() {}
  }

  /// Event sent when a role's information is changed.
  struct RoleUpdated {
    // SwiftProtobuf.Message conformance is added in an extension below. See the
    // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
    // methods supported on all messages.

    /// Guild ID of the guild where this event happened.
    var guildID: UInt64 = 0

    /// Role ID of the role that was changed.
    var roleID: UInt64 = 0

    /// The new name of the role.
    var newName: String {
      get {return _newName ?? String()}
      set {_newName = newValue}
    }
    /// Returns true if `newName` has been explicitly set.
    var hasNewName: Bool {return self._newName != nil}
    /// Clears the value of `newName`. Subsequent reads from it will return its default value.
    mutating func clearNewName() {self._newName = nil}

    /// The new color of the role.
    var newColor: Int32 {
      get {return _newColor ?? 0}
      set {_newColor = newValue}
    }
    /// Returns true if `newColor` has been explicitly set.
    var hasNewColor: Bool {return self._newColor != nil}
    /// Clears the value of `newColor`. Subsequent reads from it will return its default value.
    mutating func clearNewColor() {self._newColor = nil}

    /// The new hoist status of the role.
    var newHoist: Bool {
      get {return _newHoist ?? false}
      set {_newHoist = newValue}
    }
    /// Returns true if `newHoist` has been explicitly set.
    var hasNewHoist: Bool {return self._newHoist != nil}
    /// Clears the value of `newHoist`. Subsequent reads from it will return its default value.
    mutating func clearNewHoist() {self._newHoist = nil}

    /// The new pingable status of the role.
    var newPingable: Bool {
      get {return _newPingable ?? false}
      set {_newPingable = newValue}
    }
    /// Returns true if `newPingable` has been explicitly set.
    var hasNewPingable: Bool {return self._newPingable != nil}
    /// Clears the value of `newPingable`. Subsequent reads from it will return its default value.
    mutating func clearNewPingable() {self._newPingable = nil}

    var unknownFields = SwiftProtobuf.UnknownStorage()

    init() {}

    fileprivate var _newName: String? = nil
    fileprivate var _newColor: Int32? = nil
    fileprivate var _newHoist: Bool? = nil
    fileprivate var _newPingable: Bool? = nil
  }

  /// Event sent when a role's permissions are changed.
  ///
  /// This event will only be sent to users with the "guild.manage" permission.
  struct RolePermissionsUpdated {
    // SwiftProtobuf.Message conformance is added in an extension below. See the
    // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
    // methods supported on all messages.

    /// Guild ID of the guild where this event happened.
    var guildID: UInt64 = 0

    /// Channel ID of the channel where this event happened.
    var channelID: UInt64 {
      get {return _channelID ?? 0}
      set {_channelID = newValue}
    }
    /// Returns true if `channelID` has been explicitly set.
    var hasChannelID: Bool {return self._channelID != nil}
    /// Clears the value of `channelID`. Subsequent reads from it will return its default value.
    mutating func clearChannelID() {self._channelID = nil}

    /// Role ID of the role that had it's permissions changed.
    var roleID: UInt64 = 0

    /// The new permissions.
    var newPerms: [Protocol_Chat_V1_Permission] = []

    var unknownFields = SwiftProtobuf.UnknownStorage()

    init() {}

    fileprivate var _channelID: UInt64? = nil
  }

  /// Event sent when a user's roles are changed.
  struct UserRolesUpdated {
    // SwiftProtobuf.Message conformance is added in an extension below. See the
    // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
    // methods supported on all messages.

    /// Guild ID of the guild where this event happened.
    var guildID: UInt64 = 0

    /// User ID of the user that had it's roles changed.
    var userID: UInt64 = 0

    /// The new role IDs.
    var newRoleIds: [UInt64] = []

    var unknownFields = SwiftProtobuf.UnknownStorage()

    init() {}
  }

  /// Event sent when a user sends a typing notification in a guild channel.
  struct Typing {
    // SwiftProtobuf.Message conformance is added in an extension below. See the
    // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
    // methods supported on all messages.

    /// User ID of the user that sent the typing notification.
    var userID: UInt64 = 0

    /// Guild ID of the guild where this event happened.
    var guildID: UInt64 = 0

    /// Channel ID of the channel where this event happened.
    var channelID: UInt64 = 0

    var unknownFields = SwiftProtobuf.UnknownStorage()

    init() {}
  }

  /// Event sent when a permission is changed that matters to you.
  ///
  /// Servers should calculate which users to send this event to when a permission is set.
  /// It should only be sent if a user is subscribed to the guild the permission pertains to.
  struct PermissionUpdated {
    // SwiftProtobuf.Message conformance is added in an extension below. See the
    // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
    // methods supported on all messages.

    /// Guild ID of the guild where this event happened.
    var guildID: UInt64 = 0

    /// Channel ID of the channel where this event happened.
    var channelID: UInt64 {
      get {return _channelID ?? 0}
      set {_channelID = newValue}
    }
    /// Returns true if `channelID` has been explicitly set.
    var hasChannelID: Bool {return self._channelID != nil}
    /// Clears the value of `channelID`. Subsequent reads from it will return its default value.
    mutating func clearChannelID() {self._channelID = nil}

    /// The permission node that was changed.
    var query: String = String()

    /// Whether you have the permission or not.
    var ok: Bool = false

    var unknownFields = SwiftProtobuf.UnknownStorage()

    init() {}

    fileprivate var _channelID: UInt64? = nil
  }

  /// Sent when a message is pinned in a guild channel.
  ///
  /// Should only be sent to users who have the "message.view" permission for
  /// the guild channel where the message was pinned.
  struct MessagePinned {
    // SwiftProtobuf.Message conformance is added in an extension below. See the
    // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
    // methods supported on all messages.

    /// Guild ID of the guild where this event occured.
    var guildID: UInt64 = 0

    /// Channel ID of the channel where this event occured.
    var channelID: UInt64 = 0

    /// Message ID of the message that was pinned.
    var messageID: UInt64 = 0

    var unknownFields = SwiftProtobuf.UnknownStorage()

    init() {}
  }

  /// Sent when a message is unpinned in a guild channel.
  ///
  /// Should only be sent to users who have the "message.view" permission for
  /// the guild channel where the message was unpinned.
  struct MessageUnpinned {
    // SwiftProtobuf.Message conformance is added in an extension below. See the
    // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
    // methods supported on all messages.

    /// Guild ID of the guild where this event occured.
    var guildID: UInt64 = 0

    /// Channel ID of the channel where this event occured.
    var channelID: UInt64 = 0

    /// Message ID of the message that was unpinned.
    var messageID: UInt64 = 0

    var unknownFields = SwiftProtobuf.UnknownStorage()

    init() {}
  }

  /// Sent when a message's reaction is changed.
  struct ReactionUpdated {
    // SwiftProtobuf.Message conformance is added in an extension below. See the
    // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
    // methods supported on all messages.

    /// Guild ID of the guild where this event occured.
    var guildID: UInt64 = 0

    /// Channel ID of the channel where this event occured.
    var channelID: UInt64 = 0

    /// Message ID of the message that had a reaction updated.
    var messageID: UInt64 = 0

    /// The reaction.
    var reaction: Protocol_Chat_V1_Reaction {
      get {return _reaction ?? Protocol_Chat_V1_Reaction()}
      set {_reaction = newValue}
    }
    /// Returns true if `reaction` has been explicitly set.
    var hasReaction: Bool {return self._reaction != nil}
    /// Clears the value of `reaction`. Subsequent reads from it will return its default value.
    mutating func clearReaction() {self._reaction = nil}

    var unknownFields = SwiftProtobuf.UnknownStorage()

    init() {}

    fileprivate var _reaction: Protocol_Chat_V1_Reaction? = nil
  }

  /// Sent when there's a new owner.
  struct OwnerAdded {
    // SwiftProtobuf.Message conformance is added in an extension below. See the
    // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
    // methods supported on all messages.

    /// User ID of the new owner.
    var userID: UInt64 = 0

    var unknownFields = SwiftProtobuf.UnknownStorage()

    init() {}
  }

  /// Sent when an owner gives up their ownership.
  struct OwnerRemoved {
    // SwiftProtobuf.Message conformance is added in an extension below. See the
    // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
    // methods supported on all messages.

    /// User ID of the user who is no longer owner.
    var userID: UInt64 = 0

    var unknownFields = SwiftProtobuf.UnknownStorage()

    init() {}
  }

  /// Sent when a guild invite is received.
  struct InviteReceived {
    // SwiftProtobuf.Message conformance is added in an extension below. See the
    // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
    // methods supported on all messages.

    /// ID of the invite received.
    var inviteID: String = String()

    /// Server ID of the server the inviter is on.
    var serverID: String {
      get {return _serverID ?? String()}
      set {_serverID = newValue}
    }
    /// Returns true if `serverID` has been explicitly set.
    var hasServerID: Bool {return self._serverID != nil}
    /// Clears the value of `serverID`. Subsequent reads from it will return its default value.
    mutating func clearServerID() {self._serverID = nil}

    /// User ID of the inviter.
    var inviterID: UInt64 = 0

    var unknownFields = SwiftProtobuf.UnknownStorage()

    init() {}

    fileprivate var _serverID: String? = nil
  }

  /// Sent when a guild invite is rejected by the invitee.
  struct InviteRejected {
    // SwiftProtobuf.Message conformance is added in an extension below. See the
    // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
    // methods supported on all messages.

    /// Guild ID of the guild that this occured for.
    var guildID: UInt64 = 0

    /// ID of the invite rejected.
    var inviteID: String = String()

    /// User ID of the invitee.
    var userID: UInt64 = 0

    var unknownFields = SwiftProtobuf.UnknownStorage()

    init() {}
  }

  init() {}
}

// MARK: - Code below here is support for the SwiftProtobuf runtime.

fileprivate let _protobuf_package = "protocol.chat.v1"

extension Protocol_Chat_V1_StreamEventsRequest: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static let protoMessageName: String = _protobuf_package + ".StreamEventsRequest"
  static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .standard(proto: "subscribe_to_guild"),
    2: .standard(proto: "subscribe_to_actions"),
    3: .standard(proto: "subscribe_to_homeserver_events"),
  ]

  mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try {
        var v: Protocol_Chat_V1_StreamEventsRequest.SubscribeToGuild?
        var hadOneofValue = false
        if let current = self.request {
          hadOneofValue = true
          if case .subscribeToGuild(let m) = current {v = m}
        }
        try decoder.decodeSingularMessageField(value: &v)
        if let v = v {
          if hadOneofValue {try decoder.handleConflictingOneOf()}
          self.request = .subscribeToGuild(v)
        }
      }()
      case 2: try {
        var v: Protocol_Chat_V1_StreamEventsRequest.SubscribeToActions?
        var hadOneofValue = false
        if let current = self.request {
          hadOneofValue = true
          if case .subscribeToActions(let m) = current {v = m}
        }
        try decoder.decodeSingularMessageField(value: &v)
        if let v = v {
          if hadOneofValue {try decoder.handleConflictingOneOf()}
          self.request = .subscribeToActions(v)
        }
      }()
      case 3: try {
        var v: Protocol_Chat_V1_StreamEventsRequest.SubscribeToHomeserverEvents?
        var hadOneofValue = false
        if let current = self.request {
          hadOneofValue = true
          if case .subscribeToHomeserverEvents(let m) = current {v = m}
        }
        try decoder.decodeSingularMessageField(value: &v)
        if let v = v {
          if hadOneofValue {try decoder.handleConflictingOneOf()}
          self.request = .subscribeToHomeserverEvents(v)
        }
      }()
      default: break
      }
    }
  }

  func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    // The use of inline closures is to circumvent an issue where the compiler
    // allocates stack space for every case branch when no optimizations are
    // enabled. https://github.com/apple/swift-protobuf/issues/1034
    switch self.request {
    case .subscribeToGuild?: try {
      guard case .subscribeToGuild(let v)? = self.request else { preconditionFailure() }
      try visitor.visitSingularMessageField(value: v, fieldNumber: 1)
    }()
    case .subscribeToActions?: try {
      guard case .subscribeToActions(let v)? = self.request else { preconditionFailure() }
      try visitor.visitSingularMessageField(value: v, fieldNumber: 2)
    }()
    case .subscribeToHomeserverEvents?: try {
      guard case .subscribeToHomeserverEvents(let v)? = self.request else { preconditionFailure() }
      try visitor.visitSingularMessageField(value: v, fieldNumber: 3)
    }()
    case nil: break
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  static func ==(lhs: Protocol_Chat_V1_StreamEventsRequest, rhs: Protocol_Chat_V1_StreamEventsRequest) -> Bool {
    if lhs.request != rhs.request {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Protocol_Chat_V1_StreamEventsRequest.SubscribeToGuild: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static let protoMessageName: String = Protocol_Chat_V1_StreamEventsRequest.protoMessageName + ".SubscribeToGuild"
  static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .standard(proto: "guild_id"),
  ]

  mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularUInt64Field(value: &self.guildID) }()
      default: break
      }
    }
  }

  func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if self.guildID != 0 {
      try visitor.visitSingularUInt64Field(value: self.guildID, fieldNumber: 1)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  static func ==(lhs: Protocol_Chat_V1_StreamEventsRequest.SubscribeToGuild, rhs: Protocol_Chat_V1_StreamEventsRequest.SubscribeToGuild) -> Bool {
    if lhs.guildID != rhs.guildID {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Protocol_Chat_V1_StreamEventsRequest.SubscribeToActions: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static let protoMessageName: String = Protocol_Chat_V1_StreamEventsRequest.protoMessageName + ".SubscribeToActions"
  static let _protobuf_nameMap = SwiftProtobuf._NameMap()

  mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let _ = try decoder.nextFieldNumber() {
    }
  }

  func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    try unknownFields.traverse(visitor: &visitor)
  }

  static func ==(lhs: Protocol_Chat_V1_StreamEventsRequest.SubscribeToActions, rhs: Protocol_Chat_V1_StreamEventsRequest.SubscribeToActions) -> Bool {
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Protocol_Chat_V1_StreamEventsRequest.SubscribeToHomeserverEvents: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static let protoMessageName: String = Protocol_Chat_V1_StreamEventsRequest.protoMessageName + ".SubscribeToHomeserverEvents"
  static let _protobuf_nameMap = SwiftProtobuf._NameMap()

  mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let _ = try decoder.nextFieldNumber() {
    }
  }

  func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    try unknownFields.traverse(visitor: &visitor)
  }

  static func ==(lhs: Protocol_Chat_V1_StreamEventsRequest.SubscribeToHomeserverEvents, rhs: Protocol_Chat_V1_StreamEventsRequest.SubscribeToHomeserverEvents) -> Bool {
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Protocol_Chat_V1_StreamEventsResponse: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static let protoMessageName: String = _protobuf_package + ".StreamEventsResponse"
  static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "chat"),
    2: .same(proto: "emote"),
    3: .same(proto: "profile"),
  ]

  mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try {
        var v: Protocol_Chat_V1_StreamEvent?
        var hadOneofValue = false
        if let current = self.event {
          hadOneofValue = true
          if case .chat(let m) = current {v = m}
        }
        try decoder.decodeSingularMessageField(value: &v)
        if let v = v {
          if hadOneofValue {try decoder.handleConflictingOneOf()}
          self.event = .chat(v)
        }
      }()
      case 2: try {
        var v: Protocol_Emote_V1_StreamEvent?
        var hadOneofValue = false
        if let current = self.event {
          hadOneofValue = true
          if case .emote(let m) = current {v = m}
        }
        try decoder.decodeSingularMessageField(value: &v)
        if let v = v {
          if hadOneofValue {try decoder.handleConflictingOneOf()}
          self.event = .emote(v)
        }
      }()
      case 3: try {
        var v: Protocol_Profile_V1_StreamEvent?
        var hadOneofValue = false
        if let current = self.event {
          hadOneofValue = true
          if case .profile(let m) = current {v = m}
        }
        try decoder.decodeSingularMessageField(value: &v)
        if let v = v {
          if hadOneofValue {try decoder.handleConflictingOneOf()}
          self.event = .profile(v)
        }
      }()
      default: break
      }
    }
  }

  func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    // The use of inline closures is to circumvent an issue where the compiler
    // allocates stack space for every case branch when no optimizations are
    // enabled. https://github.com/apple/swift-protobuf/issues/1034
    switch self.event {
    case .chat?: try {
      guard case .chat(let v)? = self.event else { preconditionFailure() }
      try visitor.visitSingularMessageField(value: v, fieldNumber: 1)
    }()
    case .emote?: try {
      guard case .emote(let v)? = self.event else { preconditionFailure() }
      try visitor.visitSingularMessageField(value: v, fieldNumber: 2)
    }()
    case .profile?: try {
      guard case .profile(let v)? = self.event else { preconditionFailure() }
      try visitor.visitSingularMessageField(value: v, fieldNumber: 3)
    }()
    case nil: break
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  static func ==(lhs: Protocol_Chat_V1_StreamEventsResponse, rhs: Protocol_Chat_V1_StreamEventsResponse) -> Bool {
    if lhs.event != rhs.event {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Protocol_Chat_V1_StreamEvent: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static let protoMessageName: String = _protobuf_package + ".StreamEvent"
  static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .standard(proto: "guild_added_to_list"),
    2: .standard(proto: "guild_removed_from_list"),
    3: .standard(proto: "action_performed"),
    4: .standard(proto: "sent_message"),
    5: .standard(proto: "edited_message"),
    6: .standard(proto: "deleted_message"),
    7: .standard(proto: "created_channel"),
    8: .standard(proto: "edited_channel"),
    9: .standard(proto: "deleted_channel"),
    10: .standard(proto: "edited_guild"),
    11: .standard(proto: "deleted_guild"),
    12: .standard(proto: "joined_member"),
    13: .standard(proto: "left_member"),
    14: .same(proto: "typing"),
    15: .standard(proto: "role_created"),
    16: .standard(proto: "role_deleted"),
    17: .standard(proto: "role_moved"),
    18: .standard(proto: "role_updated"),
    19: .standard(proto: "role_perms_updated"),
    20: .standard(proto: "user_roles_updated"),
    21: .standard(proto: "permission_updated"),
    22: .standard(proto: "channels_reordered"),
    23: .standard(proto: "edited_channel_position"),
    24: .standard(proto: "message_pinned"),
    25: .standard(proto: "message_unpinned"),
    26: .standard(proto: "reaction_updated"),
    27: .standard(proto: "owner_added"),
    28: .standard(proto: "owner_removed"),
    29: .standard(proto: "invite_received"),
    30: .standard(proto: "invite_rejected"),
  ]

  mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try {
        var v: Protocol_Chat_V1_StreamEvent.GuildAddedToList?
        var hadOneofValue = false
        if let current = self.event {
          hadOneofValue = true
          if case .guildAddedToList(let m) = current {v = m}
        }
        try decoder.decodeSingularMessageField(value: &v)
        if let v = v {
          if hadOneofValue {try decoder.handleConflictingOneOf()}
          self.event = .guildAddedToList(v)
        }
      }()
      case 2: try {
        var v: Protocol_Chat_V1_StreamEvent.GuildRemovedFromList?
        var hadOneofValue = false
        if let current = self.event {
          hadOneofValue = true
          if case .guildRemovedFromList(let m) = current {v = m}
        }
        try decoder.decodeSingularMessageField(value: &v)
        if let v = v {
          if hadOneofValue {try decoder.handleConflictingOneOf()}
          self.event = .guildRemovedFromList(v)
        }
      }()
      case 3: try {
        var v: Protocol_Chat_V1_StreamEvent.ActionPerformed?
        var hadOneofValue = false
        if let current = self.event {
          hadOneofValue = true
          if case .actionPerformed(let m) = current {v = m}
        }
        try decoder.decodeSingularMessageField(value: &v)
        if let v = v {
          if hadOneofValue {try decoder.handleConflictingOneOf()}
          self.event = .actionPerformed(v)
        }
      }()
      case 4: try {
        var v: Protocol_Chat_V1_StreamEvent.MessageSent?
        var hadOneofValue = false
        if let current = self.event {
          hadOneofValue = true
          if case .sentMessage(let m) = current {v = m}
        }
        try decoder.decodeSingularMessageField(value: &v)
        if let v = v {
          if hadOneofValue {try decoder.handleConflictingOneOf()}
          self.event = .sentMessage(v)
        }
      }()
      case 5: try {
        var v: Protocol_Chat_V1_StreamEvent.MessageUpdated?
        var hadOneofValue = false
        if let current = self.event {
          hadOneofValue = true
          if case .editedMessage(let m) = current {v = m}
        }
        try decoder.decodeSingularMessageField(value: &v)
        if let v = v {
          if hadOneofValue {try decoder.handleConflictingOneOf()}
          self.event = .editedMessage(v)
        }
      }()
      case 6: try {
        var v: Protocol_Chat_V1_StreamEvent.MessageDeleted?
        var hadOneofValue = false
        if let current = self.event {
          hadOneofValue = true
          if case .deletedMessage(let m) = current {v = m}
        }
        try decoder.decodeSingularMessageField(value: &v)
        if let v = v {
          if hadOneofValue {try decoder.handleConflictingOneOf()}
          self.event = .deletedMessage(v)
        }
      }()
      case 7: try {
        var v: Protocol_Chat_V1_StreamEvent.ChannelCreated?
        var hadOneofValue = false
        if let current = self.event {
          hadOneofValue = true
          if case .createdChannel(let m) = current {v = m}
        }
        try decoder.decodeSingularMessageField(value: &v)
        if let v = v {
          if hadOneofValue {try decoder.handleConflictingOneOf()}
          self.event = .createdChannel(v)
        }
      }()
      case 8: try {
        var v: Protocol_Chat_V1_StreamEvent.ChannelUpdated?
        var hadOneofValue = false
        if let current = self.event {
          hadOneofValue = true
          if case .editedChannel(let m) = current {v = m}
        }
        try decoder.decodeSingularMessageField(value: &v)
        if let v = v {
          if hadOneofValue {try decoder.handleConflictingOneOf()}
          self.event = .editedChannel(v)
        }
      }()
      case 9: try {
        var v: Protocol_Chat_V1_StreamEvent.ChannelDeleted?
        var hadOneofValue = false
        if let current = self.event {
          hadOneofValue = true
          if case .deletedChannel(let m) = current {v = m}
        }
        try decoder.decodeSingularMessageField(value: &v)
        if let v = v {
          if hadOneofValue {try decoder.handleConflictingOneOf()}
          self.event = .deletedChannel(v)
        }
      }()
      case 10: try {
        var v: Protocol_Chat_V1_StreamEvent.GuildUpdated?
        var hadOneofValue = false
        if let current = self.event {
          hadOneofValue = true
          if case .editedGuild(let m) = current {v = m}
        }
        try decoder.decodeSingularMessageField(value: &v)
        if let v = v {
          if hadOneofValue {try decoder.handleConflictingOneOf()}
          self.event = .editedGuild(v)
        }
      }()
      case 11: try {
        var v: Protocol_Chat_V1_StreamEvent.GuildDeleted?
        var hadOneofValue = false
        if let current = self.event {
          hadOneofValue = true
          if case .deletedGuild(let m) = current {v = m}
        }
        try decoder.decodeSingularMessageField(value: &v)
        if let v = v {
          if hadOneofValue {try decoder.handleConflictingOneOf()}
          self.event = .deletedGuild(v)
        }
      }()
      case 12: try {
        var v: Protocol_Chat_V1_StreamEvent.MemberJoined?
        var hadOneofValue = false
        if let current = self.event {
          hadOneofValue = true
          if case .joinedMember(let m) = current {v = m}
        }
        try decoder.decodeSingularMessageField(value: &v)
        if let v = v {
          if hadOneofValue {try decoder.handleConflictingOneOf()}
          self.event = .joinedMember(v)
        }
      }()
      case 13: try {
        var v: Protocol_Chat_V1_StreamEvent.MemberLeft?
        var hadOneofValue = false
        if let current = self.event {
          hadOneofValue = true
          if case .leftMember(let m) = current {v = m}
        }
        try decoder.decodeSingularMessageField(value: &v)
        if let v = v {
          if hadOneofValue {try decoder.handleConflictingOneOf()}
          self.event = .leftMember(v)
        }
      }()
      case 14: try {
        var v: Protocol_Chat_V1_StreamEvent.Typing?
        var hadOneofValue = false
        if let current = self.event {
          hadOneofValue = true
          if case .typing(let m) = current {v = m}
        }
        try decoder.decodeSingularMessageField(value: &v)
        if let v = v {
          if hadOneofValue {try decoder.handleConflictingOneOf()}
          self.event = .typing(v)
        }
      }()
      case 15: try {
        var v: Protocol_Chat_V1_StreamEvent.RoleCreated?
        var hadOneofValue = false
        if let current = self.event {
          hadOneofValue = true
          if case .roleCreated(let m) = current {v = m}
        }
        try decoder.decodeSingularMessageField(value: &v)
        if let v = v {
          if hadOneofValue {try decoder.handleConflictingOneOf()}
          self.event = .roleCreated(v)
        }
      }()
      case 16: try {
        var v: Protocol_Chat_V1_StreamEvent.RoleDeleted?
        var hadOneofValue = false
        if let current = self.event {
          hadOneofValue = true
          if case .roleDeleted(let m) = current {v = m}
        }
        try decoder.decodeSingularMessageField(value: &v)
        if let v = v {
          if hadOneofValue {try decoder.handleConflictingOneOf()}
          self.event = .roleDeleted(v)
        }
      }()
      case 17: try {
        var v: Protocol_Chat_V1_StreamEvent.RoleMoved?
        var hadOneofValue = false
        if let current = self.event {
          hadOneofValue = true
          if case .roleMoved(let m) = current {v = m}
        }
        try decoder.decodeSingularMessageField(value: &v)
        if let v = v {
          if hadOneofValue {try decoder.handleConflictingOneOf()}
          self.event = .roleMoved(v)
        }
      }()
      case 18: try {
        var v: Protocol_Chat_V1_StreamEvent.RoleUpdated?
        var hadOneofValue = false
        if let current = self.event {
          hadOneofValue = true
          if case .roleUpdated(let m) = current {v = m}
        }
        try decoder.decodeSingularMessageField(value: &v)
        if let v = v {
          if hadOneofValue {try decoder.handleConflictingOneOf()}
          self.event = .roleUpdated(v)
        }
      }()
      case 19: try {
        var v: Protocol_Chat_V1_StreamEvent.RolePermissionsUpdated?
        var hadOneofValue = false
        if let current = self.event {
          hadOneofValue = true
          if case .rolePermsUpdated(let m) = current {v = m}
        }
        try decoder.decodeSingularMessageField(value: &v)
        if let v = v {
          if hadOneofValue {try decoder.handleConflictingOneOf()}
          self.event = .rolePermsUpdated(v)
        }
      }()
      case 20: try {
        var v: Protocol_Chat_V1_StreamEvent.UserRolesUpdated?
        var hadOneofValue = false
        if let current = self.event {
          hadOneofValue = true
          if case .userRolesUpdated(let m) = current {v = m}
        }
        try decoder.decodeSingularMessageField(value: &v)
        if let v = v {
          if hadOneofValue {try decoder.handleConflictingOneOf()}
          self.event = .userRolesUpdated(v)
        }
      }()
      case 21: try {
        var v: Protocol_Chat_V1_StreamEvent.PermissionUpdated?
        var hadOneofValue = false
        if let current = self.event {
          hadOneofValue = true
          if case .permissionUpdated(let m) = current {v = m}
        }
        try decoder.decodeSingularMessageField(value: &v)
        if let v = v {
          if hadOneofValue {try decoder.handleConflictingOneOf()}
          self.event = .permissionUpdated(v)
        }
      }()
      case 22: try {
        var v: Protocol_Chat_V1_StreamEvent.ChannelsReordered?
        var hadOneofValue = false
        if let current = self.event {
          hadOneofValue = true
          if case .channelsReordered(let m) = current {v = m}
        }
        try decoder.decodeSingularMessageField(value: &v)
        if let v = v {
          if hadOneofValue {try decoder.handleConflictingOneOf()}
          self.event = .channelsReordered(v)
        }
      }()
      case 23: try {
        var v: Protocol_Chat_V1_StreamEvent.ChannelPositionUpdated?
        var hadOneofValue = false
        if let current = self.event {
          hadOneofValue = true
          if case .editedChannelPosition(let m) = current {v = m}
        }
        try decoder.decodeSingularMessageField(value: &v)
        if let v = v {
          if hadOneofValue {try decoder.handleConflictingOneOf()}
          self.event = .editedChannelPosition(v)
        }
      }()
      case 24: try {
        var v: Protocol_Chat_V1_StreamEvent.MessagePinned?
        var hadOneofValue = false
        if let current = self.event {
          hadOneofValue = true
          if case .messagePinned(let m) = current {v = m}
        }
        try decoder.decodeSingularMessageField(value: &v)
        if let v = v {
          if hadOneofValue {try decoder.handleConflictingOneOf()}
          self.event = .messagePinned(v)
        }
      }()
      case 25: try {
        var v: Protocol_Chat_V1_StreamEvent.MessageUnpinned?
        var hadOneofValue = false
        if let current = self.event {
          hadOneofValue = true
          if case .messageUnpinned(let m) = current {v = m}
        }
        try decoder.decodeSingularMessageField(value: &v)
        if let v = v {
          if hadOneofValue {try decoder.handleConflictingOneOf()}
          self.event = .messageUnpinned(v)
        }
      }()
      case 26: try {
        var v: Protocol_Chat_V1_StreamEvent.ReactionUpdated?
        var hadOneofValue = false
        if let current = self.event {
          hadOneofValue = true
          if case .reactionUpdated(let m) = current {v = m}
        }
        try decoder.decodeSingularMessageField(value: &v)
        if let v = v {
          if hadOneofValue {try decoder.handleConflictingOneOf()}
          self.event = .reactionUpdated(v)
        }
      }()
      case 27: try {
        var v: Protocol_Chat_V1_StreamEvent.OwnerAdded?
        var hadOneofValue = false
        if let current = self.event {
          hadOneofValue = true
          if case .ownerAdded(let m) = current {v = m}
        }
        try decoder.decodeSingularMessageField(value: &v)
        if let v = v {
          if hadOneofValue {try decoder.handleConflictingOneOf()}
          self.event = .ownerAdded(v)
        }
      }()
      case 28: try {
        var v: Protocol_Chat_V1_StreamEvent.OwnerRemoved?
        var hadOneofValue = false
        if let current = self.event {
          hadOneofValue = true
          if case .ownerRemoved(let m) = current {v = m}
        }
        try decoder.decodeSingularMessageField(value: &v)
        if let v = v {
          if hadOneofValue {try decoder.handleConflictingOneOf()}
          self.event = .ownerRemoved(v)
        }
      }()
      case 29: try {
        var v: Protocol_Chat_V1_StreamEvent.InviteReceived?
        var hadOneofValue = false
        if let current = self.event {
          hadOneofValue = true
          if case .inviteReceived(let m) = current {v = m}
        }
        try decoder.decodeSingularMessageField(value: &v)
        if let v = v {
          if hadOneofValue {try decoder.handleConflictingOneOf()}
          self.event = .inviteReceived(v)
        }
      }()
      case 30: try {
        var v: Protocol_Chat_V1_StreamEvent.InviteRejected?
        var hadOneofValue = false
        if let current = self.event {
          hadOneofValue = true
          if case .inviteRejected(let m) = current {v = m}
        }
        try decoder.decodeSingularMessageField(value: &v)
        if let v = v {
          if hadOneofValue {try decoder.handleConflictingOneOf()}
          self.event = .inviteRejected(v)
        }
      }()
      default: break
      }
    }
  }

  func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    // The use of inline closures is to circumvent an issue where the compiler
    // allocates stack space for every case branch when no optimizations are
    // enabled. https://github.com/apple/swift-protobuf/issues/1034
    switch self.event {
    case .guildAddedToList?: try {
      guard case .guildAddedToList(let v)? = self.event else { preconditionFailure() }
      try visitor.visitSingularMessageField(value: v, fieldNumber: 1)
    }()
    case .guildRemovedFromList?: try {
      guard case .guildRemovedFromList(let v)? = self.event else { preconditionFailure() }
      try visitor.visitSingularMessageField(value: v, fieldNumber: 2)
    }()
    case .actionPerformed?: try {
      guard case .actionPerformed(let v)? = self.event else { preconditionFailure() }
      try visitor.visitSingularMessageField(value: v, fieldNumber: 3)
    }()
    case .sentMessage?: try {
      guard case .sentMessage(let v)? = self.event else { preconditionFailure() }
      try visitor.visitSingularMessageField(value: v, fieldNumber: 4)
    }()
    case .editedMessage?: try {
      guard case .editedMessage(let v)? = self.event else { preconditionFailure() }
      try visitor.visitSingularMessageField(value: v, fieldNumber: 5)
    }()
    case .deletedMessage?: try {
      guard case .deletedMessage(let v)? = self.event else { preconditionFailure() }
      try visitor.visitSingularMessageField(value: v, fieldNumber: 6)
    }()
    case .createdChannel?: try {
      guard case .createdChannel(let v)? = self.event else { preconditionFailure() }
      try visitor.visitSingularMessageField(value: v, fieldNumber: 7)
    }()
    case .editedChannel?: try {
      guard case .editedChannel(let v)? = self.event else { preconditionFailure() }
      try visitor.visitSingularMessageField(value: v, fieldNumber: 8)
    }()
    case .deletedChannel?: try {
      guard case .deletedChannel(let v)? = self.event else { preconditionFailure() }
      try visitor.visitSingularMessageField(value: v, fieldNumber: 9)
    }()
    case .editedGuild?: try {
      guard case .editedGuild(let v)? = self.event else { preconditionFailure() }
      try visitor.visitSingularMessageField(value: v, fieldNumber: 10)
    }()
    case .deletedGuild?: try {
      guard case .deletedGuild(let v)? = self.event else { preconditionFailure() }
      try visitor.visitSingularMessageField(value: v, fieldNumber: 11)
    }()
    case .joinedMember?: try {
      guard case .joinedMember(let v)? = self.event else { preconditionFailure() }
      try visitor.visitSingularMessageField(value: v, fieldNumber: 12)
    }()
    case .leftMember?: try {
      guard case .leftMember(let v)? = self.event else { preconditionFailure() }
      try visitor.visitSingularMessageField(value: v, fieldNumber: 13)
    }()
    case .typing?: try {
      guard case .typing(let v)? = self.event else { preconditionFailure() }
      try visitor.visitSingularMessageField(value: v, fieldNumber: 14)
    }()
    case .roleCreated?: try {
      guard case .roleCreated(let v)? = self.event else { preconditionFailure() }
      try visitor.visitSingularMessageField(value: v, fieldNumber: 15)
    }()
    case .roleDeleted?: try {
      guard case .roleDeleted(let v)? = self.event else { preconditionFailure() }
      try visitor.visitSingularMessageField(value: v, fieldNumber: 16)
    }()
    case .roleMoved?: try {
      guard case .roleMoved(let v)? = self.event else { preconditionFailure() }
      try visitor.visitSingularMessageField(value: v, fieldNumber: 17)
    }()
    case .roleUpdated?: try {
      guard case .roleUpdated(let v)? = self.event else { preconditionFailure() }
      try visitor.visitSingularMessageField(value: v, fieldNumber: 18)
    }()
    case .rolePermsUpdated?: try {
      guard case .rolePermsUpdated(let v)? = self.event else { preconditionFailure() }
      try visitor.visitSingularMessageField(value: v, fieldNumber: 19)
    }()
    case .userRolesUpdated?: try {
      guard case .userRolesUpdated(let v)? = self.event else { preconditionFailure() }
      try visitor.visitSingularMessageField(value: v, fieldNumber: 20)
    }()
    case .permissionUpdated?: try {
      guard case .permissionUpdated(let v)? = self.event else { preconditionFailure() }
      try visitor.visitSingularMessageField(value: v, fieldNumber: 21)
    }()
    case .channelsReordered?: try {
      guard case .channelsReordered(let v)? = self.event else { preconditionFailure() }
      try visitor.visitSingularMessageField(value: v, fieldNumber: 22)
    }()
    case .editedChannelPosition?: try {
      guard case .editedChannelPosition(let v)? = self.event else { preconditionFailure() }
      try visitor.visitSingularMessageField(value: v, fieldNumber: 23)
    }()
    case .messagePinned?: try {
      guard case .messagePinned(let v)? = self.event else { preconditionFailure() }
      try visitor.visitSingularMessageField(value: v, fieldNumber: 24)
    }()
    case .messageUnpinned?: try {
      guard case .messageUnpinned(let v)? = self.event else { preconditionFailure() }
      try visitor.visitSingularMessageField(value: v, fieldNumber: 25)
    }()
    case .reactionUpdated?: try {
      guard case .reactionUpdated(let v)? = self.event else { preconditionFailure() }
      try visitor.visitSingularMessageField(value: v, fieldNumber: 26)
    }()
    case .ownerAdded?: try {
      guard case .ownerAdded(let v)? = self.event else { preconditionFailure() }
      try visitor.visitSingularMessageField(value: v, fieldNumber: 27)
    }()
    case .ownerRemoved?: try {
      guard case .ownerRemoved(let v)? = self.event else { preconditionFailure() }
      try visitor.visitSingularMessageField(value: v, fieldNumber: 28)
    }()
    case .inviteReceived?: try {
      guard case .inviteReceived(let v)? = self.event else { preconditionFailure() }
      try visitor.visitSingularMessageField(value: v, fieldNumber: 29)
    }()
    case .inviteRejected?: try {
      guard case .inviteRejected(let v)? = self.event else { preconditionFailure() }
      try visitor.visitSingularMessageField(value: v, fieldNumber: 30)
    }()
    case nil: break
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  static func ==(lhs: Protocol_Chat_V1_StreamEvent, rhs: Protocol_Chat_V1_StreamEvent) -> Bool {
    if lhs.event != rhs.event {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Protocol_Chat_V1_StreamEvent.MessageSent: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static let protoMessageName: String = Protocol_Chat_V1_StreamEvent.protoMessageName + ".MessageSent"
  static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .standard(proto: "echo_id"),
    2: .standard(proto: "guild_id"),
    3: .standard(proto: "channel_id"),
    4: .standard(proto: "message_id"),
    5: .same(proto: "message"),
  ]

  mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularUInt64Field(value: &self._echoID) }()
      case 2: try { try decoder.decodeSingularUInt64Field(value: &self.guildID) }()
      case 3: try { try decoder.decodeSingularUInt64Field(value: &self.channelID) }()
      case 4: try { try decoder.decodeSingularUInt64Field(value: &self.messageID) }()
      case 5: try { try decoder.decodeSingularMessageField(value: &self._message) }()
      default: break
      }
    }
  }

  func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if let v = self._echoID {
      try visitor.visitSingularUInt64Field(value: v, fieldNumber: 1)
    }
    if self.guildID != 0 {
      try visitor.visitSingularUInt64Field(value: self.guildID, fieldNumber: 2)
    }
    if self.channelID != 0 {
      try visitor.visitSingularUInt64Field(value: self.channelID, fieldNumber: 3)
    }
    if self.messageID != 0 {
      try visitor.visitSingularUInt64Field(value: self.messageID, fieldNumber: 4)
    }
    if let v = self._message {
      try visitor.visitSingularMessageField(value: v, fieldNumber: 5)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  static func ==(lhs: Protocol_Chat_V1_StreamEvent.MessageSent, rhs: Protocol_Chat_V1_StreamEvent.MessageSent) -> Bool {
    if lhs._echoID != rhs._echoID {return false}
    if lhs.guildID != rhs.guildID {return false}
    if lhs.channelID != rhs.channelID {return false}
    if lhs.messageID != rhs.messageID {return false}
    if lhs._message != rhs._message {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Protocol_Chat_V1_StreamEvent.MessageUpdated: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static let protoMessageName: String = Protocol_Chat_V1_StreamEvent.protoMessageName + ".MessageUpdated"
  static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .standard(proto: "guild_id"),
    2: .standard(proto: "channel_id"),
    3: .standard(proto: "message_id"),
    4: .standard(proto: "edited_at"),
    5: .standard(proto: "new_content"),
  ]

  mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularUInt64Field(value: &self.guildID) }()
      case 2: try { try decoder.decodeSingularUInt64Field(value: &self.channelID) }()
      case 3: try { try decoder.decodeSingularUInt64Field(value: &self.messageID) }()
      case 4: try { try decoder.decodeSingularUInt64Field(value: &self.editedAt) }()
      case 5: try { try decoder.decodeSingularMessageField(value: &self._newContent) }()
      default: break
      }
    }
  }

  func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if self.guildID != 0 {
      try visitor.visitSingularUInt64Field(value: self.guildID, fieldNumber: 1)
    }
    if self.channelID != 0 {
      try visitor.visitSingularUInt64Field(value: self.channelID, fieldNumber: 2)
    }
    if self.messageID != 0 {
      try visitor.visitSingularUInt64Field(value: self.messageID, fieldNumber: 3)
    }
    if self.editedAt != 0 {
      try visitor.visitSingularUInt64Field(value: self.editedAt, fieldNumber: 4)
    }
    if let v = self._newContent {
      try visitor.visitSingularMessageField(value: v, fieldNumber: 5)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  static func ==(lhs: Protocol_Chat_V1_StreamEvent.MessageUpdated, rhs: Protocol_Chat_V1_StreamEvent.MessageUpdated) -> Bool {
    if lhs.guildID != rhs.guildID {return false}
    if lhs.channelID != rhs.channelID {return false}
    if lhs.messageID != rhs.messageID {return false}
    if lhs.editedAt != rhs.editedAt {return false}
    if lhs._newContent != rhs._newContent {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Protocol_Chat_V1_StreamEvent.MessageDeleted: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static let protoMessageName: String = Protocol_Chat_V1_StreamEvent.protoMessageName + ".MessageDeleted"
  static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .standard(proto: "guild_id"),
    2: .standard(proto: "channel_id"),
    3: .standard(proto: "message_id"),
  ]

  mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularUInt64Field(value: &self.guildID) }()
      case 2: try { try decoder.decodeSingularUInt64Field(value: &self.channelID) }()
      case 3: try { try decoder.decodeSingularUInt64Field(value: &self.messageID) }()
      default: break
      }
    }
  }

  func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if self.guildID != 0 {
      try visitor.visitSingularUInt64Field(value: self.guildID, fieldNumber: 1)
    }
    if self.channelID != 0 {
      try visitor.visitSingularUInt64Field(value: self.channelID, fieldNumber: 2)
    }
    if self.messageID != 0 {
      try visitor.visitSingularUInt64Field(value: self.messageID, fieldNumber: 3)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  static func ==(lhs: Protocol_Chat_V1_StreamEvent.MessageDeleted, rhs: Protocol_Chat_V1_StreamEvent.MessageDeleted) -> Bool {
    if lhs.guildID != rhs.guildID {return false}
    if lhs.channelID != rhs.channelID {return false}
    if lhs.messageID != rhs.messageID {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Protocol_Chat_V1_StreamEvent.ChannelCreated: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static let protoMessageName: String = Protocol_Chat_V1_StreamEvent.protoMessageName + ".ChannelCreated"
  static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .standard(proto: "guild_id"),
    2: .standard(proto: "channel_id"),
    3: .same(proto: "name"),
    4: .same(proto: "position"),
    5: .same(proto: "kind"),
    6: .same(proto: "metadata"),
  ]

  mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularUInt64Field(value: &self.guildID) }()
      case 2: try { try decoder.decodeSingularUInt64Field(value: &self.channelID) }()
      case 3: try { try decoder.decodeSingularStringField(value: &self.name) }()
      case 4: try { try decoder.decodeSingularMessageField(value: &self._position) }()
      case 5: try { try decoder.decodeSingularEnumField(value: &self.kind) }()
      case 6: try { try decoder.decodeSingularMessageField(value: &self._metadata) }()
      default: break
      }
    }
  }

  func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if self.guildID != 0 {
      try visitor.visitSingularUInt64Field(value: self.guildID, fieldNumber: 1)
    }
    if self.channelID != 0 {
      try visitor.visitSingularUInt64Field(value: self.channelID, fieldNumber: 2)
    }
    if !self.name.isEmpty {
      try visitor.visitSingularStringField(value: self.name, fieldNumber: 3)
    }
    if let v = self._position {
      try visitor.visitSingularMessageField(value: v, fieldNumber: 4)
    }
    if self.kind != .textUnspecified {
      try visitor.visitSingularEnumField(value: self.kind, fieldNumber: 5)
    }
    if let v = self._metadata {
      try visitor.visitSingularMessageField(value: v, fieldNumber: 6)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  static func ==(lhs: Protocol_Chat_V1_StreamEvent.ChannelCreated, rhs: Protocol_Chat_V1_StreamEvent.ChannelCreated) -> Bool {
    if lhs.guildID != rhs.guildID {return false}
    if lhs.channelID != rhs.channelID {return false}
    if lhs.name != rhs.name {return false}
    if lhs._position != rhs._position {return false}
    if lhs.kind != rhs.kind {return false}
    if lhs._metadata != rhs._metadata {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Protocol_Chat_V1_StreamEvent.ChannelUpdated: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static let protoMessageName: String = Protocol_Chat_V1_StreamEvent.protoMessageName + ".ChannelUpdated"
  static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .standard(proto: "guild_id"),
    2: .standard(proto: "channel_id"),
    3: .standard(proto: "new_name"),
    4: .standard(proto: "new_metadata"),
  ]

  mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularUInt64Field(value: &self.guildID) }()
      case 2: try { try decoder.decodeSingularUInt64Field(value: &self.channelID) }()
      case 3: try { try decoder.decodeSingularStringField(value: &self._newName) }()
      case 4: try { try decoder.decodeSingularMessageField(value: &self._newMetadata) }()
      default: break
      }
    }
  }

  func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if self.guildID != 0 {
      try visitor.visitSingularUInt64Field(value: self.guildID, fieldNumber: 1)
    }
    if self.channelID != 0 {
      try visitor.visitSingularUInt64Field(value: self.channelID, fieldNumber: 2)
    }
    if let v = self._newName {
      try visitor.visitSingularStringField(value: v, fieldNumber: 3)
    }
    if let v = self._newMetadata {
      try visitor.visitSingularMessageField(value: v, fieldNumber: 4)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  static func ==(lhs: Protocol_Chat_V1_StreamEvent.ChannelUpdated, rhs: Protocol_Chat_V1_StreamEvent.ChannelUpdated) -> Bool {
    if lhs.guildID != rhs.guildID {return false}
    if lhs.channelID != rhs.channelID {return false}
    if lhs._newName != rhs._newName {return false}
    if lhs._newMetadata != rhs._newMetadata {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Protocol_Chat_V1_StreamEvent.ChannelPositionUpdated: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static let protoMessageName: String = Protocol_Chat_V1_StreamEvent.protoMessageName + ".ChannelPositionUpdated"
  static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .standard(proto: "guild_id"),
    2: .standard(proto: "channel_id"),
    3: .standard(proto: "new_position"),
  ]

  mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularUInt64Field(value: &self.guildID) }()
      case 2: try { try decoder.decodeSingularUInt64Field(value: &self.channelID) }()
      case 3: try { try decoder.decodeSingularMessageField(value: &self._newPosition) }()
      default: break
      }
    }
  }

  func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if self.guildID != 0 {
      try visitor.visitSingularUInt64Field(value: self.guildID, fieldNumber: 1)
    }
    if self.channelID != 0 {
      try visitor.visitSingularUInt64Field(value: self.channelID, fieldNumber: 2)
    }
    if let v = self._newPosition {
      try visitor.visitSingularMessageField(value: v, fieldNumber: 3)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  static func ==(lhs: Protocol_Chat_V1_StreamEvent.ChannelPositionUpdated, rhs: Protocol_Chat_V1_StreamEvent.ChannelPositionUpdated) -> Bool {
    if lhs.guildID != rhs.guildID {return false}
    if lhs.channelID != rhs.channelID {return false}
    if lhs._newPosition != rhs._newPosition {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Protocol_Chat_V1_StreamEvent.ChannelsReordered: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static let protoMessageName: String = Protocol_Chat_V1_StreamEvent.protoMessageName + ".ChannelsReordered"
  static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    2: .standard(proto: "guild_id"),
    1: .standard(proto: "channel_ids"),
  ]

  mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeRepeatedUInt64Field(value: &self.channelIds) }()
      case 2: try { try decoder.decodeSingularUInt64Field(value: &self.guildID) }()
      default: break
      }
    }
  }

  func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if !self.channelIds.isEmpty {
      try visitor.visitPackedUInt64Field(value: self.channelIds, fieldNumber: 1)
    }
    if self.guildID != 0 {
      try visitor.visitSingularUInt64Field(value: self.guildID, fieldNumber: 2)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  static func ==(lhs: Protocol_Chat_V1_StreamEvent.ChannelsReordered, rhs: Protocol_Chat_V1_StreamEvent.ChannelsReordered) -> Bool {
    if lhs.guildID != rhs.guildID {return false}
    if lhs.channelIds != rhs.channelIds {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Protocol_Chat_V1_StreamEvent.ChannelDeleted: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static let protoMessageName: String = Protocol_Chat_V1_StreamEvent.protoMessageName + ".ChannelDeleted"
  static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .standard(proto: "guild_id"),
    2: .standard(proto: "channel_id"),
  ]

  mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularUInt64Field(value: &self.guildID) }()
      case 2: try { try decoder.decodeSingularUInt64Field(value: &self.channelID) }()
      default: break
      }
    }
  }

  func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if self.guildID != 0 {
      try visitor.visitSingularUInt64Field(value: self.guildID, fieldNumber: 1)
    }
    if self.channelID != 0 {
      try visitor.visitSingularUInt64Field(value: self.channelID, fieldNumber: 2)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  static func ==(lhs: Protocol_Chat_V1_StreamEvent.ChannelDeleted, rhs: Protocol_Chat_V1_StreamEvent.ChannelDeleted) -> Bool {
    if lhs.guildID != rhs.guildID {return false}
    if lhs.channelID != rhs.channelID {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Protocol_Chat_V1_StreamEvent.GuildUpdated: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static let protoMessageName: String = Protocol_Chat_V1_StreamEvent.protoMessageName + ".GuildUpdated"
  static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .standard(proto: "guild_id"),
    2: .standard(proto: "new_name"),
    3: .standard(proto: "new_picture"),
    4: .standard(proto: "new_metadata"),
  ]

  mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularUInt64Field(value: &self.guildID) }()
      case 2: try { try decoder.decodeSingularStringField(value: &self._newName) }()
      case 3: try { try decoder.decodeSingularStringField(value: &self._newPicture) }()
      case 4: try { try decoder.decodeSingularMessageField(value: &self._newMetadata) }()
      default: break
      }
    }
  }

  func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if self.guildID != 0 {
      try visitor.visitSingularUInt64Field(value: self.guildID, fieldNumber: 1)
    }
    if let v = self._newName {
      try visitor.visitSingularStringField(value: v, fieldNumber: 2)
    }
    if let v = self._newPicture {
      try visitor.visitSingularStringField(value: v, fieldNumber: 3)
    }
    if let v = self._newMetadata {
      try visitor.visitSingularMessageField(value: v, fieldNumber: 4)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  static func ==(lhs: Protocol_Chat_V1_StreamEvent.GuildUpdated, rhs: Protocol_Chat_V1_StreamEvent.GuildUpdated) -> Bool {
    if lhs.guildID != rhs.guildID {return false}
    if lhs._newName != rhs._newName {return false}
    if lhs._newPicture != rhs._newPicture {return false}
    if lhs._newMetadata != rhs._newMetadata {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Protocol_Chat_V1_StreamEvent.GuildDeleted: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static let protoMessageName: String = Protocol_Chat_V1_StreamEvent.protoMessageName + ".GuildDeleted"
  static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .standard(proto: "guild_id"),
  ]

  mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularUInt64Field(value: &self.guildID) }()
      default: break
      }
    }
  }

  func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if self.guildID != 0 {
      try visitor.visitSingularUInt64Field(value: self.guildID, fieldNumber: 1)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  static func ==(lhs: Protocol_Chat_V1_StreamEvent.GuildDeleted, rhs: Protocol_Chat_V1_StreamEvent.GuildDeleted) -> Bool {
    if lhs.guildID != rhs.guildID {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Protocol_Chat_V1_StreamEvent.MemberJoined: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static let protoMessageName: String = Protocol_Chat_V1_StreamEvent.protoMessageName + ".MemberJoined"
  static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .standard(proto: "member_id"),
    2: .standard(proto: "guild_id"),
  ]

  mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularUInt64Field(value: &self.memberID) }()
      case 2: try { try decoder.decodeSingularUInt64Field(value: &self.guildID) }()
      default: break
      }
    }
  }

  func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if self.memberID != 0 {
      try visitor.visitSingularUInt64Field(value: self.memberID, fieldNumber: 1)
    }
    if self.guildID != 0 {
      try visitor.visitSingularUInt64Field(value: self.guildID, fieldNumber: 2)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  static func ==(lhs: Protocol_Chat_V1_StreamEvent.MemberJoined, rhs: Protocol_Chat_V1_StreamEvent.MemberJoined) -> Bool {
    if lhs.memberID != rhs.memberID {return false}
    if lhs.guildID != rhs.guildID {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Protocol_Chat_V1_StreamEvent.MemberLeft: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static let protoMessageName: String = Protocol_Chat_V1_StreamEvent.protoMessageName + ".MemberLeft"
  static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .standard(proto: "member_id"),
    2: .standard(proto: "guild_id"),
    3: .standard(proto: "leave_reason"),
  ]

  mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularUInt64Field(value: &self.memberID) }()
      case 2: try { try decoder.decodeSingularUInt64Field(value: &self.guildID) }()
      case 3: try { try decoder.decodeSingularEnumField(value: &self.leaveReason) }()
      default: break
      }
    }
  }

  func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if self.memberID != 0 {
      try visitor.visitSingularUInt64Field(value: self.memberID, fieldNumber: 1)
    }
    if self.guildID != 0 {
      try visitor.visitSingularUInt64Field(value: self.guildID, fieldNumber: 2)
    }
    if self.leaveReason != .willinglyUnspecified {
      try visitor.visitSingularEnumField(value: self.leaveReason, fieldNumber: 3)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  static func ==(lhs: Protocol_Chat_V1_StreamEvent.MemberLeft, rhs: Protocol_Chat_V1_StreamEvent.MemberLeft) -> Bool {
    if lhs.memberID != rhs.memberID {return false}
    if lhs.guildID != rhs.guildID {return false}
    if lhs.leaveReason != rhs.leaveReason {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Protocol_Chat_V1_StreamEvent.GuildAddedToList: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static let protoMessageName: String = Protocol_Chat_V1_StreamEvent.protoMessageName + ".GuildAddedToList"
  static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .standard(proto: "guild_id"),
    2: .same(proto: "homeserver"),
  ]

  mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularUInt64Field(value: &self.guildID) }()
      case 2: try { try decoder.decodeSingularStringField(value: &self.homeserver) }()
      default: break
      }
    }
  }

  func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if self.guildID != 0 {
      try visitor.visitSingularUInt64Field(value: self.guildID, fieldNumber: 1)
    }
    if !self.homeserver.isEmpty {
      try visitor.visitSingularStringField(value: self.homeserver, fieldNumber: 2)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  static func ==(lhs: Protocol_Chat_V1_StreamEvent.GuildAddedToList, rhs: Protocol_Chat_V1_StreamEvent.GuildAddedToList) -> Bool {
    if lhs.guildID != rhs.guildID {return false}
    if lhs.homeserver != rhs.homeserver {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Protocol_Chat_V1_StreamEvent.GuildRemovedFromList: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static let protoMessageName: String = Protocol_Chat_V1_StreamEvent.protoMessageName + ".GuildRemovedFromList"
  static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .standard(proto: "guild_id"),
    2: .same(proto: "homeserver"),
  ]

  mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularUInt64Field(value: &self.guildID) }()
      case 2: try { try decoder.decodeSingularStringField(value: &self.homeserver) }()
      default: break
      }
    }
  }

  func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if self.guildID != 0 {
      try visitor.visitSingularUInt64Field(value: self.guildID, fieldNumber: 1)
    }
    if !self.homeserver.isEmpty {
      try visitor.visitSingularStringField(value: self.homeserver, fieldNumber: 2)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  static func ==(lhs: Protocol_Chat_V1_StreamEvent.GuildRemovedFromList, rhs: Protocol_Chat_V1_StreamEvent.GuildRemovedFromList) -> Bool {
    if lhs.guildID != rhs.guildID {return false}
    if lhs.homeserver != rhs.homeserver {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Protocol_Chat_V1_StreamEvent.ActionPerformed: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static let protoMessageName: String = Protocol_Chat_V1_StreamEvent.protoMessageName + ".ActionPerformed"
  static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .standard(proto: "guild_id"),
    2: .standard(proto: "channel_id"),
    3: .standard(proto: "message_id"),
    4: .standard(proto: "user_id"),
    5: .same(proto: "payload"),
  ]

  mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularUInt64Field(value: &self.guildID) }()
      case 2: try { try decoder.decodeSingularUInt64Field(value: &self.channelID) }()
      case 3: try { try decoder.decodeSingularUInt64Field(value: &self.messageID) }()
      case 4: try { try decoder.decodeSingularUInt64Field(value: &self.userID) }()
      case 5: try { try decoder.decodeSingularMessageField(value: &self._payload) }()
      default: break
      }
    }
  }

  func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if self.guildID != 0 {
      try visitor.visitSingularUInt64Field(value: self.guildID, fieldNumber: 1)
    }
    if self.channelID != 0 {
      try visitor.visitSingularUInt64Field(value: self.channelID, fieldNumber: 2)
    }
    if self.messageID != 0 {
      try visitor.visitSingularUInt64Field(value: self.messageID, fieldNumber: 3)
    }
    if self.userID != 0 {
      try visitor.visitSingularUInt64Field(value: self.userID, fieldNumber: 4)
    }
    if let v = self._payload {
      try visitor.visitSingularMessageField(value: v, fieldNumber: 5)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  static func ==(lhs: Protocol_Chat_V1_StreamEvent.ActionPerformed, rhs: Protocol_Chat_V1_StreamEvent.ActionPerformed) -> Bool {
    if lhs.guildID != rhs.guildID {return false}
    if lhs.channelID != rhs.channelID {return false}
    if lhs.messageID != rhs.messageID {return false}
    if lhs.userID != rhs.userID {return false}
    if lhs._payload != rhs._payload {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Protocol_Chat_V1_StreamEvent.RoleMoved: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static let protoMessageName: String = Protocol_Chat_V1_StreamEvent.protoMessageName + ".RoleMoved"
  static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .standard(proto: "guild_id"),
    2: .standard(proto: "role_id"),
    3: .standard(proto: "new_position"),
  ]

  mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularUInt64Field(value: &self.guildID) }()
      case 2: try { try decoder.decodeSingularUInt64Field(value: &self.roleID) }()
      case 3: try { try decoder.decodeSingularMessageField(value: &self._newPosition) }()
      default: break
      }
    }
  }

  func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if self.guildID != 0 {
      try visitor.visitSingularUInt64Field(value: self.guildID, fieldNumber: 1)
    }
    if self.roleID != 0 {
      try visitor.visitSingularUInt64Field(value: self.roleID, fieldNumber: 2)
    }
    if let v = self._newPosition {
      try visitor.visitSingularMessageField(value: v, fieldNumber: 3)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  static func ==(lhs: Protocol_Chat_V1_StreamEvent.RoleMoved, rhs: Protocol_Chat_V1_StreamEvent.RoleMoved) -> Bool {
    if lhs.guildID != rhs.guildID {return false}
    if lhs.roleID != rhs.roleID {return false}
    if lhs._newPosition != rhs._newPosition {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Protocol_Chat_V1_StreamEvent.RoleDeleted: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static let protoMessageName: String = Protocol_Chat_V1_StreamEvent.protoMessageName + ".RoleDeleted"
  static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .standard(proto: "guild_id"),
    2: .standard(proto: "role_id"),
  ]

  mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularUInt64Field(value: &self.guildID) }()
      case 2: try { try decoder.decodeSingularUInt64Field(value: &self.roleID) }()
      default: break
      }
    }
  }

  func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if self.guildID != 0 {
      try visitor.visitSingularUInt64Field(value: self.guildID, fieldNumber: 1)
    }
    if self.roleID != 0 {
      try visitor.visitSingularUInt64Field(value: self.roleID, fieldNumber: 2)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  static func ==(lhs: Protocol_Chat_V1_StreamEvent.RoleDeleted, rhs: Protocol_Chat_V1_StreamEvent.RoleDeleted) -> Bool {
    if lhs.guildID != rhs.guildID {return false}
    if lhs.roleID != rhs.roleID {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Protocol_Chat_V1_StreamEvent.RoleCreated: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static let protoMessageName: String = Protocol_Chat_V1_StreamEvent.protoMessageName + ".RoleCreated"
  static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .standard(proto: "guild_id"),
    2: .standard(proto: "role_id"),
    3: .same(proto: "name"),
    4: .same(proto: "color"),
    5: .same(proto: "hoist"),
    6: .same(proto: "pingable"),
  ]

  mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularUInt64Field(value: &self.guildID) }()
      case 2: try { try decoder.decodeSingularUInt64Field(value: &self.roleID) }()
      case 3: try { try decoder.decodeSingularStringField(value: &self.name) }()
      case 4: try { try decoder.decodeSingularInt32Field(value: &self.color) }()
      case 5: try { try decoder.decodeSingularBoolField(value: &self.hoist) }()
      case 6: try { try decoder.decodeSingularBoolField(value: &self.pingable) }()
      default: break
      }
    }
  }

  func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if self.guildID != 0 {
      try visitor.visitSingularUInt64Field(value: self.guildID, fieldNumber: 1)
    }
    if self.roleID != 0 {
      try visitor.visitSingularUInt64Field(value: self.roleID, fieldNumber: 2)
    }
    if !self.name.isEmpty {
      try visitor.visitSingularStringField(value: self.name, fieldNumber: 3)
    }
    if self.color != 0 {
      try visitor.visitSingularInt32Field(value: self.color, fieldNumber: 4)
    }
    if self.hoist != false {
      try visitor.visitSingularBoolField(value: self.hoist, fieldNumber: 5)
    }
    if self.pingable != false {
      try visitor.visitSingularBoolField(value: self.pingable, fieldNumber: 6)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  static func ==(lhs: Protocol_Chat_V1_StreamEvent.RoleCreated, rhs: Protocol_Chat_V1_StreamEvent.RoleCreated) -> Bool {
    if lhs.guildID != rhs.guildID {return false}
    if lhs.roleID != rhs.roleID {return false}
    if lhs.name != rhs.name {return false}
    if lhs.color != rhs.color {return false}
    if lhs.hoist != rhs.hoist {return false}
    if lhs.pingable != rhs.pingable {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Protocol_Chat_V1_StreamEvent.RoleUpdated: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static let protoMessageName: String = Protocol_Chat_V1_StreamEvent.protoMessageName + ".RoleUpdated"
  static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .standard(proto: "guild_id"),
    2: .standard(proto: "role_id"),
    3: .standard(proto: "new_name"),
    4: .standard(proto: "new_color"),
    5: .standard(proto: "new_hoist"),
    6: .standard(proto: "new_pingable"),
  ]

  mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularUInt64Field(value: &self.guildID) }()
      case 2: try { try decoder.decodeSingularUInt64Field(value: &self.roleID) }()
      case 3: try { try decoder.decodeSingularStringField(value: &self._newName) }()
      case 4: try { try decoder.decodeSingularInt32Field(value: &self._newColor) }()
      case 5: try { try decoder.decodeSingularBoolField(value: &self._newHoist) }()
      case 6: try { try decoder.decodeSingularBoolField(value: &self._newPingable) }()
      default: break
      }
    }
  }

  func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if self.guildID != 0 {
      try visitor.visitSingularUInt64Field(value: self.guildID, fieldNumber: 1)
    }
    if self.roleID != 0 {
      try visitor.visitSingularUInt64Field(value: self.roleID, fieldNumber: 2)
    }
    if let v = self._newName {
      try visitor.visitSingularStringField(value: v, fieldNumber: 3)
    }
    if let v = self._newColor {
      try visitor.visitSingularInt32Field(value: v, fieldNumber: 4)
    }
    if let v = self._newHoist {
      try visitor.visitSingularBoolField(value: v, fieldNumber: 5)
    }
    if let v = self._newPingable {
      try visitor.visitSingularBoolField(value: v, fieldNumber: 6)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  static func ==(lhs: Protocol_Chat_V1_StreamEvent.RoleUpdated, rhs: Protocol_Chat_V1_StreamEvent.RoleUpdated) -> Bool {
    if lhs.guildID != rhs.guildID {return false}
    if lhs.roleID != rhs.roleID {return false}
    if lhs._newName != rhs._newName {return false}
    if lhs._newColor != rhs._newColor {return false}
    if lhs._newHoist != rhs._newHoist {return false}
    if lhs._newPingable != rhs._newPingable {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Protocol_Chat_V1_StreamEvent.RolePermissionsUpdated: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static let protoMessageName: String = Protocol_Chat_V1_StreamEvent.protoMessageName + ".RolePermissionsUpdated"
  static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .standard(proto: "guild_id"),
    2: .standard(proto: "channel_id"),
    3: .standard(proto: "role_id"),
    4: .standard(proto: "new_perms"),
  ]

  mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularUInt64Field(value: &self.guildID) }()
      case 2: try { try decoder.decodeSingularUInt64Field(value: &self._channelID) }()
      case 3: try { try decoder.decodeSingularUInt64Field(value: &self.roleID) }()
      case 4: try { try decoder.decodeRepeatedMessageField(value: &self.newPerms) }()
      default: break
      }
    }
  }

  func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if self.guildID != 0 {
      try visitor.visitSingularUInt64Field(value: self.guildID, fieldNumber: 1)
    }
    if let v = self._channelID {
      try visitor.visitSingularUInt64Field(value: v, fieldNumber: 2)
    }
    if self.roleID != 0 {
      try visitor.visitSingularUInt64Field(value: self.roleID, fieldNumber: 3)
    }
    if !self.newPerms.isEmpty {
      try visitor.visitRepeatedMessageField(value: self.newPerms, fieldNumber: 4)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  static func ==(lhs: Protocol_Chat_V1_StreamEvent.RolePermissionsUpdated, rhs: Protocol_Chat_V1_StreamEvent.RolePermissionsUpdated) -> Bool {
    if lhs.guildID != rhs.guildID {return false}
    if lhs._channelID != rhs._channelID {return false}
    if lhs.roleID != rhs.roleID {return false}
    if lhs.newPerms != rhs.newPerms {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Protocol_Chat_V1_StreamEvent.UserRolesUpdated: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static let protoMessageName: String = Protocol_Chat_V1_StreamEvent.protoMessageName + ".UserRolesUpdated"
  static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .standard(proto: "guild_id"),
    2: .standard(proto: "user_id"),
    3: .standard(proto: "new_role_ids"),
  ]

  mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularUInt64Field(value: &self.guildID) }()
      case 2: try { try decoder.decodeSingularUInt64Field(value: &self.userID) }()
      case 3: try { try decoder.decodeRepeatedUInt64Field(value: &self.newRoleIds) }()
      default: break
      }
    }
  }

  func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if self.guildID != 0 {
      try visitor.visitSingularUInt64Field(value: self.guildID, fieldNumber: 1)
    }
    if self.userID != 0 {
      try visitor.visitSingularUInt64Field(value: self.userID, fieldNumber: 2)
    }
    if !self.newRoleIds.isEmpty {
      try visitor.visitPackedUInt64Field(value: self.newRoleIds, fieldNumber: 3)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  static func ==(lhs: Protocol_Chat_V1_StreamEvent.UserRolesUpdated, rhs: Protocol_Chat_V1_StreamEvent.UserRolesUpdated) -> Bool {
    if lhs.guildID != rhs.guildID {return false}
    if lhs.userID != rhs.userID {return false}
    if lhs.newRoleIds != rhs.newRoleIds {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Protocol_Chat_V1_StreamEvent.Typing: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static let protoMessageName: String = Protocol_Chat_V1_StreamEvent.protoMessageName + ".Typing"
  static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .standard(proto: "user_id"),
    2: .standard(proto: "guild_id"),
    3: .standard(proto: "channel_id"),
  ]

  mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularUInt64Field(value: &self.userID) }()
      case 2: try { try decoder.decodeSingularUInt64Field(value: &self.guildID) }()
      case 3: try { try decoder.decodeSingularUInt64Field(value: &self.channelID) }()
      default: break
      }
    }
  }

  func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if self.userID != 0 {
      try visitor.visitSingularUInt64Field(value: self.userID, fieldNumber: 1)
    }
    if self.guildID != 0 {
      try visitor.visitSingularUInt64Field(value: self.guildID, fieldNumber: 2)
    }
    if self.channelID != 0 {
      try visitor.visitSingularUInt64Field(value: self.channelID, fieldNumber: 3)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  static func ==(lhs: Protocol_Chat_V1_StreamEvent.Typing, rhs: Protocol_Chat_V1_StreamEvent.Typing) -> Bool {
    if lhs.userID != rhs.userID {return false}
    if lhs.guildID != rhs.guildID {return false}
    if lhs.channelID != rhs.channelID {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Protocol_Chat_V1_StreamEvent.PermissionUpdated: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static let protoMessageName: String = Protocol_Chat_V1_StreamEvent.protoMessageName + ".PermissionUpdated"
  static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .standard(proto: "guild_id"),
    2: .standard(proto: "channel_id"),
    3: .same(proto: "query"),
    4: .same(proto: "ok"),
  ]

  mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularUInt64Field(value: &self.guildID) }()
      case 2: try { try decoder.decodeSingularUInt64Field(value: &self._channelID) }()
      case 3: try { try decoder.decodeSingularStringField(value: &self.query) }()
      case 4: try { try decoder.decodeSingularBoolField(value: &self.ok) }()
      default: break
      }
    }
  }

  func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if self.guildID != 0 {
      try visitor.visitSingularUInt64Field(value: self.guildID, fieldNumber: 1)
    }
    if let v = self._channelID {
      try visitor.visitSingularUInt64Field(value: v, fieldNumber: 2)
    }
    if !self.query.isEmpty {
      try visitor.visitSingularStringField(value: self.query, fieldNumber: 3)
    }
    if self.ok != false {
      try visitor.visitSingularBoolField(value: self.ok, fieldNumber: 4)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  static func ==(lhs: Protocol_Chat_V1_StreamEvent.PermissionUpdated, rhs: Protocol_Chat_V1_StreamEvent.PermissionUpdated) -> Bool {
    if lhs.guildID != rhs.guildID {return false}
    if lhs._channelID != rhs._channelID {return false}
    if lhs.query != rhs.query {return false}
    if lhs.ok != rhs.ok {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Protocol_Chat_V1_StreamEvent.MessagePinned: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static let protoMessageName: String = Protocol_Chat_V1_StreamEvent.protoMessageName + ".MessagePinned"
  static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .standard(proto: "guild_id"),
    2: .standard(proto: "channel_id"),
    3: .standard(proto: "message_id"),
  ]

  mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularUInt64Field(value: &self.guildID) }()
      case 2: try { try decoder.decodeSingularUInt64Field(value: &self.channelID) }()
      case 3: try { try decoder.decodeSingularUInt64Field(value: &self.messageID) }()
      default: break
      }
    }
  }

  func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if self.guildID != 0 {
      try visitor.visitSingularUInt64Field(value: self.guildID, fieldNumber: 1)
    }
    if self.channelID != 0 {
      try visitor.visitSingularUInt64Field(value: self.channelID, fieldNumber: 2)
    }
    if self.messageID != 0 {
      try visitor.visitSingularUInt64Field(value: self.messageID, fieldNumber: 3)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  static func ==(lhs: Protocol_Chat_V1_StreamEvent.MessagePinned, rhs: Protocol_Chat_V1_StreamEvent.MessagePinned) -> Bool {
    if lhs.guildID != rhs.guildID {return false}
    if lhs.channelID != rhs.channelID {return false}
    if lhs.messageID != rhs.messageID {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Protocol_Chat_V1_StreamEvent.MessageUnpinned: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static let protoMessageName: String = Protocol_Chat_V1_StreamEvent.protoMessageName + ".MessageUnpinned"
  static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .standard(proto: "guild_id"),
    2: .standard(proto: "channel_id"),
    3: .standard(proto: "message_id"),
  ]

  mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularUInt64Field(value: &self.guildID) }()
      case 2: try { try decoder.decodeSingularUInt64Field(value: &self.channelID) }()
      case 3: try { try decoder.decodeSingularUInt64Field(value: &self.messageID) }()
      default: break
      }
    }
  }

  func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if self.guildID != 0 {
      try visitor.visitSingularUInt64Field(value: self.guildID, fieldNumber: 1)
    }
    if self.channelID != 0 {
      try visitor.visitSingularUInt64Field(value: self.channelID, fieldNumber: 2)
    }
    if self.messageID != 0 {
      try visitor.visitSingularUInt64Field(value: self.messageID, fieldNumber: 3)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  static func ==(lhs: Protocol_Chat_V1_StreamEvent.MessageUnpinned, rhs: Protocol_Chat_V1_StreamEvent.MessageUnpinned) -> Bool {
    if lhs.guildID != rhs.guildID {return false}
    if lhs.channelID != rhs.channelID {return false}
    if lhs.messageID != rhs.messageID {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Protocol_Chat_V1_StreamEvent.ReactionUpdated: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static let protoMessageName: String = Protocol_Chat_V1_StreamEvent.protoMessageName + ".ReactionUpdated"
  static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .standard(proto: "guild_id"),
    2: .standard(proto: "channel_id"),
    3: .standard(proto: "message_id"),
    4: .same(proto: "reaction"),
  ]

  mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularUInt64Field(value: &self.guildID) }()
      case 2: try { try decoder.decodeSingularUInt64Field(value: &self.channelID) }()
      case 3: try { try decoder.decodeSingularUInt64Field(value: &self.messageID) }()
      case 4: try { try decoder.decodeSingularMessageField(value: &self._reaction) }()
      default: break
      }
    }
  }

  func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if self.guildID != 0 {
      try visitor.visitSingularUInt64Field(value: self.guildID, fieldNumber: 1)
    }
    if self.channelID != 0 {
      try visitor.visitSingularUInt64Field(value: self.channelID, fieldNumber: 2)
    }
    if self.messageID != 0 {
      try visitor.visitSingularUInt64Field(value: self.messageID, fieldNumber: 3)
    }
    if let v = self._reaction {
      try visitor.visitSingularMessageField(value: v, fieldNumber: 4)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  static func ==(lhs: Protocol_Chat_V1_StreamEvent.ReactionUpdated, rhs: Protocol_Chat_V1_StreamEvent.ReactionUpdated) -> Bool {
    if lhs.guildID != rhs.guildID {return false}
    if lhs.channelID != rhs.channelID {return false}
    if lhs.messageID != rhs.messageID {return false}
    if lhs._reaction != rhs._reaction {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Protocol_Chat_V1_StreamEvent.OwnerAdded: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static let protoMessageName: String = Protocol_Chat_V1_StreamEvent.protoMessageName + ".OwnerAdded"
  static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .standard(proto: "user_id"),
  ]

  mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularUInt64Field(value: &self.userID) }()
      default: break
      }
    }
  }

  func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if self.userID != 0 {
      try visitor.visitSingularUInt64Field(value: self.userID, fieldNumber: 1)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  static func ==(lhs: Protocol_Chat_V1_StreamEvent.OwnerAdded, rhs: Protocol_Chat_V1_StreamEvent.OwnerAdded) -> Bool {
    if lhs.userID != rhs.userID {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Protocol_Chat_V1_StreamEvent.OwnerRemoved: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static let protoMessageName: String = Protocol_Chat_V1_StreamEvent.protoMessageName + ".OwnerRemoved"
  static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .standard(proto: "user_id"),
  ]

  mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularUInt64Field(value: &self.userID) }()
      default: break
      }
    }
  }

  func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if self.userID != 0 {
      try visitor.visitSingularUInt64Field(value: self.userID, fieldNumber: 1)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  static func ==(lhs: Protocol_Chat_V1_StreamEvent.OwnerRemoved, rhs: Protocol_Chat_V1_StreamEvent.OwnerRemoved) -> Bool {
    if lhs.userID != rhs.userID {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Protocol_Chat_V1_StreamEvent.InviteReceived: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static let protoMessageName: String = Protocol_Chat_V1_StreamEvent.protoMessageName + ".InviteReceived"
  static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .standard(proto: "invite_id"),
    2: .standard(proto: "server_id"),
    3: .standard(proto: "inviter_id"),
  ]

  mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularStringField(value: &self.inviteID) }()
      case 2: try { try decoder.decodeSingularStringField(value: &self._serverID) }()
      case 3: try { try decoder.decodeSingularUInt64Field(value: &self.inviterID) }()
      default: break
      }
    }
  }

  func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if !self.inviteID.isEmpty {
      try visitor.visitSingularStringField(value: self.inviteID, fieldNumber: 1)
    }
    if let v = self._serverID {
      try visitor.visitSingularStringField(value: v, fieldNumber: 2)
    }
    if self.inviterID != 0 {
      try visitor.visitSingularUInt64Field(value: self.inviterID, fieldNumber: 3)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  static func ==(lhs: Protocol_Chat_V1_StreamEvent.InviteReceived, rhs: Protocol_Chat_V1_StreamEvent.InviteReceived) -> Bool {
    if lhs.inviteID != rhs.inviteID {return false}
    if lhs._serverID != rhs._serverID {return false}
    if lhs.inviterID != rhs.inviterID {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Protocol_Chat_V1_StreamEvent.InviteRejected: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static let protoMessageName: String = Protocol_Chat_V1_StreamEvent.protoMessageName + ".InviteRejected"
  static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .standard(proto: "guild_id"),
    2: .standard(proto: "invite_id"),
    3: .standard(proto: "user_id"),
  ]

  mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularUInt64Field(value: &self.guildID) }()
      case 2: try { try decoder.decodeSingularStringField(value: &self.inviteID) }()
      case 3: try { try decoder.decodeSingularUInt64Field(value: &self.userID) }()
      default: break
      }
    }
  }

  func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if self.guildID != 0 {
      try visitor.visitSingularUInt64Field(value: self.guildID, fieldNumber: 1)
    }
    if !self.inviteID.isEmpty {
      try visitor.visitSingularStringField(value: self.inviteID, fieldNumber: 2)
    }
    if self.userID != 0 {
      try visitor.visitSingularUInt64Field(value: self.userID, fieldNumber: 3)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  static func ==(lhs: Protocol_Chat_V1_StreamEvent.InviteRejected, rhs: Protocol_Chat_V1_StreamEvent.InviteRejected) -> Bool {
    if lhs.guildID != rhs.guildID {return false}
    if lhs.inviteID != rhs.inviteID {return false}
    if lhs.userID != rhs.userID {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}
