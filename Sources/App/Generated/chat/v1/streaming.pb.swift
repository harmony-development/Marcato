// DO NOT EDIT.
// swift-format-ignore-file
//
// Generated by the Swift generator plugin for the protocol buffer compiler.
// Source: chat/v1/streaming.proto
//
// For information on using the generated types, please see the documentation:
//   https://github.com/apple/swift-protobuf/

import Foundation
import SwiftProtobuf

// If the compiler emits an error on this type, it is because this file
// was generated by a version of the `protoc` Swift plug-in that is
// incompatible with the version of SwiftProtobuf to which you are linking.
// Please ensure that you are building against the same version of the API
// that was used to generate this file.
fileprivate struct _GeneratedWithProtocGenSwiftVersion: SwiftProtobuf.ProtobufAPIVersionCheck {
  struct _2: SwiftProtobuf.ProtobufAPIVersion_2 {}
  typealias Version = _2
}

struct Protocol_Chat_V1_StreamEventsRequest {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  var request: Protocol_Chat_V1_StreamEventsRequest.OneOf_Request? = nil

  var subscribeToGuild: Protocol_Chat_V1_StreamEventsRequest.SubscribeToGuild {
    get {
      if case .subscribeToGuild(let v)? = request {return v}
      return Protocol_Chat_V1_StreamEventsRequest.SubscribeToGuild()
    }
    set {request = .subscribeToGuild(newValue)}
  }

  var subscribeToActions: Protocol_Chat_V1_StreamEventsRequest.SubscribeToActions {
    get {
      if case .subscribeToActions(let v)? = request {return v}
      return Protocol_Chat_V1_StreamEventsRequest.SubscribeToActions()
    }
    set {request = .subscribeToActions(newValue)}
  }

  var subscribeToHomeserverEvents: Protocol_Chat_V1_StreamEventsRequest.SubscribeToHomeserverEvents {
    get {
      if case .subscribeToHomeserverEvents(let v)? = request {return v}
      return Protocol_Chat_V1_StreamEventsRequest.SubscribeToHomeserverEvents()
    }
    set {request = .subscribeToHomeserverEvents(newValue)}
  }

  var unknownFields = SwiftProtobuf.UnknownStorage()

  enum OneOf_Request: Equatable {
    case subscribeToGuild(Protocol_Chat_V1_StreamEventsRequest.SubscribeToGuild)
    case subscribeToActions(Protocol_Chat_V1_StreamEventsRequest.SubscribeToActions)
    case subscribeToHomeserverEvents(Protocol_Chat_V1_StreamEventsRequest.SubscribeToHomeserverEvents)

  #if !swift(>=4.1)
    static func ==(lhs: Protocol_Chat_V1_StreamEventsRequest.OneOf_Request, rhs: Protocol_Chat_V1_StreamEventsRequest.OneOf_Request) -> Bool {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch (lhs, rhs) {
      case (.subscribeToGuild, .subscribeToGuild): return {
        guard case .subscribeToGuild(let l) = lhs, case .subscribeToGuild(let r) = rhs else { preconditionFailure() }
        return l == r
      }()
      case (.subscribeToActions, .subscribeToActions): return {
        guard case .subscribeToActions(let l) = lhs, case .subscribeToActions(let r) = rhs else { preconditionFailure() }
        return l == r
      }()
      case (.subscribeToHomeserverEvents, .subscribeToHomeserverEvents): return {
        guard case .subscribeToHomeserverEvents(let l) = lhs, case .subscribeToHomeserverEvents(let r) = rhs else { preconditionFailure() }
        return l == r
      }()
      default: return false
      }
    }
  #endif
  }

  struct SubscribeToGuild {
    // SwiftProtobuf.Message conformance is added in an extension below. See the
    // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
    // methods supported on all messages.

    var guildID: UInt64 = 0

    var unknownFields = SwiftProtobuf.UnknownStorage()

    init() {}
  }

  struct SubscribeToActions {
    // SwiftProtobuf.Message conformance is added in an extension below. See the
    // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
    // methods supported on all messages.

    var unknownFields = SwiftProtobuf.UnknownStorage()

    init() {}
  }

  struct SubscribeToHomeserverEvents {
    // SwiftProtobuf.Message conformance is added in an extension below. See the
    // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
    // methods supported on all messages.

    var unknownFields = SwiftProtobuf.UnknownStorage()

    init() {}
  }

  init() {}
}

struct Protocol_Chat_V1_Event {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  var event: Protocol_Chat_V1_Event.OneOf_Event? = nil

  var guildAddedToList: Protocol_Chat_V1_Event.GuildAddedToList {
    get {
      if case .guildAddedToList(let v)? = event {return v}
      return Protocol_Chat_V1_Event.GuildAddedToList()
    }
    set {event = .guildAddedToList(newValue)}
  }

  var guildRemovedFromList: Protocol_Chat_V1_Event.GuildRemovedFromList {
    get {
      if case .guildRemovedFromList(let v)? = event {return v}
      return Protocol_Chat_V1_Event.GuildRemovedFromList()
    }
    set {event = .guildRemovedFromList(newValue)}
  }

  var actionPerformed: Protocol_Chat_V1_Event.ActionPerformed {
    get {
      if case .actionPerformed(let v)? = event {return v}
      return Protocol_Chat_V1_Event.ActionPerformed()
    }
    set {event = .actionPerformed(newValue)}
  }

  var sentMessage: Protocol_Chat_V1_Event.MessageSent {
    get {
      if case .sentMessage(let v)? = event {return v}
      return Protocol_Chat_V1_Event.MessageSent()
    }
    set {event = .sentMessage(newValue)}
  }

  var editedMessage: Protocol_Chat_V1_Event.MessageUpdated {
    get {
      if case .editedMessage(let v)? = event {return v}
      return Protocol_Chat_V1_Event.MessageUpdated()
    }
    set {event = .editedMessage(newValue)}
  }

  var deletedMessage: Protocol_Chat_V1_Event.MessageDeleted {
    get {
      if case .deletedMessage(let v)? = event {return v}
      return Protocol_Chat_V1_Event.MessageDeleted()
    }
    set {event = .deletedMessage(newValue)}
  }

  var createdChannel: Protocol_Chat_V1_Event.ChannelCreated {
    get {
      if case .createdChannel(let v)? = event {return v}
      return Protocol_Chat_V1_Event.ChannelCreated()
    }
    set {event = .createdChannel(newValue)}
  }

  var editedChannel: Protocol_Chat_V1_Event.ChannelUpdated {
    get {
      if case .editedChannel(let v)? = event {return v}
      return Protocol_Chat_V1_Event.ChannelUpdated()
    }
    set {event = .editedChannel(newValue)}
  }

  var deletedChannel: Protocol_Chat_V1_Event.ChannelDeleted {
    get {
      if case .deletedChannel(let v)? = event {return v}
      return Protocol_Chat_V1_Event.ChannelDeleted()
    }
    set {event = .deletedChannel(newValue)}
  }

  var editedGuild: Protocol_Chat_V1_Event.GuildUpdated {
    get {
      if case .editedGuild(let v)? = event {return v}
      return Protocol_Chat_V1_Event.GuildUpdated()
    }
    set {event = .editedGuild(newValue)}
  }

  var deletedGuild: Protocol_Chat_V1_Event.GuildDeleted {
    get {
      if case .deletedGuild(let v)? = event {return v}
      return Protocol_Chat_V1_Event.GuildDeleted()
    }
    set {event = .deletedGuild(newValue)}
  }

  var joinedMember: Protocol_Chat_V1_Event.MemberJoined {
    get {
      if case .joinedMember(let v)? = event {return v}
      return Protocol_Chat_V1_Event.MemberJoined()
    }
    set {event = .joinedMember(newValue)}
  }

  var leftMember: Protocol_Chat_V1_Event.MemberLeft {
    get {
      if case .leftMember(let v)? = event {return v}
      return Protocol_Chat_V1_Event.MemberLeft()
    }
    set {event = .leftMember(newValue)}
  }

  var roleMoved: Protocol_Chat_V1_Event.RoleMoved {
    get {
      if case .roleMoved(let v)? = event {return v}
      return Protocol_Chat_V1_Event.RoleMoved()
    }
    set {event = .roleMoved(newValue)}
  }

  var profileUpdated: Protocol_Chat_V1_Event.ProfileUpdated {
    get {
      if case .profileUpdated(let v)? = event {return v}
      return Protocol_Chat_V1_Event.ProfileUpdated()
    }
    set {event = .profileUpdated(newValue)}
  }

  var typing: Protocol_Chat_V1_Event.Typing {
    get {
      if case .typing(let v)? = event {return v}
      return Protocol_Chat_V1_Event.Typing()
    }
    set {event = .typing(newValue)}
  }

  var unknownFields = SwiftProtobuf.UnknownStorage()

  enum OneOf_Event: Equatable {
    case guildAddedToList(Protocol_Chat_V1_Event.GuildAddedToList)
    case guildRemovedFromList(Protocol_Chat_V1_Event.GuildRemovedFromList)
    case actionPerformed(Protocol_Chat_V1_Event.ActionPerformed)
    case sentMessage(Protocol_Chat_V1_Event.MessageSent)
    case editedMessage(Protocol_Chat_V1_Event.MessageUpdated)
    case deletedMessage(Protocol_Chat_V1_Event.MessageDeleted)
    case createdChannel(Protocol_Chat_V1_Event.ChannelCreated)
    case editedChannel(Protocol_Chat_V1_Event.ChannelUpdated)
    case deletedChannel(Protocol_Chat_V1_Event.ChannelDeleted)
    case editedGuild(Protocol_Chat_V1_Event.GuildUpdated)
    case deletedGuild(Protocol_Chat_V1_Event.GuildDeleted)
    case joinedMember(Protocol_Chat_V1_Event.MemberJoined)
    case leftMember(Protocol_Chat_V1_Event.MemberLeft)
    case roleMoved(Protocol_Chat_V1_Event.RoleMoved)
    case profileUpdated(Protocol_Chat_V1_Event.ProfileUpdated)
    case typing(Protocol_Chat_V1_Event.Typing)

  #if !swift(>=4.1)
    static func ==(lhs: Protocol_Chat_V1_Event.OneOf_Event, rhs: Protocol_Chat_V1_Event.OneOf_Event) -> Bool {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch (lhs, rhs) {
      case (.guildAddedToList, .guildAddedToList): return {
        guard case .guildAddedToList(let l) = lhs, case .guildAddedToList(let r) = rhs else { preconditionFailure() }
        return l == r
      }()
      case (.guildRemovedFromList, .guildRemovedFromList): return {
        guard case .guildRemovedFromList(let l) = lhs, case .guildRemovedFromList(let r) = rhs else { preconditionFailure() }
        return l == r
      }()
      case (.actionPerformed, .actionPerformed): return {
        guard case .actionPerformed(let l) = lhs, case .actionPerformed(let r) = rhs else { preconditionFailure() }
        return l == r
      }()
      case (.sentMessage, .sentMessage): return {
        guard case .sentMessage(let l) = lhs, case .sentMessage(let r) = rhs else { preconditionFailure() }
        return l == r
      }()
      case (.editedMessage, .editedMessage): return {
        guard case .editedMessage(let l) = lhs, case .editedMessage(let r) = rhs else { preconditionFailure() }
        return l == r
      }()
      case (.deletedMessage, .deletedMessage): return {
        guard case .deletedMessage(let l) = lhs, case .deletedMessage(let r) = rhs else { preconditionFailure() }
        return l == r
      }()
      case (.createdChannel, .createdChannel): return {
        guard case .createdChannel(let l) = lhs, case .createdChannel(let r) = rhs else { preconditionFailure() }
        return l == r
      }()
      case (.editedChannel, .editedChannel): return {
        guard case .editedChannel(let l) = lhs, case .editedChannel(let r) = rhs else { preconditionFailure() }
        return l == r
      }()
      case (.deletedChannel, .deletedChannel): return {
        guard case .deletedChannel(let l) = lhs, case .deletedChannel(let r) = rhs else { preconditionFailure() }
        return l == r
      }()
      case (.editedGuild, .editedGuild): return {
        guard case .editedGuild(let l) = lhs, case .editedGuild(let r) = rhs else { preconditionFailure() }
        return l == r
      }()
      case (.deletedGuild, .deletedGuild): return {
        guard case .deletedGuild(let l) = lhs, case .deletedGuild(let r) = rhs else { preconditionFailure() }
        return l == r
      }()
      case (.joinedMember, .joinedMember): return {
        guard case .joinedMember(let l) = lhs, case .joinedMember(let r) = rhs else { preconditionFailure() }
        return l == r
      }()
      case (.leftMember, .leftMember): return {
        guard case .leftMember(let l) = lhs, case .leftMember(let r) = rhs else { preconditionFailure() }
        return l == r
      }()
      case (.roleMoved, .roleMoved): return {
        guard case .roleMoved(let l) = lhs, case .roleMoved(let r) = rhs else { preconditionFailure() }
        return l == r
      }()
      case (.profileUpdated, .profileUpdated): return {
        guard case .profileUpdated(let l) = lhs, case .profileUpdated(let r) = rhs else { preconditionFailure() }
        return l == r
      }()
      case (.typing, .typing): return {
        guard case .typing(let l) = lhs, case .typing(let r) = rhs else { preconditionFailure() }
        return l == r
      }()
      default: return false
      }
    }
  #endif
  }

  enum LeaveReason: SwiftProtobuf.Enum {
    typealias RawValue = Int
    case willingly // = 0
    case banned // = 1
    case kicked // = 2
    case UNRECOGNIZED(Int)

    init() {
      self = .willingly
    }

    init?(rawValue: Int) {
      switch rawValue {
      case 0: self = .willingly
      case 1: self = .banned
      case 2: self = .kicked
      default: self = .UNRECOGNIZED(rawValue)
      }
    }

    var rawValue: Int {
      switch self {
      case .willingly: return 0
      case .banned: return 1
      case .kicked: return 2
      case .UNRECOGNIZED(let i): return i
      }
    }

  }

  struct MessageSent {
    // SwiftProtobuf.Message conformance is added in an extension below. See the
    // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
    // methods supported on all messages.

    var echoID: UInt64 = 0

    var message: Protocol_Harmonytypes_V1_Message {
      get {return _message ?? Protocol_Harmonytypes_V1_Message()}
      set {_message = newValue}
    }
    /// Returns true if `message` has been explicitly set.
    var hasMessage: Bool {return self._message != nil}
    /// Clears the value of `message`. Subsequent reads from it will return its default value.
    mutating func clearMessage() {self._message = nil}

    var unknownFields = SwiftProtobuf.UnknownStorage()

    init() {}

    fileprivate var _message: Protocol_Harmonytypes_V1_Message? = nil
  }

  struct MessageUpdated {
    // SwiftProtobuf.Message conformance is added in an extension below. See the
    // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
    // methods supported on all messages.

    var guildID: UInt64 = 0

    var channelID: UInt64 = 0

    var messageID: UInt64 = 0

    var editedAt: SwiftProtobuf.Google_Protobuf_Timestamp {
      get {return _editedAt ?? SwiftProtobuf.Google_Protobuf_Timestamp()}
      set {_editedAt = newValue}
    }
    /// Returns true if `editedAt` has been explicitly set.
    var hasEditedAt: Bool {return self._editedAt != nil}
    /// Clears the value of `editedAt`. Subsequent reads from it will return its default value.
    mutating func clearEditedAt() {self._editedAt = nil}

    var content: String = String()

    var unknownFields = SwiftProtobuf.UnknownStorage()

    init() {}

    fileprivate var _editedAt: SwiftProtobuf.Google_Protobuf_Timestamp? = nil
  }

  struct MessageDeleted {
    // SwiftProtobuf.Message conformance is added in an extension below. See the
    // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
    // methods supported on all messages.

    var guildID: UInt64 = 0

    var channelID: UInt64 = 0

    var messageID: UInt64 = 0

    var unknownFields = SwiftProtobuf.UnknownStorage()

    init() {}
  }

  struct ChannelCreated {
    // SwiftProtobuf.Message conformance is added in an extension below. See the
    // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
    // methods supported on all messages.

    var guildID: UInt64 = 0

    var channelID: UInt64 = 0

    var name: String = String()

    var previousID: UInt64 = 0

    var nextID: UInt64 = 0

    var isCategory: Bool = false

    var metadata: Protocol_Harmonytypes_V1_Metadata {
      get {return _metadata ?? Protocol_Harmonytypes_V1_Metadata()}
      set {_metadata = newValue}
    }
    /// Returns true if `metadata` has been explicitly set.
    var hasMetadata: Bool {return self._metadata != nil}
    /// Clears the value of `metadata`. Subsequent reads from it will return its default value.
    mutating func clearMetadata() {self._metadata = nil}

    var unknownFields = SwiftProtobuf.UnknownStorage()

    init() {}

    fileprivate var _metadata: Protocol_Harmonytypes_V1_Metadata? = nil
  }

  struct ChannelUpdated {
    // SwiftProtobuf.Message conformance is added in an extension below. See the
    // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
    // methods supported on all messages.

    var guildID: UInt64 = 0

    var channelID: UInt64 = 0

    var name: String = String()

    var updateName: Bool = false

    var previousID: UInt64 = 0

    var nextID: UInt64 = 0

    var updateOrder: Bool = false

    var metadata: Protocol_Harmonytypes_V1_Metadata {
      get {return _metadata ?? Protocol_Harmonytypes_V1_Metadata()}
      set {_metadata = newValue}
    }
    /// Returns true if `metadata` has been explicitly set.
    var hasMetadata: Bool {return self._metadata != nil}
    /// Clears the value of `metadata`. Subsequent reads from it will return its default value.
    mutating func clearMetadata() {self._metadata = nil}

    var updateMetadata: Bool = false

    var unknownFields = SwiftProtobuf.UnknownStorage()

    init() {}

    fileprivate var _metadata: Protocol_Harmonytypes_V1_Metadata? = nil
  }

  struct ChannelDeleted {
    // SwiftProtobuf.Message conformance is added in an extension below. See the
    // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
    // methods supported on all messages.

    var guildID: UInt64 = 0

    var channelID: UInt64 = 0

    var unknownFields = SwiftProtobuf.UnknownStorage()

    init() {}
  }

  struct GuildUpdated {
    // SwiftProtobuf.Message conformance is added in an extension below. See the
    // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
    // methods supported on all messages.

    var guildID: UInt64 = 0

    var name: String = String()

    var updateName: Bool = false

    var picture: String = String()

    var updatePicture: Bool = false

    var metadata: Protocol_Harmonytypes_V1_Metadata {
      get {return _metadata ?? Protocol_Harmonytypes_V1_Metadata()}
      set {_metadata = newValue}
    }
    /// Returns true if `metadata` has been explicitly set.
    var hasMetadata: Bool {return self._metadata != nil}
    /// Clears the value of `metadata`. Subsequent reads from it will return its default value.
    mutating func clearMetadata() {self._metadata = nil}

    var updateMetadata: Bool = false

    var unknownFields = SwiftProtobuf.UnknownStorage()

    init() {}

    fileprivate var _metadata: Protocol_Harmonytypes_V1_Metadata? = nil
  }

  struct GuildDeleted {
    // SwiftProtobuf.Message conformance is added in an extension below. See the
    // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
    // methods supported on all messages.

    var guildID: UInt64 = 0

    var unknownFields = SwiftProtobuf.UnknownStorage()

    init() {}
  }

  struct MemberJoined {
    // SwiftProtobuf.Message conformance is added in an extension below. See the
    // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
    // methods supported on all messages.

    var memberID: UInt64 = 0

    var guildID: UInt64 = 0

    var unknownFields = SwiftProtobuf.UnknownStorage()

    init() {}
  }

  struct MemberLeft {
    // SwiftProtobuf.Message conformance is added in an extension below. See the
    // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
    // methods supported on all messages.

    var memberID: UInt64 = 0

    var guildID: UInt64 = 0

    var leaveReason: Protocol_Chat_V1_Event.LeaveReason = .willingly

    var unknownFields = SwiftProtobuf.UnknownStorage()

    init() {}
  }

  struct GuildAddedToList {
    // SwiftProtobuf.Message conformance is added in an extension below. See the
    // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
    // methods supported on all messages.

    var guildID: UInt64 = 0

    var homeserver: String = String()

    var unknownFields = SwiftProtobuf.UnknownStorage()

    init() {}
  }

  struct GuildRemovedFromList {
    // SwiftProtobuf.Message conformance is added in an extension below. See the
    // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
    // methods supported on all messages.

    var guildID: UInt64 = 0

    var homeserver: String = String()

    var unknownFields = SwiftProtobuf.UnknownStorage()

    init() {}
  }

  struct ActionPerformed {
    // SwiftProtobuf.Message conformance is added in an extension below. See the
    // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
    // methods supported on all messages.

    var guildID: UInt64 = 0

    var channelID: UInt64 = 0

    var messageID: UInt64 = 0

    var actionID: String = String()

    var actionData: String = String()

    var unknownFields = SwiftProtobuf.UnknownStorage()

    init() {}
  }

  struct RoleMoved {
    // SwiftProtobuf.Message conformance is added in an extension below. See the
    // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
    // methods supported on all messages.

    var guildID: UInt64 = 0

    var roleID: UInt64 = 0

    var unknownFields = SwiftProtobuf.UnknownStorage()

    init() {}
  }

  struct ProfileUpdated {
    // SwiftProtobuf.Message conformance is added in an extension below. See the
    // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
    // methods supported on all messages.

    var userID: UInt64 = 0

    var newUsername: String = String()

    var updateUsername: Bool = false

    var newAvatar: String = String()

    var updateAvatar: Bool = false

    var newStatus: Protocol_Harmonytypes_V1_UserStatus = .onlineUnspecified

    var updateStatus: Bool = false

    var isBot: Bool = false

    var updateIsBot: Bool = false

    var unknownFields = SwiftProtobuf.UnknownStorage()

    init() {}
  }

  struct Typing {
    // SwiftProtobuf.Message conformance is added in an extension below. See the
    // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
    // methods supported on all messages.

    var userID: UInt64 = 0

    var guildID: UInt64 = 0

    var channelID: UInt64 = 0

    var unknownFields = SwiftProtobuf.UnknownStorage()

    init() {}
  }

  init() {}
}

#if swift(>=4.2)

extension Protocol_Chat_V1_Event.LeaveReason: CaseIterable {
  // The compiler won't synthesize support with the UNRECOGNIZED case.
  static var allCases: [Protocol_Chat_V1_Event.LeaveReason] = [
    .willingly,
    .banned,
    .kicked,
  ]
}

#endif  // swift(>=4.2)

// MARK: - Code below here is support for the SwiftProtobuf runtime.

fileprivate let _protobuf_package = "protocol.chat.v1"

extension Protocol_Chat_V1_StreamEventsRequest: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static let protoMessageName: String = _protobuf_package + ".StreamEventsRequest"
  static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .standard(proto: "subscribe_to_guild"),
    2: .standard(proto: "subscribe_to_actions"),
    3: .standard(proto: "subscribe_to_homeserver_events"),
  ]

  mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try {
        var v: Protocol_Chat_V1_StreamEventsRequest.SubscribeToGuild?
        var hadOneofValue = false
        if let current = self.request {
          hadOneofValue = true
          if case .subscribeToGuild(let m) = current {v = m}
        }
        try decoder.decodeSingularMessageField(value: &v)
        if let v = v {
          if hadOneofValue {try decoder.handleConflictingOneOf()}
          self.request = .subscribeToGuild(v)
        }
      }()
      case 2: try {
        var v: Protocol_Chat_V1_StreamEventsRequest.SubscribeToActions?
        var hadOneofValue = false
        if let current = self.request {
          hadOneofValue = true
          if case .subscribeToActions(let m) = current {v = m}
        }
        try decoder.decodeSingularMessageField(value: &v)
        if let v = v {
          if hadOneofValue {try decoder.handleConflictingOneOf()}
          self.request = .subscribeToActions(v)
        }
      }()
      case 3: try {
        var v: Protocol_Chat_V1_StreamEventsRequest.SubscribeToHomeserverEvents?
        var hadOneofValue = false
        if let current = self.request {
          hadOneofValue = true
          if case .subscribeToHomeserverEvents(let m) = current {v = m}
        }
        try decoder.decodeSingularMessageField(value: &v)
        if let v = v {
          if hadOneofValue {try decoder.handleConflictingOneOf()}
          self.request = .subscribeToHomeserverEvents(v)
        }
      }()
      default: break
      }
    }
  }

  func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    // The use of inline closures is to circumvent an issue where the compiler
    // allocates stack space for every case branch when no optimizations are
    // enabled. https://github.com/apple/swift-protobuf/issues/1034
    switch self.request {
    case .subscribeToGuild?: try {
      guard case .subscribeToGuild(let v)? = self.request else { preconditionFailure() }
      try visitor.visitSingularMessageField(value: v, fieldNumber: 1)
    }()
    case .subscribeToActions?: try {
      guard case .subscribeToActions(let v)? = self.request else { preconditionFailure() }
      try visitor.visitSingularMessageField(value: v, fieldNumber: 2)
    }()
    case .subscribeToHomeserverEvents?: try {
      guard case .subscribeToHomeserverEvents(let v)? = self.request else { preconditionFailure() }
      try visitor.visitSingularMessageField(value: v, fieldNumber: 3)
    }()
    case nil: break
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  static func ==(lhs: Protocol_Chat_V1_StreamEventsRequest, rhs: Protocol_Chat_V1_StreamEventsRequest) -> Bool {
    if lhs.request != rhs.request {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Protocol_Chat_V1_StreamEventsRequest.SubscribeToGuild: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static let protoMessageName: String = Protocol_Chat_V1_StreamEventsRequest.protoMessageName + ".SubscribeToGuild"
  static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .standard(proto: "guild_id"),
  ]

  mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularUInt64Field(value: &self.guildID) }()
      default: break
      }
    }
  }

  func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if self.guildID != 0 {
      try visitor.visitSingularUInt64Field(value: self.guildID, fieldNumber: 1)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  static func ==(lhs: Protocol_Chat_V1_StreamEventsRequest.SubscribeToGuild, rhs: Protocol_Chat_V1_StreamEventsRequest.SubscribeToGuild) -> Bool {
    if lhs.guildID != rhs.guildID {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Protocol_Chat_V1_StreamEventsRequest.SubscribeToActions: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static let protoMessageName: String = Protocol_Chat_V1_StreamEventsRequest.protoMessageName + ".SubscribeToActions"
  static let _protobuf_nameMap = SwiftProtobuf._NameMap()

  mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let _ = try decoder.nextFieldNumber() {
    }
  }

  func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    try unknownFields.traverse(visitor: &visitor)
  }

  static func ==(lhs: Protocol_Chat_V1_StreamEventsRequest.SubscribeToActions, rhs: Protocol_Chat_V1_StreamEventsRequest.SubscribeToActions) -> Bool {
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Protocol_Chat_V1_StreamEventsRequest.SubscribeToHomeserverEvents: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static let protoMessageName: String = Protocol_Chat_V1_StreamEventsRequest.protoMessageName + ".SubscribeToHomeserverEvents"
  static let _protobuf_nameMap = SwiftProtobuf._NameMap()

  mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let _ = try decoder.nextFieldNumber() {
    }
  }

  func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    try unknownFields.traverse(visitor: &visitor)
  }

  static func ==(lhs: Protocol_Chat_V1_StreamEventsRequest.SubscribeToHomeserverEvents, rhs: Protocol_Chat_V1_StreamEventsRequest.SubscribeToHomeserverEvents) -> Bool {
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Protocol_Chat_V1_Event: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static let protoMessageName: String = _protobuf_package + ".Event"
  static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .standard(proto: "guild_added_to_list"),
    2: .standard(proto: "guild_removed_from_list"),
    3: .standard(proto: "action_performed"),
    4: .standard(proto: "sent_message"),
    5: .standard(proto: "edited_message"),
    6: .standard(proto: "deleted_message"),
    7: .standard(proto: "created_channel"),
    8: .standard(proto: "edited_channel"),
    9: .standard(proto: "deleted_channel"),
    10: .standard(proto: "edited_guild"),
    11: .standard(proto: "deleted_guild"),
    12: .standard(proto: "joined_member"),
    13: .standard(proto: "left_member"),
    14: .standard(proto: "role_moved"),
    15: .standard(proto: "profile_updated"),
    16: .same(proto: "typing"),
  ]

  mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try {
        var v: Protocol_Chat_V1_Event.GuildAddedToList?
        var hadOneofValue = false
        if let current = self.event {
          hadOneofValue = true
          if case .guildAddedToList(let m) = current {v = m}
        }
        try decoder.decodeSingularMessageField(value: &v)
        if let v = v {
          if hadOneofValue {try decoder.handleConflictingOneOf()}
          self.event = .guildAddedToList(v)
        }
      }()
      case 2: try {
        var v: Protocol_Chat_V1_Event.GuildRemovedFromList?
        var hadOneofValue = false
        if let current = self.event {
          hadOneofValue = true
          if case .guildRemovedFromList(let m) = current {v = m}
        }
        try decoder.decodeSingularMessageField(value: &v)
        if let v = v {
          if hadOneofValue {try decoder.handleConflictingOneOf()}
          self.event = .guildRemovedFromList(v)
        }
      }()
      case 3: try {
        var v: Protocol_Chat_V1_Event.ActionPerformed?
        var hadOneofValue = false
        if let current = self.event {
          hadOneofValue = true
          if case .actionPerformed(let m) = current {v = m}
        }
        try decoder.decodeSingularMessageField(value: &v)
        if let v = v {
          if hadOneofValue {try decoder.handleConflictingOneOf()}
          self.event = .actionPerformed(v)
        }
      }()
      case 4: try {
        var v: Protocol_Chat_V1_Event.MessageSent?
        var hadOneofValue = false
        if let current = self.event {
          hadOneofValue = true
          if case .sentMessage(let m) = current {v = m}
        }
        try decoder.decodeSingularMessageField(value: &v)
        if let v = v {
          if hadOneofValue {try decoder.handleConflictingOneOf()}
          self.event = .sentMessage(v)
        }
      }()
      case 5: try {
        var v: Protocol_Chat_V1_Event.MessageUpdated?
        var hadOneofValue = false
        if let current = self.event {
          hadOneofValue = true
          if case .editedMessage(let m) = current {v = m}
        }
        try decoder.decodeSingularMessageField(value: &v)
        if let v = v {
          if hadOneofValue {try decoder.handleConflictingOneOf()}
          self.event = .editedMessage(v)
        }
      }()
      case 6: try {
        var v: Protocol_Chat_V1_Event.MessageDeleted?
        var hadOneofValue = false
        if let current = self.event {
          hadOneofValue = true
          if case .deletedMessage(let m) = current {v = m}
        }
        try decoder.decodeSingularMessageField(value: &v)
        if let v = v {
          if hadOneofValue {try decoder.handleConflictingOneOf()}
          self.event = .deletedMessage(v)
        }
      }()
      case 7: try {
        var v: Protocol_Chat_V1_Event.ChannelCreated?
        var hadOneofValue = false
        if let current = self.event {
          hadOneofValue = true
          if case .createdChannel(let m) = current {v = m}
        }
        try decoder.decodeSingularMessageField(value: &v)
        if let v = v {
          if hadOneofValue {try decoder.handleConflictingOneOf()}
          self.event = .createdChannel(v)
        }
      }()
      case 8: try {
        var v: Protocol_Chat_V1_Event.ChannelUpdated?
        var hadOneofValue = false
        if let current = self.event {
          hadOneofValue = true
          if case .editedChannel(let m) = current {v = m}
        }
        try decoder.decodeSingularMessageField(value: &v)
        if let v = v {
          if hadOneofValue {try decoder.handleConflictingOneOf()}
          self.event = .editedChannel(v)
        }
      }()
      case 9: try {
        var v: Protocol_Chat_V1_Event.ChannelDeleted?
        var hadOneofValue = false
        if let current = self.event {
          hadOneofValue = true
          if case .deletedChannel(let m) = current {v = m}
        }
        try decoder.decodeSingularMessageField(value: &v)
        if let v = v {
          if hadOneofValue {try decoder.handleConflictingOneOf()}
          self.event = .deletedChannel(v)
        }
      }()
      case 10: try {
        var v: Protocol_Chat_V1_Event.GuildUpdated?
        var hadOneofValue = false
        if let current = self.event {
          hadOneofValue = true
          if case .editedGuild(let m) = current {v = m}
        }
        try decoder.decodeSingularMessageField(value: &v)
        if let v = v {
          if hadOneofValue {try decoder.handleConflictingOneOf()}
          self.event = .editedGuild(v)
        }
      }()
      case 11: try {
        var v: Protocol_Chat_V1_Event.GuildDeleted?
        var hadOneofValue = false
        if let current = self.event {
          hadOneofValue = true
          if case .deletedGuild(let m) = current {v = m}
        }
        try decoder.decodeSingularMessageField(value: &v)
        if let v = v {
          if hadOneofValue {try decoder.handleConflictingOneOf()}
          self.event = .deletedGuild(v)
        }
      }()
      case 12: try {
        var v: Protocol_Chat_V1_Event.MemberJoined?
        var hadOneofValue = false
        if let current = self.event {
          hadOneofValue = true
          if case .joinedMember(let m) = current {v = m}
        }
        try decoder.decodeSingularMessageField(value: &v)
        if let v = v {
          if hadOneofValue {try decoder.handleConflictingOneOf()}
          self.event = .joinedMember(v)
        }
      }()
      case 13: try {
        var v: Protocol_Chat_V1_Event.MemberLeft?
        var hadOneofValue = false
        if let current = self.event {
          hadOneofValue = true
          if case .leftMember(let m) = current {v = m}
        }
        try decoder.decodeSingularMessageField(value: &v)
        if let v = v {
          if hadOneofValue {try decoder.handleConflictingOneOf()}
          self.event = .leftMember(v)
        }
      }()
      case 14: try {
        var v: Protocol_Chat_V1_Event.RoleMoved?
        var hadOneofValue = false
        if let current = self.event {
          hadOneofValue = true
          if case .roleMoved(let m) = current {v = m}
        }
        try decoder.decodeSingularMessageField(value: &v)
        if let v = v {
          if hadOneofValue {try decoder.handleConflictingOneOf()}
          self.event = .roleMoved(v)
        }
      }()
      case 15: try {
        var v: Protocol_Chat_V1_Event.ProfileUpdated?
        var hadOneofValue = false
        if let current = self.event {
          hadOneofValue = true
          if case .profileUpdated(let m) = current {v = m}
        }
        try decoder.decodeSingularMessageField(value: &v)
        if let v = v {
          if hadOneofValue {try decoder.handleConflictingOneOf()}
          self.event = .profileUpdated(v)
        }
      }()
      case 16: try {
        var v: Protocol_Chat_V1_Event.Typing?
        var hadOneofValue = false
        if let current = self.event {
          hadOneofValue = true
          if case .typing(let m) = current {v = m}
        }
        try decoder.decodeSingularMessageField(value: &v)
        if let v = v {
          if hadOneofValue {try decoder.handleConflictingOneOf()}
          self.event = .typing(v)
        }
      }()
      default: break
      }
    }
  }

  func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    // The use of inline closures is to circumvent an issue where the compiler
    // allocates stack space for every case branch when no optimizations are
    // enabled. https://github.com/apple/swift-protobuf/issues/1034
    switch self.event {
    case .guildAddedToList?: try {
      guard case .guildAddedToList(let v)? = self.event else { preconditionFailure() }
      try visitor.visitSingularMessageField(value: v, fieldNumber: 1)
    }()
    case .guildRemovedFromList?: try {
      guard case .guildRemovedFromList(let v)? = self.event else { preconditionFailure() }
      try visitor.visitSingularMessageField(value: v, fieldNumber: 2)
    }()
    case .actionPerformed?: try {
      guard case .actionPerformed(let v)? = self.event else { preconditionFailure() }
      try visitor.visitSingularMessageField(value: v, fieldNumber: 3)
    }()
    case .sentMessage?: try {
      guard case .sentMessage(let v)? = self.event else { preconditionFailure() }
      try visitor.visitSingularMessageField(value: v, fieldNumber: 4)
    }()
    case .editedMessage?: try {
      guard case .editedMessage(let v)? = self.event else { preconditionFailure() }
      try visitor.visitSingularMessageField(value: v, fieldNumber: 5)
    }()
    case .deletedMessage?: try {
      guard case .deletedMessage(let v)? = self.event else { preconditionFailure() }
      try visitor.visitSingularMessageField(value: v, fieldNumber: 6)
    }()
    case .createdChannel?: try {
      guard case .createdChannel(let v)? = self.event else { preconditionFailure() }
      try visitor.visitSingularMessageField(value: v, fieldNumber: 7)
    }()
    case .editedChannel?: try {
      guard case .editedChannel(let v)? = self.event else { preconditionFailure() }
      try visitor.visitSingularMessageField(value: v, fieldNumber: 8)
    }()
    case .deletedChannel?: try {
      guard case .deletedChannel(let v)? = self.event else { preconditionFailure() }
      try visitor.visitSingularMessageField(value: v, fieldNumber: 9)
    }()
    case .editedGuild?: try {
      guard case .editedGuild(let v)? = self.event else { preconditionFailure() }
      try visitor.visitSingularMessageField(value: v, fieldNumber: 10)
    }()
    case .deletedGuild?: try {
      guard case .deletedGuild(let v)? = self.event else { preconditionFailure() }
      try visitor.visitSingularMessageField(value: v, fieldNumber: 11)
    }()
    case .joinedMember?: try {
      guard case .joinedMember(let v)? = self.event else { preconditionFailure() }
      try visitor.visitSingularMessageField(value: v, fieldNumber: 12)
    }()
    case .leftMember?: try {
      guard case .leftMember(let v)? = self.event else { preconditionFailure() }
      try visitor.visitSingularMessageField(value: v, fieldNumber: 13)
    }()
    case .roleMoved?: try {
      guard case .roleMoved(let v)? = self.event else { preconditionFailure() }
      try visitor.visitSingularMessageField(value: v, fieldNumber: 14)
    }()
    case .profileUpdated?: try {
      guard case .profileUpdated(let v)? = self.event else { preconditionFailure() }
      try visitor.visitSingularMessageField(value: v, fieldNumber: 15)
    }()
    case .typing?: try {
      guard case .typing(let v)? = self.event else { preconditionFailure() }
      try visitor.visitSingularMessageField(value: v, fieldNumber: 16)
    }()
    case nil: break
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  static func ==(lhs: Protocol_Chat_V1_Event, rhs: Protocol_Chat_V1_Event) -> Bool {
    if lhs.event != rhs.event {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Protocol_Chat_V1_Event.LeaveReason: SwiftProtobuf._ProtoNameProviding {
  static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    0: .same(proto: "willingly"),
    1: .same(proto: "banned"),
    2: .same(proto: "kicked"),
  ]
}

extension Protocol_Chat_V1_Event.MessageSent: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static let protoMessageName: String = Protocol_Chat_V1_Event.protoMessageName + ".MessageSent"
  static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .standard(proto: "echo_id"),
    2: .same(proto: "message"),
  ]

  mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularUInt64Field(value: &self.echoID) }()
      case 2: try { try decoder.decodeSingularMessageField(value: &self._message) }()
      default: break
      }
    }
  }

  func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if self.echoID != 0 {
      try visitor.visitSingularUInt64Field(value: self.echoID, fieldNumber: 1)
    }
    if let v = self._message {
      try visitor.visitSingularMessageField(value: v, fieldNumber: 2)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  static func ==(lhs: Protocol_Chat_V1_Event.MessageSent, rhs: Protocol_Chat_V1_Event.MessageSent) -> Bool {
    if lhs.echoID != rhs.echoID {return false}
    if lhs._message != rhs._message {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Protocol_Chat_V1_Event.MessageUpdated: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static let protoMessageName: String = Protocol_Chat_V1_Event.protoMessageName + ".MessageUpdated"
  static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .standard(proto: "guild_id"),
    2: .standard(proto: "channel_id"),
    3: .standard(proto: "message_id"),
    4: .standard(proto: "edited_at"),
    5: .same(proto: "content"),
  ]

  mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularUInt64Field(value: &self.guildID) }()
      case 2: try { try decoder.decodeSingularUInt64Field(value: &self.channelID) }()
      case 3: try { try decoder.decodeSingularUInt64Field(value: &self.messageID) }()
      case 4: try { try decoder.decodeSingularMessageField(value: &self._editedAt) }()
      case 5: try { try decoder.decodeSingularStringField(value: &self.content) }()
      default: break
      }
    }
  }

  func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if self.guildID != 0 {
      try visitor.visitSingularUInt64Field(value: self.guildID, fieldNumber: 1)
    }
    if self.channelID != 0 {
      try visitor.visitSingularUInt64Field(value: self.channelID, fieldNumber: 2)
    }
    if self.messageID != 0 {
      try visitor.visitSingularUInt64Field(value: self.messageID, fieldNumber: 3)
    }
    if let v = self._editedAt {
      try visitor.visitSingularMessageField(value: v, fieldNumber: 4)
    }
    if !self.content.isEmpty {
      try visitor.visitSingularStringField(value: self.content, fieldNumber: 5)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  static func ==(lhs: Protocol_Chat_V1_Event.MessageUpdated, rhs: Protocol_Chat_V1_Event.MessageUpdated) -> Bool {
    if lhs.guildID != rhs.guildID {return false}
    if lhs.channelID != rhs.channelID {return false}
    if lhs.messageID != rhs.messageID {return false}
    if lhs._editedAt != rhs._editedAt {return false}
    if lhs.content != rhs.content {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Protocol_Chat_V1_Event.MessageDeleted: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static let protoMessageName: String = Protocol_Chat_V1_Event.protoMessageName + ".MessageDeleted"
  static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .standard(proto: "guild_id"),
    2: .standard(proto: "channel_id"),
    3: .standard(proto: "message_id"),
  ]

  mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularUInt64Field(value: &self.guildID) }()
      case 2: try { try decoder.decodeSingularUInt64Field(value: &self.channelID) }()
      case 3: try { try decoder.decodeSingularUInt64Field(value: &self.messageID) }()
      default: break
      }
    }
  }

  func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if self.guildID != 0 {
      try visitor.visitSingularUInt64Field(value: self.guildID, fieldNumber: 1)
    }
    if self.channelID != 0 {
      try visitor.visitSingularUInt64Field(value: self.channelID, fieldNumber: 2)
    }
    if self.messageID != 0 {
      try visitor.visitSingularUInt64Field(value: self.messageID, fieldNumber: 3)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  static func ==(lhs: Protocol_Chat_V1_Event.MessageDeleted, rhs: Protocol_Chat_V1_Event.MessageDeleted) -> Bool {
    if lhs.guildID != rhs.guildID {return false}
    if lhs.channelID != rhs.channelID {return false}
    if lhs.messageID != rhs.messageID {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Protocol_Chat_V1_Event.ChannelCreated: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static let protoMessageName: String = Protocol_Chat_V1_Event.protoMessageName + ".ChannelCreated"
  static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .standard(proto: "guild_id"),
    2: .standard(proto: "channel_id"),
    3: .same(proto: "name"),
    4: .standard(proto: "previous_id"),
    5: .standard(proto: "next_id"),
    6: .standard(proto: "is_category"),
    7: .same(proto: "metadata"),
  ]

  mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularUInt64Field(value: &self.guildID) }()
      case 2: try { try decoder.decodeSingularUInt64Field(value: &self.channelID) }()
      case 3: try { try decoder.decodeSingularStringField(value: &self.name) }()
      case 4: try { try decoder.decodeSingularUInt64Field(value: &self.previousID) }()
      case 5: try { try decoder.decodeSingularUInt64Field(value: &self.nextID) }()
      case 6: try { try decoder.decodeSingularBoolField(value: &self.isCategory) }()
      case 7: try { try decoder.decodeSingularMessageField(value: &self._metadata) }()
      default: break
      }
    }
  }

  func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if self.guildID != 0 {
      try visitor.visitSingularUInt64Field(value: self.guildID, fieldNumber: 1)
    }
    if self.channelID != 0 {
      try visitor.visitSingularUInt64Field(value: self.channelID, fieldNumber: 2)
    }
    if !self.name.isEmpty {
      try visitor.visitSingularStringField(value: self.name, fieldNumber: 3)
    }
    if self.previousID != 0 {
      try visitor.visitSingularUInt64Field(value: self.previousID, fieldNumber: 4)
    }
    if self.nextID != 0 {
      try visitor.visitSingularUInt64Field(value: self.nextID, fieldNumber: 5)
    }
    if self.isCategory != false {
      try visitor.visitSingularBoolField(value: self.isCategory, fieldNumber: 6)
    }
    if let v = self._metadata {
      try visitor.visitSingularMessageField(value: v, fieldNumber: 7)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  static func ==(lhs: Protocol_Chat_V1_Event.ChannelCreated, rhs: Protocol_Chat_V1_Event.ChannelCreated) -> Bool {
    if lhs.guildID != rhs.guildID {return false}
    if lhs.channelID != rhs.channelID {return false}
    if lhs.name != rhs.name {return false}
    if lhs.previousID != rhs.previousID {return false}
    if lhs.nextID != rhs.nextID {return false}
    if lhs.isCategory != rhs.isCategory {return false}
    if lhs._metadata != rhs._metadata {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Protocol_Chat_V1_Event.ChannelUpdated: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static let protoMessageName: String = Protocol_Chat_V1_Event.protoMessageName + ".ChannelUpdated"
  static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .standard(proto: "guild_id"),
    2: .standard(proto: "channel_id"),
    3: .same(proto: "name"),
    4: .standard(proto: "update_name"),
    5: .standard(proto: "previous_id"),
    6: .standard(proto: "next_id"),
    7: .standard(proto: "update_order"),
    8: .same(proto: "metadata"),
    9: .standard(proto: "update_metadata"),
  ]

  mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularUInt64Field(value: &self.guildID) }()
      case 2: try { try decoder.decodeSingularUInt64Field(value: &self.channelID) }()
      case 3: try { try decoder.decodeSingularStringField(value: &self.name) }()
      case 4: try { try decoder.decodeSingularBoolField(value: &self.updateName) }()
      case 5: try { try decoder.decodeSingularUInt64Field(value: &self.previousID) }()
      case 6: try { try decoder.decodeSingularUInt64Field(value: &self.nextID) }()
      case 7: try { try decoder.decodeSingularBoolField(value: &self.updateOrder) }()
      case 8: try { try decoder.decodeSingularMessageField(value: &self._metadata) }()
      case 9: try { try decoder.decodeSingularBoolField(value: &self.updateMetadata) }()
      default: break
      }
    }
  }

  func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if self.guildID != 0 {
      try visitor.visitSingularUInt64Field(value: self.guildID, fieldNumber: 1)
    }
    if self.channelID != 0 {
      try visitor.visitSingularUInt64Field(value: self.channelID, fieldNumber: 2)
    }
    if !self.name.isEmpty {
      try visitor.visitSingularStringField(value: self.name, fieldNumber: 3)
    }
    if self.updateName != false {
      try visitor.visitSingularBoolField(value: self.updateName, fieldNumber: 4)
    }
    if self.previousID != 0 {
      try visitor.visitSingularUInt64Field(value: self.previousID, fieldNumber: 5)
    }
    if self.nextID != 0 {
      try visitor.visitSingularUInt64Field(value: self.nextID, fieldNumber: 6)
    }
    if self.updateOrder != false {
      try visitor.visitSingularBoolField(value: self.updateOrder, fieldNumber: 7)
    }
    if let v = self._metadata {
      try visitor.visitSingularMessageField(value: v, fieldNumber: 8)
    }
    if self.updateMetadata != false {
      try visitor.visitSingularBoolField(value: self.updateMetadata, fieldNumber: 9)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  static func ==(lhs: Protocol_Chat_V1_Event.ChannelUpdated, rhs: Protocol_Chat_V1_Event.ChannelUpdated) -> Bool {
    if lhs.guildID != rhs.guildID {return false}
    if lhs.channelID != rhs.channelID {return false}
    if lhs.name != rhs.name {return false}
    if lhs.updateName != rhs.updateName {return false}
    if lhs.previousID != rhs.previousID {return false}
    if lhs.nextID != rhs.nextID {return false}
    if lhs.updateOrder != rhs.updateOrder {return false}
    if lhs._metadata != rhs._metadata {return false}
    if lhs.updateMetadata != rhs.updateMetadata {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Protocol_Chat_V1_Event.ChannelDeleted: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static let protoMessageName: String = Protocol_Chat_V1_Event.protoMessageName + ".ChannelDeleted"
  static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .standard(proto: "guild_id"),
    2: .standard(proto: "channel_id"),
  ]

  mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularUInt64Field(value: &self.guildID) }()
      case 2: try { try decoder.decodeSingularUInt64Field(value: &self.channelID) }()
      default: break
      }
    }
  }

  func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if self.guildID != 0 {
      try visitor.visitSingularUInt64Field(value: self.guildID, fieldNumber: 1)
    }
    if self.channelID != 0 {
      try visitor.visitSingularUInt64Field(value: self.channelID, fieldNumber: 2)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  static func ==(lhs: Protocol_Chat_V1_Event.ChannelDeleted, rhs: Protocol_Chat_V1_Event.ChannelDeleted) -> Bool {
    if lhs.guildID != rhs.guildID {return false}
    if lhs.channelID != rhs.channelID {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Protocol_Chat_V1_Event.GuildUpdated: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static let protoMessageName: String = Protocol_Chat_V1_Event.protoMessageName + ".GuildUpdated"
  static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .standard(proto: "guild_id"),
    2: .same(proto: "name"),
    3: .standard(proto: "update_name"),
    4: .same(proto: "picture"),
    5: .standard(proto: "update_picture"),
    6: .same(proto: "metadata"),
    7: .standard(proto: "update_metadata"),
  ]

  mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularUInt64Field(value: &self.guildID) }()
      case 2: try { try decoder.decodeSingularStringField(value: &self.name) }()
      case 3: try { try decoder.decodeSingularBoolField(value: &self.updateName) }()
      case 4: try { try decoder.decodeSingularStringField(value: &self.picture) }()
      case 5: try { try decoder.decodeSingularBoolField(value: &self.updatePicture) }()
      case 6: try { try decoder.decodeSingularMessageField(value: &self._metadata) }()
      case 7: try { try decoder.decodeSingularBoolField(value: &self.updateMetadata) }()
      default: break
      }
    }
  }

  func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if self.guildID != 0 {
      try visitor.visitSingularUInt64Field(value: self.guildID, fieldNumber: 1)
    }
    if !self.name.isEmpty {
      try visitor.visitSingularStringField(value: self.name, fieldNumber: 2)
    }
    if self.updateName != false {
      try visitor.visitSingularBoolField(value: self.updateName, fieldNumber: 3)
    }
    if !self.picture.isEmpty {
      try visitor.visitSingularStringField(value: self.picture, fieldNumber: 4)
    }
    if self.updatePicture != false {
      try visitor.visitSingularBoolField(value: self.updatePicture, fieldNumber: 5)
    }
    if let v = self._metadata {
      try visitor.visitSingularMessageField(value: v, fieldNumber: 6)
    }
    if self.updateMetadata != false {
      try visitor.visitSingularBoolField(value: self.updateMetadata, fieldNumber: 7)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  static func ==(lhs: Protocol_Chat_V1_Event.GuildUpdated, rhs: Protocol_Chat_V1_Event.GuildUpdated) -> Bool {
    if lhs.guildID != rhs.guildID {return false}
    if lhs.name != rhs.name {return false}
    if lhs.updateName != rhs.updateName {return false}
    if lhs.picture != rhs.picture {return false}
    if lhs.updatePicture != rhs.updatePicture {return false}
    if lhs._metadata != rhs._metadata {return false}
    if lhs.updateMetadata != rhs.updateMetadata {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Protocol_Chat_V1_Event.GuildDeleted: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static let protoMessageName: String = Protocol_Chat_V1_Event.protoMessageName + ".GuildDeleted"
  static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .standard(proto: "guild_id"),
  ]

  mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularUInt64Field(value: &self.guildID) }()
      default: break
      }
    }
  }

  func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if self.guildID != 0 {
      try visitor.visitSingularUInt64Field(value: self.guildID, fieldNumber: 1)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  static func ==(lhs: Protocol_Chat_V1_Event.GuildDeleted, rhs: Protocol_Chat_V1_Event.GuildDeleted) -> Bool {
    if lhs.guildID != rhs.guildID {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Protocol_Chat_V1_Event.MemberJoined: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static let protoMessageName: String = Protocol_Chat_V1_Event.protoMessageName + ".MemberJoined"
  static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .standard(proto: "member_id"),
    2: .standard(proto: "guild_id"),
  ]

  mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularUInt64Field(value: &self.memberID) }()
      case 2: try { try decoder.decodeSingularUInt64Field(value: &self.guildID) }()
      default: break
      }
    }
  }

  func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if self.memberID != 0 {
      try visitor.visitSingularUInt64Field(value: self.memberID, fieldNumber: 1)
    }
    if self.guildID != 0 {
      try visitor.visitSingularUInt64Field(value: self.guildID, fieldNumber: 2)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  static func ==(lhs: Protocol_Chat_V1_Event.MemberJoined, rhs: Protocol_Chat_V1_Event.MemberJoined) -> Bool {
    if lhs.memberID != rhs.memberID {return false}
    if lhs.guildID != rhs.guildID {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Protocol_Chat_V1_Event.MemberLeft: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static let protoMessageName: String = Protocol_Chat_V1_Event.protoMessageName + ".MemberLeft"
  static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .standard(proto: "member_id"),
    2: .standard(proto: "guild_id"),
    3: .standard(proto: "leave_reason"),
  ]

  mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularUInt64Field(value: &self.memberID) }()
      case 2: try { try decoder.decodeSingularUInt64Field(value: &self.guildID) }()
      case 3: try { try decoder.decodeSingularEnumField(value: &self.leaveReason) }()
      default: break
      }
    }
  }

  func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if self.memberID != 0 {
      try visitor.visitSingularUInt64Field(value: self.memberID, fieldNumber: 1)
    }
    if self.guildID != 0 {
      try visitor.visitSingularUInt64Field(value: self.guildID, fieldNumber: 2)
    }
    if self.leaveReason != .willingly {
      try visitor.visitSingularEnumField(value: self.leaveReason, fieldNumber: 3)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  static func ==(lhs: Protocol_Chat_V1_Event.MemberLeft, rhs: Protocol_Chat_V1_Event.MemberLeft) -> Bool {
    if lhs.memberID != rhs.memberID {return false}
    if lhs.guildID != rhs.guildID {return false}
    if lhs.leaveReason != rhs.leaveReason {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Protocol_Chat_V1_Event.GuildAddedToList: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static let protoMessageName: String = Protocol_Chat_V1_Event.protoMessageName + ".GuildAddedToList"
  static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .standard(proto: "guild_id"),
    2: .same(proto: "homeserver"),
  ]

  mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularUInt64Field(value: &self.guildID) }()
      case 2: try { try decoder.decodeSingularStringField(value: &self.homeserver) }()
      default: break
      }
    }
  }

  func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if self.guildID != 0 {
      try visitor.visitSingularUInt64Field(value: self.guildID, fieldNumber: 1)
    }
    if !self.homeserver.isEmpty {
      try visitor.visitSingularStringField(value: self.homeserver, fieldNumber: 2)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  static func ==(lhs: Protocol_Chat_V1_Event.GuildAddedToList, rhs: Protocol_Chat_V1_Event.GuildAddedToList) -> Bool {
    if lhs.guildID != rhs.guildID {return false}
    if lhs.homeserver != rhs.homeserver {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Protocol_Chat_V1_Event.GuildRemovedFromList: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static let protoMessageName: String = Protocol_Chat_V1_Event.protoMessageName + ".GuildRemovedFromList"
  static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .standard(proto: "guild_id"),
    2: .same(proto: "homeserver"),
  ]

  mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularUInt64Field(value: &self.guildID) }()
      case 2: try { try decoder.decodeSingularStringField(value: &self.homeserver) }()
      default: break
      }
    }
  }

  func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if self.guildID != 0 {
      try visitor.visitSingularUInt64Field(value: self.guildID, fieldNumber: 1)
    }
    if !self.homeserver.isEmpty {
      try visitor.visitSingularStringField(value: self.homeserver, fieldNumber: 2)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  static func ==(lhs: Protocol_Chat_V1_Event.GuildRemovedFromList, rhs: Protocol_Chat_V1_Event.GuildRemovedFromList) -> Bool {
    if lhs.guildID != rhs.guildID {return false}
    if lhs.homeserver != rhs.homeserver {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Protocol_Chat_V1_Event.ActionPerformed: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static let protoMessageName: String = Protocol_Chat_V1_Event.protoMessageName + ".ActionPerformed"
  static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .standard(proto: "guild_id"),
    2: .standard(proto: "channel_id"),
    3: .standard(proto: "message_id"),
    4: .standard(proto: "action_id"),
    5: .standard(proto: "action_data"),
  ]

  mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularUInt64Field(value: &self.guildID) }()
      case 2: try { try decoder.decodeSingularUInt64Field(value: &self.channelID) }()
      case 3: try { try decoder.decodeSingularUInt64Field(value: &self.messageID) }()
      case 4: try { try decoder.decodeSingularStringField(value: &self.actionID) }()
      case 5: try { try decoder.decodeSingularStringField(value: &self.actionData) }()
      default: break
      }
    }
  }

  func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if self.guildID != 0 {
      try visitor.visitSingularUInt64Field(value: self.guildID, fieldNumber: 1)
    }
    if self.channelID != 0 {
      try visitor.visitSingularUInt64Field(value: self.channelID, fieldNumber: 2)
    }
    if self.messageID != 0 {
      try visitor.visitSingularUInt64Field(value: self.messageID, fieldNumber: 3)
    }
    if !self.actionID.isEmpty {
      try visitor.visitSingularStringField(value: self.actionID, fieldNumber: 4)
    }
    if !self.actionData.isEmpty {
      try visitor.visitSingularStringField(value: self.actionData, fieldNumber: 5)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  static func ==(lhs: Protocol_Chat_V1_Event.ActionPerformed, rhs: Protocol_Chat_V1_Event.ActionPerformed) -> Bool {
    if lhs.guildID != rhs.guildID {return false}
    if lhs.channelID != rhs.channelID {return false}
    if lhs.messageID != rhs.messageID {return false}
    if lhs.actionID != rhs.actionID {return false}
    if lhs.actionData != rhs.actionData {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Protocol_Chat_V1_Event.RoleMoved: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static let protoMessageName: String = Protocol_Chat_V1_Event.protoMessageName + ".RoleMoved"
  static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .standard(proto: "guild_id"),
    2: .standard(proto: "role_id"),
  ]

  mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularUInt64Field(value: &self.guildID) }()
      case 2: try { try decoder.decodeSingularUInt64Field(value: &self.roleID) }()
      default: break
      }
    }
  }

  func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if self.guildID != 0 {
      try visitor.visitSingularUInt64Field(value: self.guildID, fieldNumber: 1)
    }
    if self.roleID != 0 {
      try visitor.visitSingularUInt64Field(value: self.roleID, fieldNumber: 2)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  static func ==(lhs: Protocol_Chat_V1_Event.RoleMoved, rhs: Protocol_Chat_V1_Event.RoleMoved) -> Bool {
    if lhs.guildID != rhs.guildID {return false}
    if lhs.roleID != rhs.roleID {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Protocol_Chat_V1_Event.ProfileUpdated: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static let protoMessageName: String = Protocol_Chat_V1_Event.protoMessageName + ".ProfileUpdated"
  static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .standard(proto: "user_id"),
    2: .standard(proto: "new_username"),
    3: .standard(proto: "update_username"),
    4: .standard(proto: "new_avatar"),
    5: .standard(proto: "update_avatar"),
    6: .standard(proto: "new_status"),
    7: .standard(proto: "update_status"),
    8: .standard(proto: "is_bot"),
    9: .standard(proto: "update_is_bot"),
  ]

  mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularUInt64Field(value: &self.userID) }()
      case 2: try { try decoder.decodeSingularStringField(value: &self.newUsername) }()
      case 3: try { try decoder.decodeSingularBoolField(value: &self.updateUsername) }()
      case 4: try { try decoder.decodeSingularStringField(value: &self.newAvatar) }()
      case 5: try { try decoder.decodeSingularBoolField(value: &self.updateAvatar) }()
      case 6: try { try decoder.decodeSingularEnumField(value: &self.newStatus) }()
      case 7: try { try decoder.decodeSingularBoolField(value: &self.updateStatus) }()
      case 8: try { try decoder.decodeSingularBoolField(value: &self.isBot) }()
      case 9: try { try decoder.decodeSingularBoolField(value: &self.updateIsBot) }()
      default: break
      }
    }
  }

  func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if self.userID != 0 {
      try visitor.visitSingularUInt64Field(value: self.userID, fieldNumber: 1)
    }
    if !self.newUsername.isEmpty {
      try visitor.visitSingularStringField(value: self.newUsername, fieldNumber: 2)
    }
    if self.updateUsername != false {
      try visitor.visitSingularBoolField(value: self.updateUsername, fieldNumber: 3)
    }
    if !self.newAvatar.isEmpty {
      try visitor.visitSingularStringField(value: self.newAvatar, fieldNumber: 4)
    }
    if self.updateAvatar != false {
      try visitor.visitSingularBoolField(value: self.updateAvatar, fieldNumber: 5)
    }
    if self.newStatus != .onlineUnspecified {
      try visitor.visitSingularEnumField(value: self.newStatus, fieldNumber: 6)
    }
    if self.updateStatus != false {
      try visitor.visitSingularBoolField(value: self.updateStatus, fieldNumber: 7)
    }
    if self.isBot != false {
      try visitor.visitSingularBoolField(value: self.isBot, fieldNumber: 8)
    }
    if self.updateIsBot != false {
      try visitor.visitSingularBoolField(value: self.updateIsBot, fieldNumber: 9)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  static func ==(lhs: Protocol_Chat_V1_Event.ProfileUpdated, rhs: Protocol_Chat_V1_Event.ProfileUpdated) -> Bool {
    if lhs.userID != rhs.userID {return false}
    if lhs.newUsername != rhs.newUsername {return false}
    if lhs.updateUsername != rhs.updateUsername {return false}
    if lhs.newAvatar != rhs.newAvatar {return false}
    if lhs.updateAvatar != rhs.updateAvatar {return false}
    if lhs.newStatus != rhs.newStatus {return false}
    if lhs.updateStatus != rhs.updateStatus {return false}
    if lhs.isBot != rhs.isBot {return false}
    if lhs.updateIsBot != rhs.updateIsBot {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Protocol_Chat_V1_Event.Typing: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static let protoMessageName: String = Protocol_Chat_V1_Event.protoMessageName + ".Typing"
  static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .standard(proto: "user_id"),
    2: .standard(proto: "guild_id"),
    3: .standard(proto: "channel_id"),
  ]

  mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularUInt64Field(value: &self.userID) }()
      case 2: try { try decoder.decodeSingularUInt64Field(value: &self.guildID) }()
      case 3: try { try decoder.decodeSingularUInt64Field(value: &self.channelID) }()
      default: break
      }
    }
  }

  func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if self.userID != 0 {
      try visitor.visitSingularUInt64Field(value: self.userID, fieldNumber: 1)
    }
    if self.guildID != 0 {
      try visitor.visitSingularUInt64Field(value: self.guildID, fieldNumber: 2)
    }
    if self.channelID != 0 {
      try visitor.visitSingularUInt64Field(value: self.channelID, fieldNumber: 3)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  static func ==(lhs: Protocol_Chat_V1_Event.Typing, rhs: Protocol_Chat_V1_Event.Typing) -> Bool {
    if lhs.userID != rhs.userID {return false}
    if lhs.guildID != rhs.guildID {return false}
    if lhs.channelID != rhs.channelID {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}
