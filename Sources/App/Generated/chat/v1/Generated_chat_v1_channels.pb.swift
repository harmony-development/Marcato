// DO NOT EDIT.
// swift-format-ignore-file
//
// Generated by the Swift generator plugin for the protocol buffer compiler.
// Source: chat/v1/channels.proto
//
// For information on using the generated types, please see the documentation:
//   https://github.com/apple/swift-protobuf/

import Foundation
import SwiftProtobuf

// If the compiler emits an error on this type, it is because this file
// was generated by a version of the `protoc` Swift plug-in that is
// incompatible with the version of SwiftProtobuf to which you are linking.
// Please ensure that you are building against the same version of the API
// that was used to generate this file.
fileprivate struct _GeneratedWithProtocGenSwiftVersion: SwiftProtobuf.ProtobufAPIVersionCheck {
  struct _2: SwiftProtobuf.ProtobufAPIVersion_2 {}
  typealias Version = _2
}

/// What kind the channel is.
enum Protocol_Chat_V1_ChannelKind: SwiftProtobuf.Enum {
  typealias RawValue = Int

  /// A text channel. Allows you to simply send messages to a group of people.
  case textUnspecified // = 0

  /// A voice channel. Allows you to talk to other people with voice.
  case voiceMedia // = 1

  /// A category channel. All channels under this channel down to another
  /// category channel belongs to this category channel.
  case category // = 2
  case UNRECOGNIZED(Int)

  init() {
    self = .textUnspecified
  }

  init?(rawValue: Int) {
    switch rawValue {
    case 0: self = .textUnspecified
    case 1: self = .voiceMedia
    case 2: self = .category
    default: self = .UNRECOGNIZED(rawValue)
    }
  }

  var rawValue: Int {
    switch self {
    case .textUnspecified: return 0
    case .voiceMedia: return 1
    case .category: return 2
    case .UNRECOGNIZED(let i): return i
    }
  }

}

#if swift(>=4.2)

extension Protocol_Chat_V1_ChannelKind: CaseIterable {
  // The compiler won't synthesize support with the UNRECOGNIZED case.
  static var allCases: [Protocol_Chat_V1_ChannelKind] = [
    .textUnspecified,
    .voiceMedia,
    .category,
  ]
}

#endif  // swift(>=4.2)

/// An object representing a channel, without the ID.
struct Protocol_Chat_V1_Channel {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  /// The name of this channel.
  var channelName: String = String()

  /// The kind of channel this is.
  /// Data does not get inherently stored in the Channel type
  /// Instead, clients who understand a certain ChannelKind should
  /// fetch them from a separate RPC.
  var kind: Protocol_Chat_V1_ChannelKind = .textUnspecified

  /// The metadata of this channel.
  var metadata: Protocol_Harmonytypes_V1_Metadata {
    get {return _metadata ?? Protocol_Harmonytypes_V1_Metadata()}
    set {_metadata = newValue}
  }
  /// Returns true if `metadata` has been explicitly set.
  var hasMetadata: Bool {return self._metadata != nil}
  /// Clears the value of `metadata`. Subsequent reads from it will return its default value.
  mutating func clearMetadata() {self._metadata = nil}

  var unknownFields = SwiftProtobuf.UnknownStorage()

  init() {}

  fileprivate var _metadata: Protocol_Harmonytypes_V1_Metadata? = nil
}

/// The channel alongside with an ID.
struct Protocol_Chat_V1_ChannelWithId {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  /// ID of the channel.
  var channelID: UInt64 = 0

  /// The channel data.
  var channel: Protocol_Chat_V1_Channel {
    get {return _channel ?? Protocol_Chat_V1_Channel()}
    set {_channel = newValue}
  }
  /// Returns true if `channel` has been explicitly set.
  var hasChannel: Bool {return self._channel != nil}
  /// Clears the value of `channel`. Subsequent reads from it will return its default value.
  mutating func clearChannel() {self._channel = nil}

  var unknownFields = SwiftProtobuf.UnknownStorage()

  init() {}

  fileprivate var _channel: Protocol_Chat_V1_Channel? = nil
}

/// Channel Kinds:
///
/// Channel kinds specified in an official Harmony protocol will start with a
/// "h." prefix. Third-party extensions should not use the "h." prefix. If no
/// kind is specified, the channel is a text channel.
///
/// Kinds indicate additional functionality a channel may have: for example,
/// h.voice can indicate that a channel has voice functionalities alongside
/// the usual text fare.
///
/// Used in the `CreateChannel` endpoint.
struct Protocol_Chat_V1_CreateChannelRequest {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  /// Guild ID of the guild to create a channel in.
  var guildID: UInt64 = 0

  /// The name of this channel.
  var channelName: String = String()

  /// The kind of this channel.
  var kind: Protocol_Chat_V1_ChannelKind = .textUnspecified

  /// The metadata of this channel.
  var metadata: Protocol_Harmonytypes_V1_Metadata {
    get {return _metadata ?? Protocol_Harmonytypes_V1_Metadata()}
    set {_metadata = newValue}
  }
  /// Returns true if `metadata` has been explicitly set.
  var hasMetadata: Bool {return self._metadata != nil}
  /// Clears the value of `metadata`. Subsequent reads from it will return its default value.
  mutating func clearMetadata() {self._metadata = nil}

  /// The position of your new channel in the channel list.
  ///
  /// If not specified, it will be put at the bottom of the channel list.
  var position: Protocol_Harmonytypes_V1_ItemPosition {
    get {return _position ?? Protocol_Harmonytypes_V1_ItemPosition()}
    set {_position = newValue}
  }
  /// Returns true if `position` has been explicitly set.
  var hasPosition: Bool {return self._position != nil}
  /// Clears the value of `position`. Subsequent reads from it will return its default value.
  mutating func clearPosition() {self._position = nil}

  var unknownFields = SwiftProtobuf.UnknownStorage()

  init() {}

  fileprivate var _metadata: Protocol_Harmonytypes_V1_Metadata? = nil
  fileprivate var _position: Protocol_Harmonytypes_V1_ItemPosition? = nil
}

/// Used in the `CreateChannel` endpoint.
struct Protocol_Chat_V1_CreateChannelResponse {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  /// ID of the channel that was created.
  var channelID: UInt64 = 0

  var unknownFields = SwiftProtobuf.UnknownStorage()

  init() {}
}

/// Used in the `GetGuildChannels` endpoint.
struct Protocol_Chat_V1_GetGuildChannelsRequest {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  /// Guild ID of the guild you want to get channels from.
  var guildID: UInt64 = 0

  var unknownFields = SwiftProtobuf.UnknownStorage()

  init() {}
}

/// Used in the `GetGuildChannels` endpoint.
struct Protocol_Chat_V1_GetGuildChannelsResponse {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  /// Channels' data and ID the server responded with.
  var channels: [Protocol_Chat_V1_ChannelWithId] = []

  var unknownFields = SwiftProtobuf.UnknownStorage()

  init() {}
}

/// Used in the `UpdateChannelInformation` endpoint.
struct Protocol_Chat_V1_UpdateChannelInformationRequest {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  /// Guild ID of the guild where the channel is.
  var guildID: UInt64 = 0

  /// Channel ID of the channel you want to change the information of.
  var channelID: UInt64 = 0

  /// New name to set for this channel.
  var newName: String {
    get {return _newName ?? String()}
    set {_newName = newValue}
  }
  /// Returns true if `newName` has been explicitly set.
  var hasNewName: Bool {return self._newName != nil}
  /// Clears the value of `newName`. Subsequent reads from it will return its default value.
  mutating func clearNewName() {self._newName = nil}

  /// New metadata to set for this channel.
  var newMetadata: Protocol_Harmonytypes_V1_Metadata {
    get {return _newMetadata ?? Protocol_Harmonytypes_V1_Metadata()}
    set {_newMetadata = newValue}
  }
  /// Returns true if `newMetadata` has been explicitly set.
  var hasNewMetadata: Bool {return self._newMetadata != nil}
  /// Clears the value of `newMetadata`. Subsequent reads from it will return its default value.
  mutating func clearNewMetadata() {self._newMetadata = nil}

  var unknownFields = SwiftProtobuf.UnknownStorage()

  init() {}

  fileprivate var _newName: String? = nil
  fileprivate var _newMetadata: Protocol_Harmonytypes_V1_Metadata? = nil
}

/// Used in the `UpdateChannelInformation` endpoint.
struct Protocol_Chat_V1_UpdateChannelInformationResponse {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  var unknownFields = SwiftProtobuf.UnknownStorage()

  init() {}
}

/// Used in the `UpdateChannelOrder` endpoint.
struct Protocol_Chat_V1_UpdateChannelOrderRequest {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  /// Guild ID of the guild that has the channel.
  var guildID: UInt64 = 0

  /// Channel ID of the channel that you want to move.
  var channelID: UInt64 = 0

  /// The new position of this channel.
  var newPosition: Protocol_Harmonytypes_V1_ItemPosition {
    get {return _newPosition ?? Protocol_Harmonytypes_V1_ItemPosition()}
    set {_newPosition = newValue}
  }
  /// Returns true if `newPosition` has been explicitly set.
  var hasNewPosition: Bool {return self._newPosition != nil}
  /// Clears the value of `newPosition`. Subsequent reads from it will return its default value.
  mutating func clearNewPosition() {self._newPosition = nil}

  var unknownFields = SwiftProtobuf.UnknownStorage()

  init() {}

  fileprivate var _newPosition: Protocol_Harmonytypes_V1_ItemPosition? = nil
}

/// Used in the `UpdateChannelOrder` endpoint.
struct Protocol_Chat_V1_UpdateChannelOrderResponse {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  var unknownFields = SwiftProtobuf.UnknownStorage()

  init() {}
}

/// Request specifiying the order of all channels in a guild at once
struct Protocol_Chat_V1_UpdateAllChannelOrderRequest {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  /// guild_id: the guild to specify the new channel order for
  var guildID: UInt64 = 0

  /// channel_ids: the new order of channel ids
  var channelIds: [UInt64] = []

  var unknownFields = SwiftProtobuf.UnknownStorage()

  init() {}
}

/// Used in the `UpdateAllChannelOrder` endpoint.
struct Protocol_Chat_V1_UpdateAllChannelOrderResponse {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  var unknownFields = SwiftProtobuf.UnknownStorage()

  init() {}
}

/// Used in the `DeleteChannel` endpoint.
struct Protocol_Chat_V1_DeleteChannelRequest {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  /// Guild ID of the guild that has the channel.
  var guildID: UInt64 = 0

  /// Channel ID of the channel you want to delete.
  var channelID: UInt64 = 0

  var unknownFields = SwiftProtobuf.UnknownStorage()

  init() {}
}

/// Used in the `DeleteChannel` endpoint.
struct Protocol_Chat_V1_DeleteChannelResponse {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  var unknownFields = SwiftProtobuf.UnknownStorage()

  init() {}
}

/// Used in `Typing` endpoint.
struct Protocol_Chat_V1_TypingRequest {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  /// The guild id of the channel the user is typing in.
  var guildID: UInt64 = 0

  /// The channel id of the channel the user is typing in.
  var channelID: UInt64 = 0

  var unknownFields = SwiftProtobuf.UnknownStorage()

  init() {}
}

/// Used in `Typing` endpoint.
struct Protocol_Chat_V1_TypingResponse {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  var unknownFields = SwiftProtobuf.UnknownStorage()

  init() {}
}

// MARK: - Code below here is support for the SwiftProtobuf runtime.

fileprivate let _protobuf_package = "protocol.chat.v1"

extension Protocol_Chat_V1_ChannelKind: SwiftProtobuf._ProtoNameProviding {
  static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    0: .same(proto: "CHANNEL_KIND_TEXT_UNSPECIFIED"),
    1: .same(proto: "CHANNEL_KIND_VOICE_MEDIA"),
    2: .same(proto: "CHANNEL_KIND_CATEGORY"),
  ]
}

extension Protocol_Chat_V1_Channel: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static let protoMessageName: String = _protobuf_package + ".Channel"
  static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .standard(proto: "channel_name"),
    2: .same(proto: "kind"),
    3: .same(proto: "metadata"),
  ]

  mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularStringField(value: &self.channelName) }()
      case 2: try { try decoder.decodeSingularEnumField(value: &self.kind) }()
      case 3: try { try decoder.decodeSingularMessageField(value: &self._metadata) }()
      default: break
      }
    }
  }

  func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if !self.channelName.isEmpty {
      try visitor.visitSingularStringField(value: self.channelName, fieldNumber: 1)
    }
    if self.kind != .textUnspecified {
      try visitor.visitSingularEnumField(value: self.kind, fieldNumber: 2)
    }
    if let v = self._metadata {
      try visitor.visitSingularMessageField(value: v, fieldNumber: 3)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  static func ==(lhs: Protocol_Chat_V1_Channel, rhs: Protocol_Chat_V1_Channel) -> Bool {
    if lhs.channelName != rhs.channelName {return false}
    if lhs.kind != rhs.kind {return false}
    if lhs._metadata != rhs._metadata {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Protocol_Chat_V1_ChannelWithId: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static let protoMessageName: String = _protobuf_package + ".ChannelWithId"
  static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .standard(proto: "channel_id"),
    2: .same(proto: "channel"),
  ]

  mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularUInt64Field(value: &self.channelID) }()
      case 2: try { try decoder.decodeSingularMessageField(value: &self._channel) }()
      default: break
      }
    }
  }

  func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if self.channelID != 0 {
      try visitor.visitSingularUInt64Field(value: self.channelID, fieldNumber: 1)
    }
    if let v = self._channel {
      try visitor.visitSingularMessageField(value: v, fieldNumber: 2)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  static func ==(lhs: Protocol_Chat_V1_ChannelWithId, rhs: Protocol_Chat_V1_ChannelWithId) -> Bool {
    if lhs.channelID != rhs.channelID {return false}
    if lhs._channel != rhs._channel {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Protocol_Chat_V1_CreateChannelRequest: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static let protoMessageName: String = _protobuf_package + ".CreateChannelRequest"
  static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .standard(proto: "guild_id"),
    2: .standard(proto: "channel_name"),
    3: .same(proto: "kind"),
    4: .same(proto: "metadata"),
    5: .same(proto: "position"),
  ]

  mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularUInt64Field(value: &self.guildID) }()
      case 2: try { try decoder.decodeSingularStringField(value: &self.channelName) }()
      case 3: try { try decoder.decodeSingularEnumField(value: &self.kind) }()
      case 4: try { try decoder.decodeSingularMessageField(value: &self._metadata) }()
      case 5: try { try decoder.decodeSingularMessageField(value: &self._position) }()
      default: break
      }
    }
  }

  func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if self.guildID != 0 {
      try visitor.visitSingularUInt64Field(value: self.guildID, fieldNumber: 1)
    }
    if !self.channelName.isEmpty {
      try visitor.visitSingularStringField(value: self.channelName, fieldNumber: 2)
    }
    if self.kind != .textUnspecified {
      try visitor.visitSingularEnumField(value: self.kind, fieldNumber: 3)
    }
    if let v = self._metadata {
      try visitor.visitSingularMessageField(value: v, fieldNumber: 4)
    }
    if let v = self._position {
      try visitor.visitSingularMessageField(value: v, fieldNumber: 5)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  static func ==(lhs: Protocol_Chat_V1_CreateChannelRequest, rhs: Protocol_Chat_V1_CreateChannelRequest) -> Bool {
    if lhs.guildID != rhs.guildID {return false}
    if lhs.channelName != rhs.channelName {return false}
    if lhs.kind != rhs.kind {return false}
    if lhs._metadata != rhs._metadata {return false}
    if lhs._position != rhs._position {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Protocol_Chat_V1_CreateChannelResponse: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static let protoMessageName: String = _protobuf_package + ".CreateChannelResponse"
  static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .standard(proto: "channel_id"),
  ]

  mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularUInt64Field(value: &self.channelID) }()
      default: break
      }
    }
  }

  func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if self.channelID != 0 {
      try visitor.visitSingularUInt64Field(value: self.channelID, fieldNumber: 1)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  static func ==(lhs: Protocol_Chat_V1_CreateChannelResponse, rhs: Protocol_Chat_V1_CreateChannelResponse) -> Bool {
    if lhs.channelID != rhs.channelID {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Protocol_Chat_V1_GetGuildChannelsRequest: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static let protoMessageName: String = _protobuf_package + ".GetGuildChannelsRequest"
  static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .standard(proto: "guild_id"),
  ]

  mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularUInt64Field(value: &self.guildID) }()
      default: break
      }
    }
  }

  func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if self.guildID != 0 {
      try visitor.visitSingularUInt64Field(value: self.guildID, fieldNumber: 1)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  static func ==(lhs: Protocol_Chat_V1_GetGuildChannelsRequest, rhs: Protocol_Chat_V1_GetGuildChannelsRequest) -> Bool {
    if lhs.guildID != rhs.guildID {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Protocol_Chat_V1_GetGuildChannelsResponse: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static let protoMessageName: String = _protobuf_package + ".GetGuildChannelsResponse"
  static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "channels"),
  ]

  mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeRepeatedMessageField(value: &self.channels) }()
      default: break
      }
    }
  }

  func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if !self.channels.isEmpty {
      try visitor.visitRepeatedMessageField(value: self.channels, fieldNumber: 1)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  static func ==(lhs: Protocol_Chat_V1_GetGuildChannelsResponse, rhs: Protocol_Chat_V1_GetGuildChannelsResponse) -> Bool {
    if lhs.channels != rhs.channels {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Protocol_Chat_V1_UpdateChannelInformationRequest: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static let protoMessageName: String = _protobuf_package + ".UpdateChannelInformationRequest"
  static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .standard(proto: "guild_id"),
    2: .standard(proto: "channel_id"),
    3: .standard(proto: "new_name"),
    4: .standard(proto: "new_metadata"),
  ]

  mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularUInt64Field(value: &self.guildID) }()
      case 2: try { try decoder.decodeSingularUInt64Field(value: &self.channelID) }()
      case 3: try { try decoder.decodeSingularStringField(value: &self._newName) }()
      case 4: try { try decoder.decodeSingularMessageField(value: &self._newMetadata) }()
      default: break
      }
    }
  }

  func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if self.guildID != 0 {
      try visitor.visitSingularUInt64Field(value: self.guildID, fieldNumber: 1)
    }
    if self.channelID != 0 {
      try visitor.visitSingularUInt64Field(value: self.channelID, fieldNumber: 2)
    }
    if let v = self._newName {
      try visitor.visitSingularStringField(value: v, fieldNumber: 3)
    }
    if let v = self._newMetadata {
      try visitor.visitSingularMessageField(value: v, fieldNumber: 4)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  static func ==(lhs: Protocol_Chat_V1_UpdateChannelInformationRequest, rhs: Protocol_Chat_V1_UpdateChannelInformationRequest) -> Bool {
    if lhs.guildID != rhs.guildID {return false}
    if lhs.channelID != rhs.channelID {return false}
    if lhs._newName != rhs._newName {return false}
    if lhs._newMetadata != rhs._newMetadata {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Protocol_Chat_V1_UpdateChannelInformationResponse: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static let protoMessageName: String = _protobuf_package + ".UpdateChannelInformationResponse"
  static let _protobuf_nameMap = SwiftProtobuf._NameMap()

  mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let _ = try decoder.nextFieldNumber() {
    }
  }

  func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    try unknownFields.traverse(visitor: &visitor)
  }

  static func ==(lhs: Protocol_Chat_V1_UpdateChannelInformationResponse, rhs: Protocol_Chat_V1_UpdateChannelInformationResponse) -> Bool {
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Protocol_Chat_V1_UpdateChannelOrderRequest: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static let protoMessageName: String = _protobuf_package + ".UpdateChannelOrderRequest"
  static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .standard(proto: "guild_id"),
    2: .standard(proto: "channel_id"),
    3: .standard(proto: "new_position"),
  ]

  mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularUInt64Field(value: &self.guildID) }()
      case 2: try { try decoder.decodeSingularUInt64Field(value: &self.channelID) }()
      case 3: try { try decoder.decodeSingularMessageField(value: &self._newPosition) }()
      default: break
      }
    }
  }

  func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if self.guildID != 0 {
      try visitor.visitSingularUInt64Field(value: self.guildID, fieldNumber: 1)
    }
    if self.channelID != 0 {
      try visitor.visitSingularUInt64Field(value: self.channelID, fieldNumber: 2)
    }
    if let v = self._newPosition {
      try visitor.visitSingularMessageField(value: v, fieldNumber: 3)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  static func ==(lhs: Protocol_Chat_V1_UpdateChannelOrderRequest, rhs: Protocol_Chat_V1_UpdateChannelOrderRequest) -> Bool {
    if lhs.guildID != rhs.guildID {return false}
    if lhs.channelID != rhs.channelID {return false}
    if lhs._newPosition != rhs._newPosition {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Protocol_Chat_V1_UpdateChannelOrderResponse: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static let protoMessageName: String = _protobuf_package + ".UpdateChannelOrderResponse"
  static let _protobuf_nameMap = SwiftProtobuf._NameMap()

  mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let _ = try decoder.nextFieldNumber() {
    }
  }

  func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    try unknownFields.traverse(visitor: &visitor)
  }

  static func ==(lhs: Protocol_Chat_V1_UpdateChannelOrderResponse, rhs: Protocol_Chat_V1_UpdateChannelOrderResponse) -> Bool {
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Protocol_Chat_V1_UpdateAllChannelOrderRequest: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static let protoMessageName: String = _protobuf_package + ".UpdateAllChannelOrderRequest"
  static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .standard(proto: "guild_id"),
    2: .standard(proto: "channel_ids"),
  ]

  mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularUInt64Field(value: &self.guildID) }()
      case 2: try { try decoder.decodeRepeatedUInt64Field(value: &self.channelIds) }()
      default: break
      }
    }
  }

  func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if self.guildID != 0 {
      try visitor.visitSingularUInt64Field(value: self.guildID, fieldNumber: 1)
    }
    if !self.channelIds.isEmpty {
      try visitor.visitPackedUInt64Field(value: self.channelIds, fieldNumber: 2)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  static func ==(lhs: Protocol_Chat_V1_UpdateAllChannelOrderRequest, rhs: Protocol_Chat_V1_UpdateAllChannelOrderRequest) -> Bool {
    if lhs.guildID != rhs.guildID {return false}
    if lhs.channelIds != rhs.channelIds {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Protocol_Chat_V1_UpdateAllChannelOrderResponse: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static let protoMessageName: String = _protobuf_package + ".UpdateAllChannelOrderResponse"
  static let _protobuf_nameMap = SwiftProtobuf._NameMap()

  mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let _ = try decoder.nextFieldNumber() {
    }
  }

  func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    try unknownFields.traverse(visitor: &visitor)
  }

  static func ==(lhs: Protocol_Chat_V1_UpdateAllChannelOrderResponse, rhs: Protocol_Chat_V1_UpdateAllChannelOrderResponse) -> Bool {
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Protocol_Chat_V1_DeleteChannelRequest: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static let protoMessageName: String = _protobuf_package + ".DeleteChannelRequest"
  static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .standard(proto: "guild_id"),
    2: .standard(proto: "channel_id"),
  ]

  mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularUInt64Field(value: &self.guildID) }()
      case 2: try { try decoder.decodeSingularUInt64Field(value: &self.channelID) }()
      default: break
      }
    }
  }

  func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if self.guildID != 0 {
      try visitor.visitSingularUInt64Field(value: self.guildID, fieldNumber: 1)
    }
    if self.channelID != 0 {
      try visitor.visitSingularUInt64Field(value: self.channelID, fieldNumber: 2)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  static func ==(lhs: Protocol_Chat_V1_DeleteChannelRequest, rhs: Protocol_Chat_V1_DeleteChannelRequest) -> Bool {
    if lhs.guildID != rhs.guildID {return false}
    if lhs.channelID != rhs.channelID {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Protocol_Chat_V1_DeleteChannelResponse: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static let protoMessageName: String = _protobuf_package + ".DeleteChannelResponse"
  static let _protobuf_nameMap = SwiftProtobuf._NameMap()

  mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let _ = try decoder.nextFieldNumber() {
    }
  }

  func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    try unknownFields.traverse(visitor: &visitor)
  }

  static func ==(lhs: Protocol_Chat_V1_DeleteChannelResponse, rhs: Protocol_Chat_V1_DeleteChannelResponse) -> Bool {
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Protocol_Chat_V1_TypingRequest: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static let protoMessageName: String = _protobuf_package + ".TypingRequest"
  static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .standard(proto: "guild_id"),
    2: .standard(proto: "channel_id"),
  ]

  mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularUInt64Field(value: &self.guildID) }()
      case 2: try { try decoder.decodeSingularUInt64Field(value: &self.channelID) }()
      default: break
      }
    }
  }

  func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if self.guildID != 0 {
      try visitor.visitSingularUInt64Field(value: self.guildID, fieldNumber: 1)
    }
    if self.channelID != 0 {
      try visitor.visitSingularUInt64Field(value: self.channelID, fieldNumber: 2)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  static func ==(lhs: Protocol_Chat_V1_TypingRequest, rhs: Protocol_Chat_V1_TypingRequest) -> Bool {
    if lhs.guildID != rhs.guildID {return false}
    if lhs.channelID != rhs.channelID {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Protocol_Chat_V1_TypingResponse: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static let protoMessageName: String = _protobuf_package + ".TypingResponse"
  static let _protobuf_nameMap = SwiftProtobuf._NameMap()

  mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let _ = try decoder.nextFieldNumber() {
    }
  }

  func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    try unknownFields.traverse(visitor: &visitor)
  }

  static func ==(lhs: Protocol_Chat_V1_TypingResponse, rhs: Protocol_Chat_V1_TypingResponse) -> Bool {
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}
