// DO NOT EDIT.
// swift-format-ignore-file
//
// Generated by the Swift generator plugin for the protocol buffer compiler.
// Source: chat/v1/messages.proto
//
// For information on using the generated types, please see the documentation:
//   https://github.com/apple/swift-protobuf/

import Foundation
import SwiftProtobuf

// If the compiler emits an error on this type, it is because this file
// was generated by a version of the `protoc` Swift plug-in that is
// incompatible with the version of SwiftProtobuf to which you are linking.
// Please ensure that you are building against the same version of the API
// that was used to generate this file.
fileprivate struct _GeneratedWithProtocGenSwiftVersion: SwiftProtobuf.ProtobufAPIVersionCheck {
  struct _2: SwiftProtobuf.ProtobufAPIVersion_2 {}
  typealias Version = _2
}

/// Overrides provide a way to override the name and avatar of a message.
struct Protocol_Chat_V1_Overrides {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  /// the overridden username.
  var username: String {
    get {return _username ?? String()}
    set {_username = newValue}
  }
  /// Returns true if `username` has been explicitly set.
  var hasUsername: Bool {return self._username != nil}
  /// Clears the value of `username`. Subsequent reads from it will return its default value.
  mutating func clearUsername() {self._username = nil}

  /// the overridden avatar.
  var avatar: String {
    get {return _avatar ?? String()}
    set {_avatar = newValue}
  }
  /// Returns true if `avatar` has been explicitly set.
  var hasAvatar: Bool {return self._avatar != nil}
  /// Clears the value of `avatar`. Subsequent reads from it will return its default value.
  mutating func clearAvatar() {self._avatar = nil}

  /// the reason for overriding username and avatar.
  var reason: Protocol_Chat_V1_Overrides.OneOf_Reason? = nil

  /// a custom reason in case the builtin ones don't fit
  var userDefined: String {
    get {
      if case .userDefined(let v)? = reason {return v}
      return String()
    }
    set {reason = .userDefined(newValue)}
  }

  /// the override occured because of a webhook
  var webhook: Protocol_Harmonytypes_V1_Empty {
    get {
      if case .webhook(let v)? = reason {return v}
      return Protocol_Harmonytypes_V1_Empty()
    }
    set {reason = .webhook(newValue)}
  }

  /// plurality, not system as in computer
  var systemPlurality: Protocol_Harmonytypes_V1_Empty {
    get {
      if case .systemPlurality(let v)? = reason {return v}
      return Protocol_Harmonytypes_V1_Empty()
    }
    set {reason = .systemPlurality(newValue)}
  }

  /// the override occured because it was made by the server
  ///
  /// Servers should reject messages sent by users with this override.
  var systemMessage: Protocol_Harmonytypes_V1_Empty {
    get {
      if case .systemMessage(let v)? = reason {return v}
      return Protocol_Harmonytypes_V1_Empty()
    }
    set {reason = .systemMessage(newValue)}
  }

  /// the override occured because of bridging
  var bridge: Protocol_Harmonytypes_V1_Empty {
    get {
      if case .bridge(let v)? = reason {return v}
      return Protocol_Harmonytypes_V1_Empty()
    }
    set {reason = .bridge(newValue)}
  }

  var unknownFields = SwiftProtobuf.UnknownStorage()

  /// the reason for overriding username and avatar.
  enum OneOf_Reason: Equatable {
    /// a custom reason in case the builtin ones don't fit
    case userDefined(String)
    /// the override occured because of a webhook
    case webhook(Protocol_Harmonytypes_V1_Empty)
    /// plurality, not system as in computer
    case systemPlurality(Protocol_Harmonytypes_V1_Empty)
    /// the override occured because it was made by the server
    ///
    /// Servers should reject messages sent by users with this override.
    case systemMessage(Protocol_Harmonytypes_V1_Empty)
    /// the override occured because of bridging
    case bridge(Protocol_Harmonytypes_V1_Empty)

  #if !swift(>=4.1)
    static func ==(lhs: Protocol_Chat_V1_Overrides.OneOf_Reason, rhs: Protocol_Chat_V1_Overrides.OneOf_Reason) -> Bool {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch (lhs, rhs) {
      case (.userDefined, .userDefined): return {
        guard case .userDefined(let l) = lhs, case .userDefined(let r) = rhs else { preconditionFailure() }
        return l == r
      }()
      case (.webhook, .webhook): return {
        guard case .webhook(let l) = lhs, case .webhook(let r) = rhs else { preconditionFailure() }
        return l == r
      }()
      case (.systemPlurality, .systemPlurality): return {
        guard case .systemPlurality(let l) = lhs, case .systemPlurality(let r) = rhs else { preconditionFailure() }
        return l == r
      }()
      case (.systemMessage, .systemMessage): return {
        guard case .systemMessage(let l) = lhs, case .systemMessage(let r) = rhs else { preconditionFailure() }
        return l == r
      }()
      case (.bridge, .bridge): return {
        guard case .bridge(let l) = lhs, case .bridge(let r) = rhs else { preconditionFailure() }
        return l == r
      }()
      default: return false
      }
    }
  #endif
  }

  init() {}

  fileprivate var _username: String? = nil
  fileprivate var _avatar: String? = nil
}

/// The payload sent to the bot when an action is triggered.
struct Protocol_Chat_V1_ActionPayload {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  /// The payload data
  var payload: Protocol_Chat_V1_ActionPayload.OneOf_Payload? = nil

  /// Payload for a button
  var button: Protocol_Chat_V1_ActionPayload.Button {
    get {
      if case .button(let v)? = payload {return v}
      return Protocol_Chat_V1_ActionPayload.Button()
    }
    set {payload = .button(newValue)}
  }

  /// Payload for a dropdown
  var dropdown: Protocol_Chat_V1_ActionPayload.Dropdown {
    get {
      if case .dropdown(let v)? = payload {return v}
      return Protocol_Chat_V1_ActionPayload.Dropdown()
    }
    set {payload = .dropdown(newValue)}
  }

  /// Payload for a text input
  var input: Protocol_Chat_V1_ActionPayload.Input {
    get {
      if case .input(let v)? = payload {return v}
      return Protocol_Chat_V1_ActionPayload.Input()
    }
    set {payload = .input(newValue)}
  }

  var unknownFields = SwiftProtobuf.UnknownStorage()

  /// The payload data
  enum OneOf_Payload: Equatable {
    /// Payload for a button
    case button(Protocol_Chat_V1_ActionPayload.Button)
    /// Payload for a dropdown
    case dropdown(Protocol_Chat_V1_ActionPayload.Dropdown)
    /// Payload for a text input
    case input(Protocol_Chat_V1_ActionPayload.Input)

  #if !swift(>=4.1)
    static func ==(lhs: Protocol_Chat_V1_ActionPayload.OneOf_Payload, rhs: Protocol_Chat_V1_ActionPayload.OneOf_Payload) -> Bool {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch (lhs, rhs) {
      case (.button, .button): return {
        guard case .button(let l) = lhs, case .button(let r) = rhs else { preconditionFailure() }
        return l == r
      }()
      case (.dropdown, .dropdown): return {
        guard case .dropdown(let l) = lhs, case .dropdown(let r) = rhs else { preconditionFailure() }
        return l == r
      }()
      case (.input, .input): return {
        guard case .input(let l) = lhs, case .input(let r) = rhs else { preconditionFailure() }
        return l == r
      }()
      default: return false
      }
    }
  #endif
  }

  /// The payload data for a button action
  struct Button {
    // SwiftProtobuf.Message conformance is added in an extension below. See the
    // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
    // methods supported on all messages.

    /// The data from the Button action
    var data: Data = Data()

    var unknownFields = SwiftProtobuf.UnknownStorage()

    init() {}
  }

  /// The payload for a dropdown action
  struct Dropdown {
    // SwiftProtobuf.Message conformance is added in an extension below. See the
    // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
    // methods supported on all messages.

    /// The user choice from the dropdown.
    var choice: Data = Data()

    var unknownFields = SwiftProtobuf.UnknownStorage()

    init() {}
  }

  /// The payload for a text input action
  struct Input {
    // SwiftProtobuf.Message conformance is added in an extension below. See the
    // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
    // methods supported on all messages.

    /// The user input.
    var input: String = String()

    /// The bot-provided data
    var data: Data = Data()

    var unknownFields = SwiftProtobuf.UnknownStorage()

    init() {}
  }

  init() {}
}

/// Actions are interactive elements that can exist within an embed.
struct Protocol_Chat_V1_Action {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  /// Type of the action.
  var actionType: Protocol_Chat_V1_Action.TypeEnum = .normalUnspecified

  /// The kind of the action.
  var kind: Protocol_Chat_V1_Action.OneOf_Kind? = nil

  /// Button action.
  var button: Protocol_Chat_V1_Action.Button {
    get {
      if case .button(let v)? = kind {return v}
      return Protocol_Chat_V1_Action.Button()
    }
    set {kind = .button(newValue)}
  }

  /// Dropdown action.
  var dropdown: Protocol_Chat_V1_Action.Dropdown {
    get {
      if case .dropdown(let v)? = kind {return v}
      return Protocol_Chat_V1_Action.Dropdown()
    }
    set {kind = .dropdown(newValue)}
  }

  /// Input action.
  var input: Protocol_Chat_V1_Action.Input {
    get {
      if case .input(let v)? = kind {return v}
      return Protocol_Chat_V1_Action.Input()
    }
    set {kind = .input(newValue)}
  }

  var unknownFields = SwiftProtobuf.UnknownStorage()

  /// The kind of the action.
  enum OneOf_Kind: Equatable {
    /// Button action.
    case button(Protocol_Chat_V1_Action.Button)
    /// Dropdown action.
    case dropdown(Protocol_Chat_V1_Action.Dropdown)
    /// Input action.
    case input(Protocol_Chat_V1_Action.Input)

  #if !swift(>=4.1)
    static func ==(lhs: Protocol_Chat_V1_Action.OneOf_Kind, rhs: Protocol_Chat_V1_Action.OneOf_Kind) -> Bool {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch (lhs, rhs) {
      case (.button, .button): return {
        guard case .button(let l) = lhs, case .button(let r) = rhs else { preconditionFailure() }
        return l == r
      }()
      case (.dropdown, .dropdown): return {
        guard case .dropdown(let l) = lhs, case .dropdown(let r) = rhs else { preconditionFailure() }
        return l == r
      }()
      case (.input, .input): return {
        guard case .input(let l) = lhs, case .input(let r) = rhs else { preconditionFailure() }
        return l == r
      }()
      default: return false
      }
    }
  #endif
  }

  /// The action type. This is primarily used to change the look of the action to
  /// the user (example: Destructive actions will have a red background).
  enum TypeEnum: SwiftProtobuf.Enum {
    typealias RawValue = Int

    /// a normal action.
    case normalUnspecified // = 0

    /// a primary action.
    case primary // = 1

    /// A destructive / dangerous action.
    case destructive // = 2
    case UNRECOGNIZED(Int)

    init() {
      self = .normalUnspecified
    }

    init?(rawValue: Int) {
      switch rawValue {
      case 0: self = .normalUnspecified
      case 1: self = .primary
      case 2: self = .destructive
      default: self = .UNRECOGNIZED(rawValue)
      }
    }

    var rawValue: Int {
      switch self {
      case .normalUnspecified: return 0
      case .primary: return 1
      case .destructive: return 2
      case .UNRECOGNIZED(let i): return i
      }
    }

  }

  /// A button that users can click on to trigger an action.
  struct Button {
    // SwiftProtobuf.Message conformance is added in an extension below. See the
    // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
    // methods supported on all messages.

    /// The text to show on the button.
    var text: String = String()

    /// Action data, which should be used in the call to perform the action.
    var data: Data = Data()

    /// An external URL that the button links to.
    /// This makes it so that tapping this button will open said URL instead
    /// of triggering the action.
    var url: String {
      get {return _url ?? String()}
      set {_url = newValue}
    }
    /// Returns true if `url` has been explicitly set.
    var hasURL: Bool {return self._url != nil}
    /// Clears the value of `url`. Subsequent reads from it will return its default value.
    mutating func clearURL() {self._url = nil}

    var unknownFields = SwiftProtobuf.UnknownStorage()

    init() {}

    fileprivate var _url: String? = nil
  }

  /// A dropdown menu that users can click on to trigger an action.
  struct Dropdown {
    // SwiftProtobuf.Message conformance is added in an extension below. See the
    // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
    // methods supported on all messages.

    /// The text describing the dropdown.
    var label: String = String()

    /// The options in the dropdown.
    var entries: [Protocol_Chat_V1_Action.Dropdown.Entry] = []

    var unknownFields = SwiftProtobuf.UnknownStorage()

    /// An entry in the dropdown
    struct Entry {
      // SwiftProtobuf.Message conformance is added in an extension below. See the
      // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
      // methods supported on all messages.

      /// The dropdown's UI label.
      var label: String = String()

      /// The dropdown's associated data.
      var data: Data = Data()

      var unknownFields = SwiftProtobuf.UnknownStorage()

      init() {}
    }

    init() {}
  }

  /// A text input that users can type in to trigger an action.
  struct Input {
    // SwiftProtobuf.Message conformance is added in an extension below. See the
    // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
    // methods supported on all messages.

    /// The label describing the input.
    var label: String = String()

    /// Whether this text input should be a multiline one or not.
    var multiline: Bool = false

    /// Contextual data allowing the bot to discern what the user input is for
    var data: Data = Data()

    var unknownFields = SwiftProtobuf.UnknownStorage()

    init() {}
  }

  init() {}
}

#if swift(>=4.2)

extension Protocol_Chat_V1_Action.TypeEnum: CaseIterable {
  // The compiler won't synthesize support with the UNRECOGNIZED case.
  static var allCases: [Protocol_Chat_V1_Action.TypeEnum] = [
    .normalUnspecified,
    .primary,
    .destructive,
  ]
}

#endif  // swift(>=4.2)

/// Object representing a message embed.
struct Protocol_Chat_V1_Embed {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  /// Title of this embed.
  var title: String = String()

  /// Body text of this embed.
  var body: Protocol_Chat_V1_FormattedText {
    get {return _body ?? Protocol_Chat_V1_FormattedText()}
    set {_body = newValue}
  }
  /// Returns true if `body` has been explicitly set.
  var hasBody: Bool {return self._body != nil}
  /// Clears the value of `body`. Subsequent reads from it will return its default value.
  mutating func clearBody() {self._body = nil}

  /// Color of this embed.
  var color: Int32 {
    get {return _color ?? 0}
    set {_color = newValue}
  }
  /// Returns true if `color` has been explicitly set.
  var hasColor: Bool {return self._color != nil}
  /// Clears the value of `color`. Subsequent reads from it will return its default value.
  mutating func clearColor() {self._color = nil}

  /// Embed heading for the header.
  var header: Protocol_Chat_V1_Embed.EmbedHeading {
    get {return _header ?? Protocol_Chat_V1_Embed.EmbedHeading()}
    set {_header = newValue}
  }
  /// Returns true if `header` has been explicitly set.
  var hasHeader: Bool {return self._header != nil}
  /// Clears the value of `header`. Subsequent reads from it will return its default value.
  mutating func clearHeader() {self._header = nil}

  /// Embed heading for the footer.
  var footer: Protocol_Chat_V1_Embed.EmbedHeading {
    get {return _footer ?? Protocol_Chat_V1_Embed.EmbedHeading()}
    set {_footer = newValue}
  }
  /// Returns true if `footer` has been explicitly set.
  var hasFooter: Bool {return self._footer != nil}
  /// Clears the value of `footer`. Subsequent reads from it will return its default value.
  mutating func clearFooter() {self._footer = nil}

  /// Fields of this embed.
  var fields: [Protocol_Chat_V1_Embed.EmbedField] = []

  var unknownFields = SwiftProtobuf.UnknownStorage()

  /// Object representing an embed heading.
  struct EmbedHeading {
    // SwiftProtobuf.Message conformance is added in an extension below. See the
    // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
    // methods supported on all messages.

    /// Text of the heading.
    var text: String = String()

    /// Subtext of the heading.
    var subtext: String {
      get {return _subtext ?? String()}
      set {_subtext = newValue}
    }
    /// Returns true if `subtext` has been explicitly set.
    var hasSubtext: Bool {return self._subtext != nil}
    /// Clears the value of `subtext`. Subsequent reads from it will return its default value.
    mutating func clearSubtext() {self._subtext = nil}

    /// URL of the heading.
    var url: String {
      get {return _url ?? String()}
      set {_url = newValue}
    }
    /// Returns true if `url` has been explicitly set.
    var hasURL: Bool {return self._url != nil}
    /// Clears the value of `url`. Subsequent reads from it will return its default value.
    mutating func clearURL() {self._url = nil}

    /// Icon of the heading.
    var icon: String {
      get {return _icon ?? String()}
      set {_icon = newValue}
    }
    /// Returns true if `icon` has been explicitly set.
    var hasIcon: Bool {return self._icon != nil}
    /// Clears the value of `icon`. Subsequent reads from it will return its default value.
    mutating func clearIcon() {self._icon = nil}

    var unknownFields = SwiftProtobuf.UnknownStorage()

    init() {}

    fileprivate var _subtext: String? = nil
    fileprivate var _url: String? = nil
    fileprivate var _icon: String? = nil
  }

  /// Object representing an embed field.
  struct EmbedField {
    // SwiftProtobuf.Message conformance is added in an extension below. See the
    // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
    // methods supported on all messages.

    /// Title of this field.
    var title: String = String()

    /// Subtitle of this field.
    var subtitle: String {
      get {return _subtitle ?? String()}
      set {_subtitle = newValue}
    }
    /// Returns true if `subtitle` has been explicitly set.
    var hasSubtitle: Bool {return self._subtitle != nil}
    /// Clears the value of `subtitle`. Subsequent reads from it will return its default value.
    mutating func clearSubtitle() {self._subtitle = nil}

    /// Body text of this field (eg. a description).
    var body: Protocol_Chat_V1_FormattedText {
      get {return _body ?? Protocol_Chat_V1_FormattedText()}
      set {_body = newValue}
    }
    /// Returns true if `body` has been explicitly set.
    var hasBody: Bool {return self._body != nil}
    /// Clears the value of `body`. Subsequent reads from it will return its default value.
    mutating func clearBody() {self._body = nil}

    /// Image URL of this field.
    var imageURL: String {
      get {return _imageURL ?? String()}
      set {_imageURL = newValue}
    }
    /// Returns true if `imageURL` has been explicitly set.
    var hasImageURL: Bool {return self._imageURL != nil}
    /// Clears the value of `imageURL`. Subsequent reads from it will return its default value.
    mutating func clearImageURL() {self._imageURL = nil}

    /// How to present this field.
    var presentation: Protocol_Chat_V1_Embed.EmbedField.Presentation = .dataUnspecified

    /// Actions of this field.
    var actions: [Protocol_Chat_V1_Action] = []

    var unknownFields = SwiftProtobuf.UnknownStorage()

    /// Type representing how to present an embed field.
    enum Presentation: SwiftProtobuf.Enum {
      typealias RawValue = Int

      /// Show the field as data.
      case dataUnspecified // = 0

      /// Show the field as a captioned image.
      case captionedImage // = 1

      /// Show the field as a row.
      case row // = 2
      case UNRECOGNIZED(Int)

      init() {
        self = .dataUnspecified
      }

      init?(rawValue: Int) {
        switch rawValue {
        case 0: self = .dataUnspecified
        case 1: self = .captionedImage
        case 2: self = .row
        default: self = .UNRECOGNIZED(rawValue)
        }
      }

      var rawValue: Int {
        switch self {
        case .dataUnspecified: return 0
        case .captionedImage: return 1
        case .row: return 2
        case .UNRECOGNIZED(let i): return i
        }
      }

    }

    init() {}

    fileprivate var _subtitle: String? = nil
    fileprivate var _body: Protocol_Chat_V1_FormattedText? = nil
    fileprivate var _imageURL: String? = nil
  }

  init() {}

  fileprivate var _body: Protocol_Chat_V1_FormattedText? = nil
  fileprivate var _color: Int32? = nil
  fileprivate var _header: Protocol_Chat_V1_Embed.EmbedHeading? = nil
  fileprivate var _footer: Protocol_Chat_V1_Embed.EmbedHeading? = nil
}

#if swift(>=4.2)

extension Protocol_Chat_V1_Embed.EmbedField.Presentation: CaseIterable {
  // The compiler won't synthesize support with the UNRECOGNIZED case.
  static var allCases: [Protocol_Chat_V1_Embed.EmbedField.Presentation] = [
    .dataUnspecified,
    .captionedImage,
    .row,
  ]
}

#endif  // swift(>=4.2)

///
///Minithumbnail is an extremely low-quality JPEG thumbnail.
///
///The resolution is usually no larger than 64x64.
struct Protocol_Chat_V1_Minithumbnail {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  /// The width of the minithumbnail
  var width: UInt32 = 0

  /// The height of the minithumbnail
  var height: UInt32 = 0

  /// The JPEG data of the minithumbnail
  var data: Data = Data()

  var unknownFields = SwiftProtobuf.UnknownStorage()

  init() {}
}

///
///Photo contains data about a photo.
///
///Photo are always JPEG, and are
///constrained to the following rules:
///
///- width+height <= 10_000
///- width <= height*20
///- height <= width*20
///
///Photos are preferably no more than 10MB
///in size, and servers may compress as necessary.
struct Protocol_Chat_V1_Photo {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  /// The HMC URL of the photo.
  var hmc: String = String()

  /// The filename of the photo.
  var name: String = String()

  /// The size of the photo.
  var fileSize: UInt32 = 0

  /// The height of the photo, in pixels.
  var height: UInt32 = 0

  /// The width of the photo, in pixels.
  var width: UInt32 = 0

  /// The photo's caption.
  var caption: Protocol_Chat_V1_FormattedText {
    get {return _caption ?? Protocol_Chat_V1_FormattedText()}
    set {_caption = newValue}
  }
  /// Returns true if `caption` has been explicitly set.
  var hasCaption: Bool {return self._caption != nil}
  /// Clears the value of `caption`. Subsequent reads from it will return its default value.
  mutating func clearCaption() {self._caption = nil}

  /// A thumbnail representing the photo.
  var minithumbnail: Protocol_Chat_V1_Minithumbnail {
    get {return _minithumbnail ?? Protocol_Chat_V1_Minithumbnail()}
    set {_minithumbnail = newValue}
  }
  /// Returns true if `minithumbnail` has been explicitly set.
  var hasMinithumbnail: Bool {return self._minithumbnail != nil}
  /// Clears the value of `minithumbnail`. Subsequent reads from it will return its default value.
  mutating func clearMinithumbnail() {self._minithumbnail = nil}

  var unknownFields = SwiftProtobuf.UnknownStorage()

  init() {}

  fileprivate var _caption: Protocol_Chat_V1_FormattedText? = nil
  fileprivate var _minithumbnail: Protocol_Chat_V1_Minithumbnail? = nil
}

/// Object representing a generic message attachment.
struct Protocol_Chat_V1_Attachment {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  /// File ID of this attachment.
  var id: String = String()

  /// Filename of this attachment.
  var name: String = String()

  /// Mimetype of this attachment.
  var mimetype: String = String()

  /// Size of this attachment.
  var size: UInt32 = 0

  /// Caption of this attachment.
  var caption: Protocol_Chat_V1_FormattedText {
    get {return _caption ?? Protocol_Chat_V1_FormattedText()}
    set {_caption = newValue}
  }
  /// Returns true if `caption` has been explicitly set.
  var hasCaption: Bool {return self._caption != nil}
  /// Clears the value of `caption`. Subsequent reads from it will return its default value.
  mutating func clearCaption() {self._caption = nil}

  var unknownFields = SwiftProtobuf.UnknownStorage()

  init() {}

  fileprivate var _caption: Protocol_Chat_V1_FormattedText? = nil
}

/// Object representing a message's content.
struct Protocol_Chat_V1_Content {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  /// Content data.
  var content: Protocol_Chat_V1_Content.OneOf_Content? = nil

  /// Text content.
  var textMessage: Protocol_Chat_V1_Content.TextContent {
    get {
      if case .textMessage(let v)? = content {return v}
      return Protocol_Chat_V1_Content.TextContent()
    }
    set {content = .textMessage(newValue)}
  }

  /// Embed content.
  var embedMessage: Protocol_Chat_V1_Content.EmbedContent {
    get {
      if case .embedMessage(let v)? = content {return v}
      return Protocol_Chat_V1_Content.EmbedContent()
    }
    set {content = .embedMessage(newValue)}
  }

  /// Attachment content.
  var attachmentMessage: Protocol_Chat_V1_Content.AttachmentContent {
    get {
      if case .attachmentMessage(let v)? = content {return v}
      return Protocol_Chat_V1_Content.AttachmentContent()
    }
    set {content = .attachmentMessage(newValue)}
  }

  /// Photo content.
  var photoMessage: Protocol_Chat_V1_Content.PhotoContent {
    get {
      if case .photoMessage(let v)? = content {return v}
      return Protocol_Chat_V1_Content.PhotoContent()
    }
    set {content = .photoMessage(newValue)}
  }

  /// A user rejected an invite.
  var inviteRejected: Protocol_Chat_V1_Content.InviteRejected {
    get {
      if case .inviteRejected(let v)? = content {return v}
      return Protocol_Chat_V1_Content.InviteRejected()
    }
    set {content = .inviteRejected(newValue)}
  }

  /// A user accepted an invite.
  var inviteAccepted: Protocol_Chat_V1_Content.InviteAccepted {
    get {
      if case .inviteAccepted(let v)? = content {return v}
      return Protocol_Chat_V1_Content.InviteAccepted()
    }
    set {content = .inviteAccepted(newValue)}
  }

  /// A user upgraded a guild from "room" to "normal".
  var roomUpgradedToGuild: Protocol_Chat_V1_Content.RoomUpgradedToGuild {
    get {
      if case .roomUpgradedToGuild(let v)? = content {return v}
      return Protocol_Chat_V1_Content.RoomUpgradedToGuild()
    }
    set {content = .roomUpgradedToGuild(newValue)}
  }

  var unknownFields = SwiftProtobuf.UnknownStorage()

  /// Content data.
  enum OneOf_Content: Equatable {
    /// Text content.
    case textMessage(Protocol_Chat_V1_Content.TextContent)
    /// Embed content.
    case embedMessage(Protocol_Chat_V1_Content.EmbedContent)
    /// Attachment content.
    case attachmentMessage(Protocol_Chat_V1_Content.AttachmentContent)
    /// Photo content.
    case photoMessage(Protocol_Chat_V1_Content.PhotoContent)
    /// A user rejected an invite.
    case inviteRejected(Protocol_Chat_V1_Content.InviteRejected)
    /// A user accepted an invite.
    case inviteAccepted(Protocol_Chat_V1_Content.InviteAccepted)
    /// A user upgraded a guild from "room" to "normal".
    case roomUpgradedToGuild(Protocol_Chat_V1_Content.RoomUpgradedToGuild)

  #if !swift(>=4.1)
    static func ==(lhs: Protocol_Chat_V1_Content.OneOf_Content, rhs: Protocol_Chat_V1_Content.OneOf_Content) -> Bool {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch (lhs, rhs) {
      case (.textMessage, .textMessage): return {
        guard case .textMessage(let l) = lhs, case .textMessage(let r) = rhs else { preconditionFailure() }
        return l == r
      }()
      case (.embedMessage, .embedMessage): return {
        guard case .embedMessage(let l) = lhs, case .embedMessage(let r) = rhs else { preconditionFailure() }
        return l == r
      }()
      case (.attachmentMessage, .attachmentMessage): return {
        guard case .attachmentMessage(let l) = lhs, case .attachmentMessage(let r) = rhs else { preconditionFailure() }
        return l == r
      }()
      case (.photoMessage, .photoMessage): return {
        guard case .photoMessage(let l) = lhs, case .photoMessage(let r) = rhs else { preconditionFailure() }
        return l == r
      }()
      case (.inviteRejected, .inviteRejected): return {
        guard case .inviteRejected(let l) = lhs, case .inviteRejected(let r) = rhs else { preconditionFailure() }
        return l == r
      }()
      case (.inviteAccepted, .inviteAccepted): return {
        guard case .inviteAccepted(let l) = lhs, case .inviteAccepted(let r) = rhs else { preconditionFailure() }
        return l == r
      }()
      case (.roomUpgradedToGuild, .roomUpgradedToGuild): return {
        guard case .roomUpgradedToGuild(let l) = lhs, case .roomUpgradedToGuild(let r) = rhs else { preconditionFailure() }
        return l == r
      }()
      default: return false
      }
    }
  #endif
  }

  /// Object representing text content.
  struct TextContent {
    // SwiftProtobuf.Message conformance is added in an extension below. See the
    // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
    // methods supported on all messages.

    /// Text content.
    var content: Protocol_Chat_V1_FormattedText {
      get {return _content ?? Protocol_Chat_V1_FormattedText()}
      set {_content = newValue}
    }
    /// Returns true if `content` has been explicitly set.
    var hasContent: Bool {return self._content != nil}
    /// Clears the value of `content`. Subsequent reads from it will return its default value.
    mutating func clearContent() {self._content = nil}

    var unknownFields = SwiftProtobuf.UnknownStorage()

    init() {}

    fileprivate var _content: Protocol_Chat_V1_FormattedText? = nil
  }

  /// Object representing embed content.
  struct EmbedContent {
    // SwiftProtobuf.Message conformance is added in an extension below. See the
    // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
    // methods supported on all messages.

    /// Embed content.
    var embeds: [Protocol_Chat_V1_Embed] = []

    var unknownFields = SwiftProtobuf.UnknownStorage()

    init() {}
  }

  /// Object representing attachment content.
  struct AttachmentContent {
    // SwiftProtobuf.Message conformance is added in an extension below. See the
    // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
    // methods supported on all messages.

    /// A list of attachments.
    var files: [Protocol_Chat_V1_Attachment] = []

    var unknownFields = SwiftProtobuf.UnknownStorage()

    init() {}
  }

  /// Object representing photo content.
  struct PhotoContent {
    // SwiftProtobuf.Message conformance is added in an extension below. See the
    // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
    // methods supported on all messages.

    /// A list of photos.
    var photos: [Protocol_Chat_V1_Photo] = []

    var unknownFields = SwiftProtobuf.UnknownStorage()

    init() {}
  }

  /// Represents a user rejecting an invite.
  ///
  /// This can only be used by servers themselves. Servers should reject
  /// messages with this content if they are sent by a user.
  struct InviteRejected {
    // SwiftProtobuf.Message conformance is added in an extension below. See the
    // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
    // methods supported on all messages.

    /// User ID of the invitee.
    var inviteeID: UInt64 = 0

    /// User ID of the inviter.
    var inviterID: UInt64 = 0

    var unknownFields = SwiftProtobuf.UnknownStorage()

    init() {}
  }

  /// Represents a user accepting an invite.
  ///
  /// This can only be used by servers themselves. Servers should reject
  /// messages with this content if they are sent by a user.
  struct InviteAccepted {
    // SwiftProtobuf.Message conformance is added in an extension below. See the
    // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
    // methods supported on all messages.

    /// User ID of the invitee.
    var inviteeID: UInt64 = 0

    /// User ID of the inviter.
    var inviterID: UInt64 = 0

    var unknownFields = SwiftProtobuf.UnknownStorage()

    init() {}
  }

  /// Represents a guild upgrade from "room" to "normal".
  ///
  /// This can only be used by servers themselves. Servers should reject
  /// messages with this content if they are sent by a user.
  struct RoomUpgradedToGuild {
    // SwiftProtobuf.Message conformance is added in an extension below. See the
    // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
    // methods supported on all messages.

    /// User ID of the user that upgraded the guild.
    var upgradedBy: UInt64 = 0

    var unknownFields = SwiftProtobuf.UnknownStorage()

    init() {}
  }

  init() {}
}

/// Object representing a reaction.
struct Protocol_Chat_V1_Reaction {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  /// Emote data for this reaction.
  ///
  /// Emote's image ID is used as an identifier for unique reactions.
  /// Emotes with the same names should be "deduplicated" by a client, by suffixing
  /// their names with `~1`, `~2` and so on.
  var emote: Protocol_Emote_V1_Emote {
    get {return _emote ?? Protocol_Emote_V1_Emote()}
    set {_emote = newValue}
  }
  /// Returns true if `emote` has been explicitly set.
  var hasEmote: Bool {return self._emote != nil}
  /// Clears the value of `emote`. Subsequent reads from it will return its default value.
  mutating func clearEmote() {self._emote = nil}

  /// How many reactions this reaction has.
  var count: UInt32 = 0

  var unknownFields = SwiftProtobuf.UnknownStorage()

  init() {}

  fileprivate var _emote: Protocol_Emote_V1_Emote? = nil
}

/// A format for text
struct Protocol_Chat_V1_Format {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  /// where the format begins to apply to
  var start: UInt32 = 0

  /// how many characters the format is
  var length: UInt32 = 0

  /// the style if format to apply to this text
  var format: Protocol_Chat_V1_Format.OneOf_Format? = nil

  /// a text format for bold text
  var bold: Protocol_Chat_V1_Format.Bold {
    get {
      if case .bold(let v)? = format {return v}
      return Protocol_Chat_V1_Format.Bold()
    }
    set {format = .bold(newValue)}
  }

  /// a text format for italic text
  var italic: Protocol_Chat_V1_Format.Italic {
    get {
      if case .italic(let v)? = format {return v}
      return Protocol_Chat_V1_Format.Italic()
    }
    set {format = .italic(newValue)}
  }

  /// a text format for underline text
  var underline: Protocol_Chat_V1_Format.Underline {
    get {
      if case .underline(let v)? = format {return v}
      return Protocol_Chat_V1_Format.Underline()
    }
    set {format = .underline(newValue)}
  }

  /// a text format for monospace text
  var monospace: Protocol_Chat_V1_Format.Monospace {
    get {
      if case .monospace(let v)? = format {return v}
      return Protocol_Chat_V1_Format.Monospace()
    }
    set {format = .monospace(newValue)}
  }

  /// a text format for superscript text
  var superscript: Protocol_Chat_V1_Format.Superscript {
    get {
      if case .superscript(let v)? = format {return v}
      return Protocol_Chat_V1_Format.Superscript()
    }
    set {format = .superscript(newValue)}
  }

  /// a text format for subscript text
  var `subscript`: Protocol_Chat_V1_Format.Subscript {
    get {
      if case .subscript(let v)? = format {return v}
      return Protocol_Chat_V1_Format.Subscript()
    }
    set {format = .subscript(newValue)}
  }

  /// a text format for a codeblock
  var codeBlock: Protocol_Chat_V1_Format.CodeBlock {
    get {
      if case .codeBlock(let v)? = format {return v}
      return Protocol_Chat_V1_Format.CodeBlock()
    }
    set {format = .codeBlock(newValue)}
  }

  /// a text format for a user mention
  var userMention: Protocol_Chat_V1_Format.UserMention {
    get {
      if case .userMention(let v)? = format {return v}
      return Protocol_Chat_V1_Format.UserMention()
    }
    set {format = .userMention(newValue)}
  }

  /// a text format for a role mention
  var roleMention: Protocol_Chat_V1_Format.RoleMention {
    get {
      if case .roleMention(let v)? = format {return v}
      return Protocol_Chat_V1_Format.RoleMention()
    }
    set {format = .roleMention(newValue)}
  }

  /// a text format for a channel mention
  var channelMention: Protocol_Chat_V1_Format.ChannelMention {
    get {
      if case .channelMention(let v)? = format {return v}
      return Protocol_Chat_V1_Format.ChannelMention()
    }
    set {format = .channelMention(newValue)}
  }

  /// a text format for a guild mention
  var guildMention: Protocol_Chat_V1_Format.GuildMention {
    get {
      if case .guildMention(let v)? = format {return v}
      return Protocol_Chat_V1_Format.GuildMention()
    }
    set {format = .guildMention(newValue)}
  }

  /// a text format for an emoji
  var emoji: Protocol_Chat_V1_Format.Emoji {
    get {
      if case .emoji(let v)? = format {return v}
      return Protocol_Chat_V1_Format.Emoji()
    }
    set {format = .emoji(newValue)}
  }

  /// a text format for coloured text
  var color: Protocol_Chat_V1_Format.Color {
    get {
      if case .color(let v)? = format {return v}
      return Protocol_Chat_V1_Format.Color()
    }
    set {format = .color(newValue)}
  }

  /// a text format for localization
  var localization: Protocol_Chat_V1_Format.Localization {
    get {
      if case .localization(let v)? = format {return v}
      return Protocol_Chat_V1_Format.Localization()
    }
    set {format = .localization(newValue)}
  }

  var unknownFields = SwiftProtobuf.UnknownStorage()

  /// the style if format to apply to this text
  enum OneOf_Format: Equatable {
    /// a text format for bold text
    case bold(Protocol_Chat_V1_Format.Bold)
    /// a text format for italic text
    case italic(Protocol_Chat_V1_Format.Italic)
    /// a text format for underline text
    case underline(Protocol_Chat_V1_Format.Underline)
    /// a text format for monospace text
    case monospace(Protocol_Chat_V1_Format.Monospace)
    /// a text format for superscript text
    case superscript(Protocol_Chat_V1_Format.Superscript)
    /// a text format for subscript text
    case `subscript`(Protocol_Chat_V1_Format.Subscript)
    /// a text format for a codeblock
    case codeBlock(Protocol_Chat_V1_Format.CodeBlock)
    /// a text format for a user mention
    case userMention(Protocol_Chat_V1_Format.UserMention)
    /// a text format for a role mention
    case roleMention(Protocol_Chat_V1_Format.RoleMention)
    /// a text format for a channel mention
    case channelMention(Protocol_Chat_V1_Format.ChannelMention)
    /// a text format for a guild mention
    case guildMention(Protocol_Chat_V1_Format.GuildMention)
    /// a text format for an emoji
    case emoji(Protocol_Chat_V1_Format.Emoji)
    /// a text format for coloured text
    case color(Protocol_Chat_V1_Format.Color)
    /// a text format for localization
    case localization(Protocol_Chat_V1_Format.Localization)

  #if !swift(>=4.1)
    static func ==(lhs: Protocol_Chat_V1_Format.OneOf_Format, rhs: Protocol_Chat_V1_Format.OneOf_Format) -> Bool {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch (lhs, rhs) {
      case (.bold, .bold): return {
        guard case .bold(let l) = lhs, case .bold(let r) = rhs else { preconditionFailure() }
        return l == r
      }()
      case (.italic, .italic): return {
        guard case .italic(let l) = lhs, case .italic(let r) = rhs else { preconditionFailure() }
        return l == r
      }()
      case (.underline, .underline): return {
        guard case .underline(let l) = lhs, case .underline(let r) = rhs else { preconditionFailure() }
        return l == r
      }()
      case (.monospace, .monospace): return {
        guard case .monospace(let l) = lhs, case .monospace(let r) = rhs else { preconditionFailure() }
        return l == r
      }()
      case (.superscript, .superscript): return {
        guard case .superscript(let l) = lhs, case .superscript(let r) = rhs else { preconditionFailure() }
        return l == r
      }()
      case (.subscript, .subscript): return {
        guard case .subscript(let l) = lhs, case .subscript(let r) = rhs else { preconditionFailure() }
        return l == r
      }()
      case (.codeBlock, .codeBlock): return {
        guard case .codeBlock(let l) = lhs, case .codeBlock(let r) = rhs else { preconditionFailure() }
        return l == r
      }()
      case (.userMention, .userMention): return {
        guard case .userMention(let l) = lhs, case .userMention(let r) = rhs else { preconditionFailure() }
        return l == r
      }()
      case (.roleMention, .roleMention): return {
        guard case .roleMention(let l) = lhs, case .roleMention(let r) = rhs else { preconditionFailure() }
        return l == r
      }()
      case (.channelMention, .channelMention): return {
        guard case .channelMention(let l) = lhs, case .channelMention(let r) = rhs else { preconditionFailure() }
        return l == r
      }()
      case (.guildMention, .guildMention): return {
        guard case .guildMention(let l) = lhs, case .guildMention(let r) = rhs else { preconditionFailure() }
        return l == r
      }()
      case (.emoji, .emoji): return {
        guard case .emoji(let l) = lhs, case .emoji(let r) = rhs else { preconditionFailure() }
        return l == r
      }()
      case (.color, .color): return {
        guard case .color(let l) = lhs, case .color(let r) = rhs else { preconditionFailure() }
        return l == r
      }()
      case (.localization, .localization): return {
        guard case .localization(let l) = lhs, case .localization(let r) = rhs else { preconditionFailure() }
        return l == r
      }()
      default: return false
      }
    }
  #endif
  }

  /// Bold text
  struct Bold {
    // SwiftProtobuf.Message conformance is added in an extension below. See the
    // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
    // methods supported on all messages.

    var unknownFields = SwiftProtobuf.UnknownStorage()

    init() {}
  }

  /// Italic text
  struct Italic {
    // SwiftProtobuf.Message conformance is added in an extension below. See the
    // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
    // methods supported on all messages.

    var unknownFields = SwiftProtobuf.UnknownStorage()

    init() {}
  }

  /// Underlined text
  struct Underline {
    // SwiftProtobuf.Message conformance is added in an extension below. See the
    // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
    // methods supported on all messages.

    var unknownFields = SwiftProtobuf.UnknownStorage()

    init() {}
  }

  /// Monospace text
  struct Monospace {
    // SwiftProtobuf.Message conformance is added in an extension below. See the
    // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
    // methods supported on all messages.

    var unknownFields = SwiftProtobuf.UnknownStorage()

    init() {}
  }

  /// Superscript text
  struct Superscript {
    // SwiftProtobuf.Message conformance is added in an extension below. See the
    // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
    // methods supported on all messages.

    var unknownFields = SwiftProtobuf.UnknownStorage()

    init() {}
  }

  /// Subscript text
  struct Subscript {
    // SwiftProtobuf.Message conformance is added in an extension below. See the
    // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
    // methods supported on all messages.

    var unknownFields = SwiftProtobuf.UnknownStorage()

    init() {}
  }

  /// A larger codeblock, with a programming language specified
  /// Clients should ideally not bound the width of codeblock messages,
  /// possibly scrolling the codeblock horizontally separately from the
  /// rest of the message
  struct CodeBlock {
    // SwiftProtobuf.Message conformance is added in an extension below. See the
    // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
    // methods supported on all messages.

    /// programming language of the code block
    var language: String = String()

    var unknownFields = SwiftProtobuf.UnknownStorage()

    init() {}
  }

  /// Mention of a user (on the current homeserver)
  struct UserMention {
    // SwiftProtobuf.Message conformance is added in an extension below. See the
    // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
    // methods supported on all messages.

    /// user_id of the user being mentioned
    var userID: UInt64 = 0

    var unknownFields = SwiftProtobuf.UnknownStorage()

    init() {}
  }

  /// Mention of a role (on the current guild)
  struct RoleMention {
    // SwiftProtobuf.Message conformance is added in an extension below. See the
    // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
    // methods supported on all messages.

    /// the role being mentioned
    var roleID: UInt64 = 0

    var unknownFields = SwiftProtobuf.UnknownStorage()

    init() {}
  }

  /// Mention of a channel (on the current guild)
  struct ChannelMention {
    // SwiftProtobuf.Message conformance is added in an extension below. See the
    // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
    // methods supported on all messages.

    /// the channel being mentioned
    var channelID: UInt64 = 0

    var unknownFields = SwiftProtobuf.UnknownStorage()

    init() {}
  }

  /// Mention of a guild
  struct GuildMention {
    // SwiftProtobuf.Message conformance is added in an extension below. See the
    // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
    // methods supported on all messages.

    /// the guild being mentioned
    var guildID: UInt64 = 0

    /// which homeserver it belongs to
    var homeserver: String = String()

    var unknownFields = SwiftProtobuf.UnknownStorage()

    init() {}
  }

  /// An emoji
  struct Emoji {
    // SwiftProtobuf.Message conformance is added in an extension below. See the
    // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
    // methods supported on all messages.

    /// The HMC URL of the emoji
    var imageHmc: String = String()

    /// The ID of the emoji pack the emoji is from
    var packID: UInt64 = 0

    var unknownFields = SwiftProtobuf.UnknownStorage()

    init() {}
  }

  /// Colour modification
  struct Color {
    // SwiftProtobuf.Message conformance is added in an extension below. See the
    // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
    // methods supported on all messages.

    /// The kind of colour modification to apply
    var kind: Protocol_Chat_V1_Format.Color.Kind = .dimUnspecified

    var unknownFields = SwiftProtobuf.UnknownStorage()

    /// The kind of colour modification to apply
    enum Kind: SwiftProtobuf.Enum {
      typealias RawValue = Int

      /// Dimmed colour
      case dimUnspecified // = 0

      /// Brightened colour
      case bright // = 1

      /// Negative colour (usually red)
      case negative // = 2

      /// Positive colour (usually green)
      case positive // = 3

      /// Informational colour (usually blue)
      case info // = 4

      /// Warning colour (usually yellow-orange)
      case warning // = 5
      case UNRECOGNIZED(Int)

      init() {
        self = .dimUnspecified
      }

      init?(rawValue: Int) {
        switch rawValue {
        case 0: self = .dimUnspecified
        case 1: self = .bright
        case 2: self = .negative
        case 3: self = .positive
        case 4: self = .info
        case 5: self = .warning
        default: self = .UNRECOGNIZED(rawValue)
        }
      }

      var rawValue: Int {
        switch self {
        case .dimUnspecified: return 0
        case .bright: return 1
        case .negative: return 2
        case .positive: return 3
        case .info: return 4
        case .warning: return 5
        case .UNRECOGNIZED(let i): return i
        }
      }

    }

    init() {}
  }

  /// Replace a part of the text with the text matching the i18n code.
  /// If i18n code was not found, keep the original text.
  struct Localization {
    // SwiftProtobuf.Message conformance is added in an extension below. See the
    // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
    // methods supported on all messages.

    /// i18n code for the text.
    var i18NCode: String = String()

    var unknownFields = SwiftProtobuf.UnknownStorage()

    init() {}
  }

  init() {}
}

#if swift(>=4.2)

extension Protocol_Chat_V1_Format.Color.Kind: CaseIterable {
  // The compiler won't synthesize support with the UNRECOGNIZED case.
  static var allCases: [Protocol_Chat_V1_Format.Color.Kind] = [
    .dimUnspecified,
    .bright,
    .negative,
    .positive,
    .info,
    .warning,
  ]
}

#endif  // swift(>=4.2)

/// Formatted text
struct Protocol_Chat_V1_FormattedText {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  /// The textual content of a message
  var text: String = String()

  /// The formats for a message
  var format: [Protocol_Chat_V1_Format] = []

  var unknownFields = SwiftProtobuf.UnknownStorage()

  init() {}
}

/// Object representing a message without the ID part.
struct Protocol_Chat_V1_Message {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  /// Metadata of this message.
  var metadata: Protocol_Harmonytypes_V1_Metadata {
    get {return _metadata ?? Protocol_Harmonytypes_V1_Metadata()}
    set {_metadata = newValue}
  }
  /// Returns true if `metadata` has been explicitly set.
  var hasMetadata: Bool {return self._metadata != nil}
  /// Clears the value of `metadata`. Subsequent reads from it will return its default value.
  mutating func clearMetadata() {self._metadata = nil}

  /// Overrides of this message.
  var overrides: Protocol_Chat_V1_Overrides {
    get {return _overrides ?? Protocol_Chat_V1_Overrides()}
    set {_overrides = newValue}
  }
  /// Returns true if `overrides` has been explicitly set.
  var hasOverrides: Bool {return self._overrides != nil}
  /// Clears the value of `overrides`. Subsequent reads from it will return its default value.
  mutating func clearOverrides() {self._overrides = nil}

  /// User ID of the user who sent this message.
  var authorID: UInt64 = 0

  /// When this message was created, in miliseconds since unix epoch
  var createdAt: UInt64 = 0

  /// The most recent time this message was edited, in milliseconds since unix epoch
  var editedAt: UInt64 {
    get {return _editedAt ?? 0}
    set {_editedAt = newValue}
  }
  /// Returns true if `editedAt` has been explicitly set.
  var hasEditedAt: Bool {return self._editedAt != nil}
  /// Clears the value of `editedAt`. Subsequent reads from it will return its default value.
  mutating func clearEditedAt() {self._editedAt = nil}

  /// The message this message is a reply to.
  var inReplyTo: UInt64 {
    get {return _inReplyTo ?? 0}
    set {_inReplyTo = newValue}
  }
  /// Returns true if `inReplyTo` has been explicitly set.
  var hasInReplyTo: Bool {return self._inReplyTo != nil}
  /// Clears the value of `inReplyTo`. Subsequent reads from it will return its default value.
  mutating func clearInReplyTo() {self._inReplyTo = nil}

  /// The content of the message.
  var content: Protocol_Chat_V1_Content {
    get {return _content ?? Protocol_Chat_V1_Content()}
    set {_content = newValue}
  }
  /// Returns true if `content` has been explicitly set.
  var hasContent: Bool {return self._content != nil}
  /// Clears the value of `content`. Subsequent reads from it will return its default value.
  mutating func clearContent() {self._content = nil}

  /// The reactions of the message.
  var reactions: [Protocol_Chat_V1_Reaction] = []

  var unknownFields = SwiftProtobuf.UnknownStorage()

  init() {}

  fileprivate var _metadata: Protocol_Harmonytypes_V1_Metadata? = nil
  fileprivate var _overrides: Protocol_Chat_V1_Overrides? = nil
  fileprivate var _editedAt: UInt64? = nil
  fileprivate var _inReplyTo: UInt64? = nil
  fileprivate var _content: Protocol_Chat_V1_Content? = nil
}

/// Object representing a message with it's ID.
struct Protocol_Chat_V1_MessageWithId {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  /// ID of the message.
  var messageID: UInt64 = 0

  /// The message data.
  var message: Protocol_Chat_V1_Message {
    get {return _message ?? Protocol_Chat_V1_Message()}
    set {_message = newValue}
  }
  /// Returns true if `message` has been explicitly set.
  var hasMessage: Bool {return self._message != nil}
  /// Clears the value of `message`. Subsequent reads from it will return its default value.
  mutating func clearMessage() {self._message = nil}

  var unknownFields = SwiftProtobuf.UnknownStorage()

  init() {}

  fileprivate var _message: Protocol_Chat_V1_Message? = nil
}

/// Used in the `GetChannelMessages` endpoint.
struct Protocol_Chat_V1_GetChannelMessagesRequest {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  /// Guild ID of the guild that has the channel.
  var guildID: UInt64 = 0

  /// Channel ID of the channel to get messages from.
  var channelID: UInt64 = 0

  /// The ID of the message that will be used as an "anchor" point to figure out
  /// where to get the messages.
  /// If not specified, the `direction` will be ignored and the newest messages
  /// will be returned.
  var messageID: UInt64 {
    get {return _messageID ?? 0}
    set {_messageID = newValue}
  }
  /// Returns true if `messageID` has been explicitly set.
  var hasMessageID: Bool {return self._messageID != nil}
  /// Clears the value of `messageID`. Subsequent reads from it will return its default value.
  mutating func clearMessageID() {self._messageID = nil}

  /// On which direction to get the messages.
  ///
  /// - By default, it is "before", which means you will get messages before the
  /// `message_id` message.
  /// - If it is "around", you will get the messages around the `message_id`
  /// message. This will include the `message_id` message itself, as the middle
  /// item of the list returned.
  /// - If it is "after", you will get the messages after the `message_id`
  /// message.
  var direction: Protocol_Chat_V1_GetChannelMessagesRequest.Direction {
    get {return _direction ?? .beforeUnspecified}
    set {_direction = newValue}
  }
  /// Returns true if `direction` has been explicitly set.
  var hasDirection: Bool {return self._direction != nil}
  /// Clears the value of `direction`. Subsequent reads from it will return its default value.
  mutating func clearDirection() {self._direction = nil}

  /// How many messages to get.
  ///
  /// - If `0`, a recommended message count to return is 25. If the direction is
  /// "around", the recommended value is 12.
  /// - If the direction to get the messages is "around", this count will not be
  /// the *total* count of messages to return, but instead the count of messages
  /// to return *for each direction*, before and after.
  /// - Servers should enforce their own maximum limit, and clamp this value to
  /// the limit.
  var count: UInt32 {
    get {return _count ?? 0}
    set {_count = newValue}
  }
  /// Returns true if `count` has been explicitly set.
  var hasCount: Bool {return self._count != nil}
  /// Clears the value of `count`. Subsequent reads from it will return its default value.
  mutating func clearCount() {self._count = nil}

  var unknownFields = SwiftProtobuf.UnknownStorage()

  /// The direction relative to the `message_id` message to get messages from.
  enum Direction: SwiftProtobuf.Enum {
    typealias RawValue = Int

    /// Get messages before the anchor.
    case beforeUnspecified // = 0

    /// Get messages around the anchor, including the anchor.
    case around // = 1

    /// Get messages after the anchor.
    case after // = 2
    case UNRECOGNIZED(Int)

    init() {
      self = .beforeUnspecified
    }

    init?(rawValue: Int) {
      switch rawValue {
      case 0: self = .beforeUnspecified
      case 1: self = .around
      case 2: self = .after
      default: self = .UNRECOGNIZED(rawValue)
      }
    }

    var rawValue: Int {
      switch self {
      case .beforeUnspecified: return 0
      case .around: return 1
      case .after: return 2
      case .UNRECOGNIZED(let i): return i
      }
    }

  }

  init() {}

  fileprivate var _messageID: UInt64? = nil
  fileprivate var _direction: Protocol_Chat_V1_GetChannelMessagesRequest.Direction? = nil
  fileprivate var _count: UInt32? = nil
}

#if swift(>=4.2)

extension Protocol_Chat_V1_GetChannelMessagesRequest.Direction: CaseIterable {
  // The compiler won't synthesize support with the UNRECOGNIZED case.
  static var allCases: [Protocol_Chat_V1_GetChannelMessagesRequest.Direction] = [
    .beforeUnspecified,
    .around,
    .after,
  ]
}

#endif  // swift(>=4.2)

/// Used in the `GetChannelMessages` endpoint.
struct Protocol_Chat_V1_GetChannelMessagesResponse {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  /// Has reached the top (first message) of the message history.
  var reachedTop: Bool = false

  /// Has reached the bottom (last message) of the message history.
  var reachedBottom: Bool = false

  /// The messages requested.
  var messages: [Protocol_Chat_V1_MessageWithId] = []

  var unknownFields = SwiftProtobuf.UnknownStorage()

  init() {}
}

/// Used in the `GetMessage` endpoint.
struct Protocol_Chat_V1_GetMessageRequest {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  /// Guild ID of the guild where the channel is.
  var guildID: UInt64 = 0

  /// Channel ID of the channel where the message is.
  var channelID: UInt64 = 0

  /// Message ID of the message you want to get.
  var messageID: UInt64 = 0

  var unknownFields = SwiftProtobuf.UnknownStorage()

  init() {}
}

/// Used in the `GetMessage` endpoint.
struct Protocol_Chat_V1_GetMessageResponse {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  /// The message requested.
  var message: Protocol_Chat_V1_Message {
    get {return _message ?? Protocol_Chat_V1_Message()}
    set {_message = newValue}
  }
  /// Returns true if `message` has been explicitly set.
  var hasMessage: Bool {return self._message != nil}
  /// Clears the value of `message`. Subsequent reads from it will return its default value.
  mutating func clearMessage() {self._message = nil}

  var unknownFields = SwiftProtobuf.UnknownStorage()

  init() {}

  fileprivate var _message: Protocol_Chat_V1_Message? = nil
}

/// Used in the `DeleteMessage` endpoint.
struct Protocol_Chat_V1_DeleteMessageRequest {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  /// Guild ID of the guild where the channel is.
  var guildID: UInt64 = 0

  /// Channel ID of the channel where the message is.
  var channelID: UInt64 = 0

  /// Message ID of the message you want to delete.
  var messageID: UInt64 = 0

  var unknownFields = SwiftProtobuf.UnknownStorage()

  init() {}
}

/// Used in the `DeleteMessage` endpoint.
struct Protocol_Chat_V1_DeleteMessageResponse {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  var unknownFields = SwiftProtobuf.UnknownStorage()

  init() {}
}

/// Used in the `TriggerAction` endpoint.
struct Protocol_Chat_V1_TriggerActionRequest {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  /// Guild ID of the guild where the channel is.
  var guildID: UInt64 = 0

  /// Channel ID of the channel where the message is.
  var channelID: UInt64 = 0

  /// Message ID of the message you want to trigger an action in.
  var messageID: UInt64 = 0

  /// Payload of action data.
  var payload: Protocol_Chat_V1_ActionPayload {
    get {return _payload ?? Protocol_Chat_V1_ActionPayload()}
    set {_payload = newValue}
  }
  /// Returns true if `payload` has been explicitly set.
  var hasPayload: Bool {return self._payload != nil}
  /// Clears the value of `payload`. Subsequent reads from it will return its default value.
  mutating func clearPayload() {self._payload = nil}

  var unknownFields = SwiftProtobuf.UnknownStorage()

  init() {}

  fileprivate var _payload: Protocol_Chat_V1_ActionPayload? = nil
}

/// Used in the `TriggerAction` endpoint.
struct Protocol_Chat_V1_TriggerActionResponse {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  var unknownFields = SwiftProtobuf.UnknownStorage()

  init() {}
}

/// Used in the `SendMessage` endpoint.
struct Protocol_Chat_V1_SendMessageRequest {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  /// Guild ID of the guild where the channel is.
  var guildID: UInt64 = 0

  /// Channel ID of the channel you want to send a message in.
  var channelID: UInt64 = 0

  /// Content of the new message.
  var content: Protocol_Chat_V1_Content {
    get {return _content ?? Protocol_Chat_V1_Content()}
    set {_content = newValue}
  }
  /// Returns true if `content` has been explicitly set.
  var hasContent: Bool {return self._content != nil}
  /// Clears the value of `content`. Subsequent reads from it will return its default value.
  mutating func clearContent() {self._content = nil}

  /// Echo ID of the new message. This can be used by clients to
  /// determine whether a message is sent.
  var echoID: UInt64 {
    get {return _echoID ?? 0}
    set {_echoID = newValue}
  }
  /// Returns true if `echoID` has been explicitly set.
  var hasEchoID: Bool {return self._echoID != nil}
  /// Clears the value of `echoID`. Subsequent reads from it will return its default value.
  mutating func clearEchoID() {self._echoID = nil}

  /// The overrides of this new message.
  var overrides: Protocol_Chat_V1_Overrides {
    get {return _overrides ?? Protocol_Chat_V1_Overrides()}
    set {_overrides = newValue}
  }
  /// Returns true if `overrides` has been explicitly set.
  var hasOverrides: Bool {return self._overrides != nil}
  /// Clears the value of `overrides`. Subsequent reads from it will return its default value.
  mutating func clearOverrides() {self._overrides = nil}

  /// The message this new message is a reply to.
  var inReplyTo: UInt64 {
    get {return _inReplyTo ?? 0}
    set {_inReplyTo = newValue}
  }
  /// Returns true if `inReplyTo` has been explicitly set.
  var hasInReplyTo: Bool {return self._inReplyTo != nil}
  /// Clears the value of `inReplyTo`. Subsequent reads from it will return its default value.
  mutating func clearInReplyTo() {self._inReplyTo = nil}

  /// The metadata of this new message.
  var metadata: Protocol_Harmonytypes_V1_Metadata {
    get {return _metadata ?? Protocol_Harmonytypes_V1_Metadata()}
    set {_metadata = newValue}
  }
  /// Returns true if `metadata` has been explicitly set.
  var hasMetadata: Bool {return self._metadata != nil}
  /// Clears the value of `metadata`. Subsequent reads from it will return its default value.
  mutating func clearMetadata() {self._metadata = nil}

  var unknownFields = SwiftProtobuf.UnknownStorage()

  init() {}

  fileprivate var _content: Protocol_Chat_V1_Content? = nil
  fileprivate var _echoID: UInt64? = nil
  fileprivate var _overrides: Protocol_Chat_V1_Overrides? = nil
  fileprivate var _inReplyTo: UInt64? = nil
  fileprivate var _metadata: Protocol_Harmonytypes_V1_Metadata? = nil
}

/// Used in the `SendMessage` endpoint.
struct Protocol_Chat_V1_SendMessageResponse {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  /// Message ID of the message sent.
  var messageID: UInt64 = 0

  var unknownFields = SwiftProtobuf.UnknownStorage()

  init() {}
}

/// Used in the `UpdateMessageText` endpoint.
struct Protocol_Chat_V1_UpdateMessageTextRequest {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  /// Guild ID of the guild where the channel is.
  var guildID: UInt64 = 0

  /// Channel ID of the channel where the message is.
  var channelID: UInt64 = 0

  /// Message ID of the message you want to edit the text of.
  var messageID: UInt64 = 0

  /// New content for this message.
  var newContent: Protocol_Chat_V1_FormattedText {
    get {return _newContent ?? Protocol_Chat_V1_FormattedText()}
    set {_newContent = newValue}
  }
  /// Returns true if `newContent` has been explicitly set.
  var hasNewContent: Bool {return self._newContent != nil}
  /// Clears the value of `newContent`. Subsequent reads from it will return its default value.
  mutating func clearNewContent() {self._newContent = nil}

  var unknownFields = SwiftProtobuf.UnknownStorage()

  init() {}

  fileprivate var _newContent: Protocol_Chat_V1_FormattedText? = nil
}

/// Used in the `UpdateMessageText` endpoint.
struct Protocol_Chat_V1_UpdateMessageTextResponse {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  var unknownFields = SwiftProtobuf.UnknownStorage()

  init() {}
}

/// Used in the `PinMessage` endpoint.
struct Protocol_Chat_V1_PinMessageRequest {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  /// Guild ID of the guild where the channel is.
  var guildID: UInt64 = 0

  /// Channel ID of the channel where the message is.
  var channelID: UInt64 = 0

  /// Message ID of the message we want to pin.
  var messageID: UInt64 = 0

  var unknownFields = SwiftProtobuf.UnknownStorage()

  init() {}
}

/// Used in the `UnpinMessage` endpoint.
struct Protocol_Chat_V1_PinMessageResponse {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  var unknownFields = SwiftProtobuf.UnknownStorage()

  init() {}
}

/// Used in the `UnpinMessage` endpoint.
struct Protocol_Chat_V1_UnpinMessageRequest {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  /// Guild ID of the guild where the channel is.
  var guildID: UInt64 = 0

  /// Channel ID of the channel where the message is.
  var channelID: UInt64 = 0

  /// Message ID of the message we want to unpin.
  var messageID: UInt64 = 0

  var unknownFields = SwiftProtobuf.UnknownStorage()

  init() {}
}

/// Used in the `UnpinMessage` endpoint.
struct Protocol_Chat_V1_UnpinMessageResponse {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  var unknownFields = SwiftProtobuf.UnknownStorage()

  init() {}
}

/// Used in the `GetPinnedMessages` endpoint.
struct Protocol_Chat_V1_GetPinnedMessagesRequest {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  /// Guild ID of the guild where the channel is.
  var guildID: UInt64 = 0

  /// Channel ID of the channel we want to get pins of.
  var channelID: UInt64 = 0

  var unknownFields = SwiftProtobuf.UnknownStorage()

  init() {}
}

/// Used in the `GetPinnedMessages` endpoint.
struct Protocol_Chat_V1_GetPinnedMessagesResponse {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  /// The IDs of the pinned messages.
  var pinnedMessageIds: [UInt64] = []

  var unknownFields = SwiftProtobuf.UnknownStorage()

  init() {}
}

/// Used in `AddReaction` endpoint.
struct Protocol_Chat_V1_AddReactionRequest {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  /// Guild ID of the guild where the channel is.
  var guildID: UInt64 = 0

  /// Channel ID of the channel where the message is.
  var channelID: UInt64 = 0

  /// Message ID of the message we want to add a reaction to.
  var messageID: UInt64 = 0

  /// The emote we want to react with.
  var emote: Protocol_Emote_V1_Emote {
    get {return _emote ?? Protocol_Emote_V1_Emote()}
    set {_emote = newValue}
  }
  /// Returns true if `emote` has been explicitly set.
  var hasEmote: Bool {return self._emote != nil}
  /// Clears the value of `emote`. Subsequent reads from it will return its default value.
  mutating func clearEmote() {self._emote = nil}

  var unknownFields = SwiftProtobuf.UnknownStorage()

  init() {}

  fileprivate var _emote: Protocol_Emote_V1_Emote? = nil
}

/// Used in `AddReaction` endpoint.
struct Protocol_Chat_V1_AddReactionResponse {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  var unknownFields = SwiftProtobuf.UnknownStorage()

  init() {}
}

/// Used in `RemoveReaction` endpoint.
struct Protocol_Chat_V1_RemoveReactionRequest {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  /// Guild ID of the guild where the channel is.
  var guildID: UInt64 = 0

  /// Channel ID of the channel where the message is.
  var channelID: UInt64 = 0

  /// Message ID of the message we want to remove a reaction.
  var messageID: UInt64 = 0

  /// The emote we want to remove the react of.
  var emote: Protocol_Emote_V1_Emote {
    get {return _emote ?? Protocol_Emote_V1_Emote()}
    set {_emote = newValue}
  }
  /// Returns true if `emote` has been explicitly set.
  var hasEmote: Bool {return self._emote != nil}
  /// Clears the value of `emote`. Subsequent reads from it will return its default value.
  mutating func clearEmote() {self._emote = nil}

  var unknownFields = SwiftProtobuf.UnknownStorage()

  init() {}

  fileprivate var _emote: Protocol_Emote_V1_Emote? = nil
}

/// Used in `RemoveReaction` endpoint.
struct Protocol_Chat_V1_RemoveReactionResponse {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  var unknownFields = SwiftProtobuf.UnknownStorage()

  init() {}
}

// MARK: - Code below here is support for the SwiftProtobuf runtime.

fileprivate let _protobuf_package = "protocol.chat.v1"

extension Protocol_Chat_V1_Overrides: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static let protoMessageName: String = _protobuf_package + ".Overrides"
  static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "username"),
    2: .same(proto: "avatar"),
    3: .standard(proto: "user_defined"),
    4: .same(proto: "webhook"),
    5: .standard(proto: "system_plurality"),
    6: .standard(proto: "system_message"),
    7: .same(proto: "bridge"),
  ]

  mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularStringField(value: &self._username) }()
      case 2: try { try decoder.decodeSingularStringField(value: &self._avatar) }()
      case 3: try {
        var v: String?
        try decoder.decodeSingularStringField(value: &v)
        if let v = v {
          if self.reason != nil {try decoder.handleConflictingOneOf()}
          self.reason = .userDefined(v)
        }
      }()
      case 4: try {
        var v: Protocol_Harmonytypes_V1_Empty?
        var hadOneofValue = false
        if let current = self.reason {
          hadOneofValue = true
          if case .webhook(let m) = current {v = m}
        }
        try decoder.decodeSingularMessageField(value: &v)
        if let v = v {
          if hadOneofValue {try decoder.handleConflictingOneOf()}
          self.reason = .webhook(v)
        }
      }()
      case 5: try {
        var v: Protocol_Harmonytypes_V1_Empty?
        var hadOneofValue = false
        if let current = self.reason {
          hadOneofValue = true
          if case .systemPlurality(let m) = current {v = m}
        }
        try decoder.decodeSingularMessageField(value: &v)
        if let v = v {
          if hadOneofValue {try decoder.handleConflictingOneOf()}
          self.reason = .systemPlurality(v)
        }
      }()
      case 6: try {
        var v: Protocol_Harmonytypes_V1_Empty?
        var hadOneofValue = false
        if let current = self.reason {
          hadOneofValue = true
          if case .systemMessage(let m) = current {v = m}
        }
        try decoder.decodeSingularMessageField(value: &v)
        if let v = v {
          if hadOneofValue {try decoder.handleConflictingOneOf()}
          self.reason = .systemMessage(v)
        }
      }()
      case 7: try {
        var v: Protocol_Harmonytypes_V1_Empty?
        var hadOneofValue = false
        if let current = self.reason {
          hadOneofValue = true
          if case .bridge(let m) = current {v = m}
        }
        try decoder.decodeSingularMessageField(value: &v)
        if let v = v {
          if hadOneofValue {try decoder.handleConflictingOneOf()}
          self.reason = .bridge(v)
        }
      }()
      default: break
      }
    }
  }

  func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if let v = self._username {
      try visitor.visitSingularStringField(value: v, fieldNumber: 1)
    }
    if let v = self._avatar {
      try visitor.visitSingularStringField(value: v, fieldNumber: 2)
    }
    // The use of inline closures is to circumvent an issue where the compiler
    // allocates stack space for every case branch when no optimizations are
    // enabled. https://github.com/apple/swift-protobuf/issues/1034
    switch self.reason {
    case .userDefined?: try {
      guard case .userDefined(let v)? = self.reason else { preconditionFailure() }
      try visitor.visitSingularStringField(value: v, fieldNumber: 3)
    }()
    case .webhook?: try {
      guard case .webhook(let v)? = self.reason else { preconditionFailure() }
      try visitor.visitSingularMessageField(value: v, fieldNumber: 4)
    }()
    case .systemPlurality?: try {
      guard case .systemPlurality(let v)? = self.reason else { preconditionFailure() }
      try visitor.visitSingularMessageField(value: v, fieldNumber: 5)
    }()
    case .systemMessage?: try {
      guard case .systemMessage(let v)? = self.reason else { preconditionFailure() }
      try visitor.visitSingularMessageField(value: v, fieldNumber: 6)
    }()
    case .bridge?: try {
      guard case .bridge(let v)? = self.reason else { preconditionFailure() }
      try visitor.visitSingularMessageField(value: v, fieldNumber: 7)
    }()
    case nil: break
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  static func ==(lhs: Protocol_Chat_V1_Overrides, rhs: Protocol_Chat_V1_Overrides) -> Bool {
    if lhs._username != rhs._username {return false}
    if lhs._avatar != rhs._avatar {return false}
    if lhs.reason != rhs.reason {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Protocol_Chat_V1_ActionPayload: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static let protoMessageName: String = _protobuf_package + ".ActionPayload"
  static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "button"),
    2: .same(proto: "dropdown"),
    3: .same(proto: "input"),
  ]

  mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try {
        var v: Protocol_Chat_V1_ActionPayload.Button?
        var hadOneofValue = false
        if let current = self.payload {
          hadOneofValue = true
          if case .button(let m) = current {v = m}
        }
        try decoder.decodeSingularMessageField(value: &v)
        if let v = v {
          if hadOneofValue {try decoder.handleConflictingOneOf()}
          self.payload = .button(v)
        }
      }()
      case 2: try {
        var v: Protocol_Chat_V1_ActionPayload.Dropdown?
        var hadOneofValue = false
        if let current = self.payload {
          hadOneofValue = true
          if case .dropdown(let m) = current {v = m}
        }
        try decoder.decodeSingularMessageField(value: &v)
        if let v = v {
          if hadOneofValue {try decoder.handleConflictingOneOf()}
          self.payload = .dropdown(v)
        }
      }()
      case 3: try {
        var v: Protocol_Chat_V1_ActionPayload.Input?
        var hadOneofValue = false
        if let current = self.payload {
          hadOneofValue = true
          if case .input(let m) = current {v = m}
        }
        try decoder.decodeSingularMessageField(value: &v)
        if let v = v {
          if hadOneofValue {try decoder.handleConflictingOneOf()}
          self.payload = .input(v)
        }
      }()
      default: break
      }
    }
  }

  func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    // The use of inline closures is to circumvent an issue where the compiler
    // allocates stack space for every case branch when no optimizations are
    // enabled. https://github.com/apple/swift-protobuf/issues/1034
    switch self.payload {
    case .button?: try {
      guard case .button(let v)? = self.payload else { preconditionFailure() }
      try visitor.visitSingularMessageField(value: v, fieldNumber: 1)
    }()
    case .dropdown?: try {
      guard case .dropdown(let v)? = self.payload else { preconditionFailure() }
      try visitor.visitSingularMessageField(value: v, fieldNumber: 2)
    }()
    case .input?: try {
      guard case .input(let v)? = self.payload else { preconditionFailure() }
      try visitor.visitSingularMessageField(value: v, fieldNumber: 3)
    }()
    case nil: break
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  static func ==(lhs: Protocol_Chat_V1_ActionPayload, rhs: Protocol_Chat_V1_ActionPayload) -> Bool {
    if lhs.payload != rhs.payload {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Protocol_Chat_V1_ActionPayload.Button: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static let protoMessageName: String = Protocol_Chat_V1_ActionPayload.protoMessageName + ".Button"
  static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "data"),
  ]

  mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularBytesField(value: &self.data) }()
      default: break
      }
    }
  }

  func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if !self.data.isEmpty {
      try visitor.visitSingularBytesField(value: self.data, fieldNumber: 1)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  static func ==(lhs: Protocol_Chat_V1_ActionPayload.Button, rhs: Protocol_Chat_V1_ActionPayload.Button) -> Bool {
    if lhs.data != rhs.data {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Protocol_Chat_V1_ActionPayload.Dropdown: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static let protoMessageName: String = Protocol_Chat_V1_ActionPayload.protoMessageName + ".Dropdown"
  static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "choice"),
  ]

  mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularBytesField(value: &self.choice) }()
      default: break
      }
    }
  }

  func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if !self.choice.isEmpty {
      try visitor.visitSingularBytesField(value: self.choice, fieldNumber: 1)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  static func ==(lhs: Protocol_Chat_V1_ActionPayload.Dropdown, rhs: Protocol_Chat_V1_ActionPayload.Dropdown) -> Bool {
    if lhs.choice != rhs.choice {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Protocol_Chat_V1_ActionPayload.Input: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static let protoMessageName: String = Protocol_Chat_V1_ActionPayload.protoMessageName + ".Input"
  static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "input"),
    2: .same(proto: "data"),
  ]

  mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularStringField(value: &self.input) }()
      case 2: try { try decoder.decodeSingularBytesField(value: &self.data) }()
      default: break
      }
    }
  }

  func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if !self.input.isEmpty {
      try visitor.visitSingularStringField(value: self.input, fieldNumber: 1)
    }
    if !self.data.isEmpty {
      try visitor.visitSingularBytesField(value: self.data, fieldNumber: 2)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  static func ==(lhs: Protocol_Chat_V1_ActionPayload.Input, rhs: Protocol_Chat_V1_ActionPayload.Input) -> Bool {
    if lhs.input != rhs.input {return false}
    if lhs.data != rhs.data {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Protocol_Chat_V1_Action: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static let protoMessageName: String = _protobuf_package + ".Action"
  static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .standard(proto: "action_type"),
    2: .same(proto: "button"),
    3: .same(proto: "dropdown"),
    4: .same(proto: "input"),
  ]

  mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularEnumField(value: &self.actionType) }()
      case 2: try {
        var v: Protocol_Chat_V1_Action.Button?
        var hadOneofValue = false
        if let current = self.kind {
          hadOneofValue = true
          if case .button(let m) = current {v = m}
        }
        try decoder.decodeSingularMessageField(value: &v)
        if let v = v {
          if hadOneofValue {try decoder.handleConflictingOneOf()}
          self.kind = .button(v)
        }
      }()
      case 3: try {
        var v: Protocol_Chat_V1_Action.Dropdown?
        var hadOneofValue = false
        if let current = self.kind {
          hadOneofValue = true
          if case .dropdown(let m) = current {v = m}
        }
        try decoder.decodeSingularMessageField(value: &v)
        if let v = v {
          if hadOneofValue {try decoder.handleConflictingOneOf()}
          self.kind = .dropdown(v)
        }
      }()
      case 4: try {
        var v: Protocol_Chat_V1_Action.Input?
        var hadOneofValue = false
        if let current = self.kind {
          hadOneofValue = true
          if case .input(let m) = current {v = m}
        }
        try decoder.decodeSingularMessageField(value: &v)
        if let v = v {
          if hadOneofValue {try decoder.handleConflictingOneOf()}
          self.kind = .input(v)
        }
      }()
      default: break
      }
    }
  }

  func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if self.actionType != .normalUnspecified {
      try visitor.visitSingularEnumField(value: self.actionType, fieldNumber: 1)
    }
    // The use of inline closures is to circumvent an issue where the compiler
    // allocates stack space for every case branch when no optimizations are
    // enabled. https://github.com/apple/swift-protobuf/issues/1034
    switch self.kind {
    case .button?: try {
      guard case .button(let v)? = self.kind else { preconditionFailure() }
      try visitor.visitSingularMessageField(value: v, fieldNumber: 2)
    }()
    case .dropdown?: try {
      guard case .dropdown(let v)? = self.kind else { preconditionFailure() }
      try visitor.visitSingularMessageField(value: v, fieldNumber: 3)
    }()
    case .input?: try {
      guard case .input(let v)? = self.kind else { preconditionFailure() }
      try visitor.visitSingularMessageField(value: v, fieldNumber: 4)
    }()
    case nil: break
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  static func ==(lhs: Protocol_Chat_V1_Action, rhs: Protocol_Chat_V1_Action) -> Bool {
    if lhs.actionType != rhs.actionType {return false}
    if lhs.kind != rhs.kind {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Protocol_Chat_V1_Action.TypeEnum: SwiftProtobuf._ProtoNameProviding {
  static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    0: .same(proto: "TYPE_NORMAL_UNSPECIFIED"),
    1: .same(proto: "TYPE_PRIMARY"),
    2: .same(proto: "TYPE_DESTRUCTIVE"),
  ]
}

extension Protocol_Chat_V1_Action.Button: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static let protoMessageName: String = Protocol_Chat_V1_Action.protoMessageName + ".Button"
  static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "text"),
    2: .same(proto: "data"),
    3: .same(proto: "url"),
  ]

  mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularStringField(value: &self.text) }()
      case 2: try { try decoder.decodeSingularBytesField(value: &self.data) }()
      case 3: try { try decoder.decodeSingularStringField(value: &self._url) }()
      default: break
      }
    }
  }

  func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if !self.text.isEmpty {
      try visitor.visitSingularStringField(value: self.text, fieldNumber: 1)
    }
    if !self.data.isEmpty {
      try visitor.visitSingularBytesField(value: self.data, fieldNumber: 2)
    }
    if let v = self._url {
      try visitor.visitSingularStringField(value: v, fieldNumber: 3)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  static func ==(lhs: Protocol_Chat_V1_Action.Button, rhs: Protocol_Chat_V1_Action.Button) -> Bool {
    if lhs.text != rhs.text {return false}
    if lhs.data != rhs.data {return false}
    if lhs._url != rhs._url {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Protocol_Chat_V1_Action.Dropdown: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static let protoMessageName: String = Protocol_Chat_V1_Action.protoMessageName + ".Dropdown"
  static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "label"),
    2: .same(proto: "entries"),
  ]

  mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularStringField(value: &self.label) }()
      case 2: try { try decoder.decodeRepeatedMessageField(value: &self.entries) }()
      default: break
      }
    }
  }

  func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if !self.label.isEmpty {
      try visitor.visitSingularStringField(value: self.label, fieldNumber: 1)
    }
    if !self.entries.isEmpty {
      try visitor.visitRepeatedMessageField(value: self.entries, fieldNumber: 2)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  static func ==(lhs: Protocol_Chat_V1_Action.Dropdown, rhs: Protocol_Chat_V1_Action.Dropdown) -> Bool {
    if lhs.label != rhs.label {return false}
    if lhs.entries != rhs.entries {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Protocol_Chat_V1_Action.Dropdown.Entry: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static let protoMessageName: String = Protocol_Chat_V1_Action.Dropdown.protoMessageName + ".Entry"
  static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "label"),
    2: .same(proto: "data"),
  ]

  mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularStringField(value: &self.label) }()
      case 2: try { try decoder.decodeSingularBytesField(value: &self.data) }()
      default: break
      }
    }
  }

  func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if !self.label.isEmpty {
      try visitor.visitSingularStringField(value: self.label, fieldNumber: 1)
    }
    if !self.data.isEmpty {
      try visitor.visitSingularBytesField(value: self.data, fieldNumber: 2)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  static func ==(lhs: Protocol_Chat_V1_Action.Dropdown.Entry, rhs: Protocol_Chat_V1_Action.Dropdown.Entry) -> Bool {
    if lhs.label != rhs.label {return false}
    if lhs.data != rhs.data {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Protocol_Chat_V1_Action.Input: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static let protoMessageName: String = Protocol_Chat_V1_Action.protoMessageName + ".Input"
  static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "label"),
    2: .same(proto: "multiline"),
    3: .same(proto: "data"),
  ]

  mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularStringField(value: &self.label) }()
      case 2: try { try decoder.decodeSingularBoolField(value: &self.multiline) }()
      case 3: try { try decoder.decodeSingularBytesField(value: &self.data) }()
      default: break
      }
    }
  }

  func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if !self.label.isEmpty {
      try visitor.visitSingularStringField(value: self.label, fieldNumber: 1)
    }
    if self.multiline != false {
      try visitor.visitSingularBoolField(value: self.multiline, fieldNumber: 2)
    }
    if !self.data.isEmpty {
      try visitor.visitSingularBytesField(value: self.data, fieldNumber: 3)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  static func ==(lhs: Protocol_Chat_V1_Action.Input, rhs: Protocol_Chat_V1_Action.Input) -> Bool {
    if lhs.label != rhs.label {return false}
    if lhs.multiline != rhs.multiline {return false}
    if lhs.data != rhs.data {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Protocol_Chat_V1_Embed: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static let protoMessageName: String = _protobuf_package + ".Embed"
  static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "title"),
    2: .same(proto: "body"),
    3: .same(proto: "color"),
    4: .same(proto: "header"),
    5: .same(proto: "footer"),
    6: .same(proto: "fields"),
  ]

  mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularStringField(value: &self.title) }()
      case 2: try { try decoder.decodeSingularMessageField(value: &self._body) }()
      case 3: try { try decoder.decodeSingularInt32Field(value: &self._color) }()
      case 4: try { try decoder.decodeSingularMessageField(value: &self._header) }()
      case 5: try { try decoder.decodeSingularMessageField(value: &self._footer) }()
      case 6: try { try decoder.decodeRepeatedMessageField(value: &self.fields) }()
      default: break
      }
    }
  }

  func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if !self.title.isEmpty {
      try visitor.visitSingularStringField(value: self.title, fieldNumber: 1)
    }
    if let v = self._body {
      try visitor.visitSingularMessageField(value: v, fieldNumber: 2)
    }
    if let v = self._color {
      try visitor.visitSingularInt32Field(value: v, fieldNumber: 3)
    }
    if let v = self._header {
      try visitor.visitSingularMessageField(value: v, fieldNumber: 4)
    }
    if let v = self._footer {
      try visitor.visitSingularMessageField(value: v, fieldNumber: 5)
    }
    if !self.fields.isEmpty {
      try visitor.visitRepeatedMessageField(value: self.fields, fieldNumber: 6)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  static func ==(lhs: Protocol_Chat_V1_Embed, rhs: Protocol_Chat_V1_Embed) -> Bool {
    if lhs.title != rhs.title {return false}
    if lhs._body != rhs._body {return false}
    if lhs._color != rhs._color {return false}
    if lhs._header != rhs._header {return false}
    if lhs._footer != rhs._footer {return false}
    if lhs.fields != rhs.fields {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Protocol_Chat_V1_Embed.EmbedHeading: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static let protoMessageName: String = Protocol_Chat_V1_Embed.protoMessageName + ".EmbedHeading"
  static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "text"),
    2: .same(proto: "subtext"),
    3: .same(proto: "url"),
    4: .same(proto: "icon"),
  ]

  mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularStringField(value: &self.text) }()
      case 2: try { try decoder.decodeSingularStringField(value: &self._subtext) }()
      case 3: try { try decoder.decodeSingularStringField(value: &self._url) }()
      case 4: try { try decoder.decodeSingularStringField(value: &self._icon) }()
      default: break
      }
    }
  }

  func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if !self.text.isEmpty {
      try visitor.visitSingularStringField(value: self.text, fieldNumber: 1)
    }
    if let v = self._subtext {
      try visitor.visitSingularStringField(value: v, fieldNumber: 2)
    }
    if let v = self._url {
      try visitor.visitSingularStringField(value: v, fieldNumber: 3)
    }
    if let v = self._icon {
      try visitor.visitSingularStringField(value: v, fieldNumber: 4)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  static func ==(lhs: Protocol_Chat_V1_Embed.EmbedHeading, rhs: Protocol_Chat_V1_Embed.EmbedHeading) -> Bool {
    if lhs.text != rhs.text {return false}
    if lhs._subtext != rhs._subtext {return false}
    if lhs._url != rhs._url {return false}
    if lhs._icon != rhs._icon {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Protocol_Chat_V1_Embed.EmbedField: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static let protoMessageName: String = Protocol_Chat_V1_Embed.protoMessageName + ".EmbedField"
  static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "title"),
    2: .same(proto: "subtitle"),
    3: .same(proto: "body"),
    4: .standard(proto: "image_url"),
    5: .same(proto: "presentation"),
    6: .same(proto: "actions"),
  ]

  mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularStringField(value: &self.title) }()
      case 2: try { try decoder.decodeSingularStringField(value: &self._subtitle) }()
      case 3: try { try decoder.decodeSingularMessageField(value: &self._body) }()
      case 4: try { try decoder.decodeSingularStringField(value: &self._imageURL) }()
      case 5: try { try decoder.decodeSingularEnumField(value: &self.presentation) }()
      case 6: try { try decoder.decodeRepeatedMessageField(value: &self.actions) }()
      default: break
      }
    }
  }

  func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if !self.title.isEmpty {
      try visitor.visitSingularStringField(value: self.title, fieldNumber: 1)
    }
    if let v = self._subtitle {
      try visitor.visitSingularStringField(value: v, fieldNumber: 2)
    }
    if let v = self._body {
      try visitor.visitSingularMessageField(value: v, fieldNumber: 3)
    }
    if let v = self._imageURL {
      try visitor.visitSingularStringField(value: v, fieldNumber: 4)
    }
    if self.presentation != .dataUnspecified {
      try visitor.visitSingularEnumField(value: self.presentation, fieldNumber: 5)
    }
    if !self.actions.isEmpty {
      try visitor.visitRepeatedMessageField(value: self.actions, fieldNumber: 6)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  static func ==(lhs: Protocol_Chat_V1_Embed.EmbedField, rhs: Protocol_Chat_V1_Embed.EmbedField) -> Bool {
    if lhs.title != rhs.title {return false}
    if lhs._subtitle != rhs._subtitle {return false}
    if lhs._body != rhs._body {return false}
    if lhs._imageURL != rhs._imageURL {return false}
    if lhs.presentation != rhs.presentation {return false}
    if lhs.actions != rhs.actions {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Protocol_Chat_V1_Embed.EmbedField.Presentation: SwiftProtobuf._ProtoNameProviding {
  static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    0: .same(proto: "PRESENTATION_DATA_UNSPECIFIED"),
    1: .same(proto: "PRESENTATION_CAPTIONED_IMAGE"),
    2: .same(proto: "PRESENTATION_ROW"),
  ]
}

extension Protocol_Chat_V1_Minithumbnail: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static let protoMessageName: String = _protobuf_package + ".Minithumbnail"
  static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "width"),
    2: .same(proto: "height"),
    3: .same(proto: "data"),
  ]

  mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularUInt32Field(value: &self.width) }()
      case 2: try { try decoder.decodeSingularUInt32Field(value: &self.height) }()
      case 3: try { try decoder.decodeSingularBytesField(value: &self.data) }()
      default: break
      }
    }
  }

  func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if self.width != 0 {
      try visitor.visitSingularUInt32Field(value: self.width, fieldNumber: 1)
    }
    if self.height != 0 {
      try visitor.visitSingularUInt32Field(value: self.height, fieldNumber: 2)
    }
    if !self.data.isEmpty {
      try visitor.visitSingularBytesField(value: self.data, fieldNumber: 3)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  static func ==(lhs: Protocol_Chat_V1_Minithumbnail, rhs: Protocol_Chat_V1_Minithumbnail) -> Bool {
    if lhs.width != rhs.width {return false}
    if lhs.height != rhs.height {return false}
    if lhs.data != rhs.data {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Protocol_Chat_V1_Photo: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static let protoMessageName: String = _protobuf_package + ".Photo"
  static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "hmc"),
    2: .same(proto: "name"),
    3: .standard(proto: "file_size"),
    4: .same(proto: "height"),
    5: .same(proto: "width"),
    6: .same(proto: "caption"),
    7: .same(proto: "minithumbnail"),
  ]

  mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularStringField(value: &self.hmc) }()
      case 2: try { try decoder.decodeSingularStringField(value: &self.name) }()
      case 3: try { try decoder.decodeSingularUInt32Field(value: &self.fileSize) }()
      case 4: try { try decoder.decodeSingularUInt32Field(value: &self.height) }()
      case 5: try { try decoder.decodeSingularUInt32Field(value: &self.width) }()
      case 6: try { try decoder.decodeSingularMessageField(value: &self._caption) }()
      case 7: try { try decoder.decodeSingularMessageField(value: &self._minithumbnail) }()
      default: break
      }
    }
  }

  func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if !self.hmc.isEmpty {
      try visitor.visitSingularStringField(value: self.hmc, fieldNumber: 1)
    }
    if !self.name.isEmpty {
      try visitor.visitSingularStringField(value: self.name, fieldNumber: 2)
    }
    if self.fileSize != 0 {
      try visitor.visitSingularUInt32Field(value: self.fileSize, fieldNumber: 3)
    }
    if self.height != 0 {
      try visitor.visitSingularUInt32Field(value: self.height, fieldNumber: 4)
    }
    if self.width != 0 {
      try visitor.visitSingularUInt32Field(value: self.width, fieldNumber: 5)
    }
    if let v = self._caption {
      try visitor.visitSingularMessageField(value: v, fieldNumber: 6)
    }
    if let v = self._minithumbnail {
      try visitor.visitSingularMessageField(value: v, fieldNumber: 7)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  static func ==(lhs: Protocol_Chat_V1_Photo, rhs: Protocol_Chat_V1_Photo) -> Bool {
    if lhs.hmc != rhs.hmc {return false}
    if lhs.name != rhs.name {return false}
    if lhs.fileSize != rhs.fileSize {return false}
    if lhs.height != rhs.height {return false}
    if lhs.width != rhs.width {return false}
    if lhs._caption != rhs._caption {return false}
    if lhs._minithumbnail != rhs._minithumbnail {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Protocol_Chat_V1_Attachment: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static let protoMessageName: String = _protobuf_package + ".Attachment"
  static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "id"),
    2: .same(proto: "name"),
    3: .same(proto: "mimetype"),
    4: .same(proto: "size"),
    5: .same(proto: "caption"),
  ]

  mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularStringField(value: &self.id) }()
      case 2: try { try decoder.decodeSingularStringField(value: &self.name) }()
      case 3: try { try decoder.decodeSingularStringField(value: &self.mimetype) }()
      case 4: try { try decoder.decodeSingularUInt32Field(value: &self.size) }()
      case 5: try { try decoder.decodeSingularMessageField(value: &self._caption) }()
      default: break
      }
    }
  }

  func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if !self.id.isEmpty {
      try visitor.visitSingularStringField(value: self.id, fieldNumber: 1)
    }
    if !self.name.isEmpty {
      try visitor.visitSingularStringField(value: self.name, fieldNumber: 2)
    }
    if !self.mimetype.isEmpty {
      try visitor.visitSingularStringField(value: self.mimetype, fieldNumber: 3)
    }
    if self.size != 0 {
      try visitor.visitSingularUInt32Field(value: self.size, fieldNumber: 4)
    }
    if let v = self._caption {
      try visitor.visitSingularMessageField(value: v, fieldNumber: 5)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  static func ==(lhs: Protocol_Chat_V1_Attachment, rhs: Protocol_Chat_V1_Attachment) -> Bool {
    if lhs.id != rhs.id {return false}
    if lhs.name != rhs.name {return false}
    if lhs.mimetype != rhs.mimetype {return false}
    if lhs.size != rhs.size {return false}
    if lhs._caption != rhs._caption {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Protocol_Chat_V1_Content: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static let protoMessageName: String = _protobuf_package + ".Content"
  static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .standard(proto: "text_message"),
    2: .standard(proto: "embed_message"),
    3: .standard(proto: "attachment_message"),
    4: .standard(proto: "photo_message"),
    5: .standard(proto: "invite_rejected"),
    6: .standard(proto: "invite_accepted"),
    7: .standard(proto: "room_upgraded_to_guild"),
  ]

  mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try {
        var v: Protocol_Chat_V1_Content.TextContent?
        var hadOneofValue = false
        if let current = self.content {
          hadOneofValue = true
          if case .textMessage(let m) = current {v = m}
        }
        try decoder.decodeSingularMessageField(value: &v)
        if let v = v {
          if hadOneofValue {try decoder.handleConflictingOneOf()}
          self.content = .textMessage(v)
        }
      }()
      case 2: try {
        var v: Protocol_Chat_V1_Content.EmbedContent?
        var hadOneofValue = false
        if let current = self.content {
          hadOneofValue = true
          if case .embedMessage(let m) = current {v = m}
        }
        try decoder.decodeSingularMessageField(value: &v)
        if let v = v {
          if hadOneofValue {try decoder.handleConflictingOneOf()}
          self.content = .embedMessage(v)
        }
      }()
      case 3: try {
        var v: Protocol_Chat_V1_Content.AttachmentContent?
        var hadOneofValue = false
        if let current = self.content {
          hadOneofValue = true
          if case .attachmentMessage(let m) = current {v = m}
        }
        try decoder.decodeSingularMessageField(value: &v)
        if let v = v {
          if hadOneofValue {try decoder.handleConflictingOneOf()}
          self.content = .attachmentMessage(v)
        }
      }()
      case 4: try {
        var v: Protocol_Chat_V1_Content.PhotoContent?
        var hadOneofValue = false
        if let current = self.content {
          hadOneofValue = true
          if case .photoMessage(let m) = current {v = m}
        }
        try decoder.decodeSingularMessageField(value: &v)
        if let v = v {
          if hadOneofValue {try decoder.handleConflictingOneOf()}
          self.content = .photoMessage(v)
        }
      }()
      case 5: try {
        var v: Protocol_Chat_V1_Content.InviteRejected?
        var hadOneofValue = false
        if let current = self.content {
          hadOneofValue = true
          if case .inviteRejected(let m) = current {v = m}
        }
        try decoder.decodeSingularMessageField(value: &v)
        if let v = v {
          if hadOneofValue {try decoder.handleConflictingOneOf()}
          self.content = .inviteRejected(v)
        }
      }()
      case 6: try {
        var v: Protocol_Chat_V1_Content.InviteAccepted?
        var hadOneofValue = false
        if let current = self.content {
          hadOneofValue = true
          if case .inviteAccepted(let m) = current {v = m}
        }
        try decoder.decodeSingularMessageField(value: &v)
        if let v = v {
          if hadOneofValue {try decoder.handleConflictingOneOf()}
          self.content = .inviteAccepted(v)
        }
      }()
      case 7: try {
        var v: Protocol_Chat_V1_Content.RoomUpgradedToGuild?
        var hadOneofValue = false
        if let current = self.content {
          hadOneofValue = true
          if case .roomUpgradedToGuild(let m) = current {v = m}
        }
        try decoder.decodeSingularMessageField(value: &v)
        if let v = v {
          if hadOneofValue {try decoder.handleConflictingOneOf()}
          self.content = .roomUpgradedToGuild(v)
        }
      }()
      default: break
      }
    }
  }

  func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    // The use of inline closures is to circumvent an issue where the compiler
    // allocates stack space for every case branch when no optimizations are
    // enabled. https://github.com/apple/swift-protobuf/issues/1034
    switch self.content {
    case .textMessage?: try {
      guard case .textMessage(let v)? = self.content else { preconditionFailure() }
      try visitor.visitSingularMessageField(value: v, fieldNumber: 1)
    }()
    case .embedMessage?: try {
      guard case .embedMessage(let v)? = self.content else { preconditionFailure() }
      try visitor.visitSingularMessageField(value: v, fieldNumber: 2)
    }()
    case .attachmentMessage?: try {
      guard case .attachmentMessage(let v)? = self.content else { preconditionFailure() }
      try visitor.visitSingularMessageField(value: v, fieldNumber: 3)
    }()
    case .photoMessage?: try {
      guard case .photoMessage(let v)? = self.content else { preconditionFailure() }
      try visitor.visitSingularMessageField(value: v, fieldNumber: 4)
    }()
    case .inviteRejected?: try {
      guard case .inviteRejected(let v)? = self.content else { preconditionFailure() }
      try visitor.visitSingularMessageField(value: v, fieldNumber: 5)
    }()
    case .inviteAccepted?: try {
      guard case .inviteAccepted(let v)? = self.content else { preconditionFailure() }
      try visitor.visitSingularMessageField(value: v, fieldNumber: 6)
    }()
    case .roomUpgradedToGuild?: try {
      guard case .roomUpgradedToGuild(let v)? = self.content else { preconditionFailure() }
      try visitor.visitSingularMessageField(value: v, fieldNumber: 7)
    }()
    case nil: break
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  static func ==(lhs: Protocol_Chat_V1_Content, rhs: Protocol_Chat_V1_Content) -> Bool {
    if lhs.content != rhs.content {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Protocol_Chat_V1_Content.TextContent: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static let protoMessageName: String = Protocol_Chat_V1_Content.protoMessageName + ".TextContent"
  static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "content"),
  ]

  mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularMessageField(value: &self._content) }()
      default: break
      }
    }
  }

  func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if let v = self._content {
      try visitor.visitSingularMessageField(value: v, fieldNumber: 1)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  static func ==(lhs: Protocol_Chat_V1_Content.TextContent, rhs: Protocol_Chat_V1_Content.TextContent) -> Bool {
    if lhs._content != rhs._content {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Protocol_Chat_V1_Content.EmbedContent: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static let protoMessageName: String = Protocol_Chat_V1_Content.protoMessageName + ".EmbedContent"
  static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "embeds"),
  ]

  mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeRepeatedMessageField(value: &self.embeds) }()
      default: break
      }
    }
  }

  func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if !self.embeds.isEmpty {
      try visitor.visitRepeatedMessageField(value: self.embeds, fieldNumber: 1)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  static func ==(lhs: Protocol_Chat_V1_Content.EmbedContent, rhs: Protocol_Chat_V1_Content.EmbedContent) -> Bool {
    if lhs.embeds != rhs.embeds {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Protocol_Chat_V1_Content.AttachmentContent: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static let protoMessageName: String = Protocol_Chat_V1_Content.protoMessageName + ".AttachmentContent"
  static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "files"),
  ]

  mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeRepeatedMessageField(value: &self.files) }()
      default: break
      }
    }
  }

  func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if !self.files.isEmpty {
      try visitor.visitRepeatedMessageField(value: self.files, fieldNumber: 1)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  static func ==(lhs: Protocol_Chat_V1_Content.AttachmentContent, rhs: Protocol_Chat_V1_Content.AttachmentContent) -> Bool {
    if lhs.files != rhs.files {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Protocol_Chat_V1_Content.PhotoContent: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static let protoMessageName: String = Protocol_Chat_V1_Content.protoMessageName + ".PhotoContent"
  static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "photos"),
  ]

  mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeRepeatedMessageField(value: &self.photos) }()
      default: break
      }
    }
  }

  func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if !self.photos.isEmpty {
      try visitor.visitRepeatedMessageField(value: self.photos, fieldNumber: 1)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  static func ==(lhs: Protocol_Chat_V1_Content.PhotoContent, rhs: Protocol_Chat_V1_Content.PhotoContent) -> Bool {
    if lhs.photos != rhs.photos {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Protocol_Chat_V1_Content.InviteRejected: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static let protoMessageName: String = Protocol_Chat_V1_Content.protoMessageName + ".InviteRejected"
  static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .standard(proto: "invitee_id"),
    2: .standard(proto: "inviter_id"),
  ]

  mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularUInt64Field(value: &self.inviteeID) }()
      case 2: try { try decoder.decodeSingularUInt64Field(value: &self.inviterID) }()
      default: break
      }
    }
  }

  func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if self.inviteeID != 0 {
      try visitor.visitSingularUInt64Field(value: self.inviteeID, fieldNumber: 1)
    }
    if self.inviterID != 0 {
      try visitor.visitSingularUInt64Field(value: self.inviterID, fieldNumber: 2)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  static func ==(lhs: Protocol_Chat_V1_Content.InviteRejected, rhs: Protocol_Chat_V1_Content.InviteRejected) -> Bool {
    if lhs.inviteeID != rhs.inviteeID {return false}
    if lhs.inviterID != rhs.inviterID {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Protocol_Chat_V1_Content.InviteAccepted: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static let protoMessageName: String = Protocol_Chat_V1_Content.protoMessageName + ".InviteAccepted"
  static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .standard(proto: "invitee_id"),
    2: .standard(proto: "inviter_id"),
  ]

  mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularUInt64Field(value: &self.inviteeID) }()
      case 2: try { try decoder.decodeSingularUInt64Field(value: &self.inviterID) }()
      default: break
      }
    }
  }

  func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if self.inviteeID != 0 {
      try visitor.visitSingularUInt64Field(value: self.inviteeID, fieldNumber: 1)
    }
    if self.inviterID != 0 {
      try visitor.visitSingularUInt64Field(value: self.inviterID, fieldNumber: 2)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  static func ==(lhs: Protocol_Chat_V1_Content.InviteAccepted, rhs: Protocol_Chat_V1_Content.InviteAccepted) -> Bool {
    if lhs.inviteeID != rhs.inviteeID {return false}
    if lhs.inviterID != rhs.inviterID {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Protocol_Chat_V1_Content.RoomUpgradedToGuild: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static let protoMessageName: String = Protocol_Chat_V1_Content.protoMessageName + ".RoomUpgradedToGuild"
  static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .standard(proto: "upgraded_by"),
  ]

  mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularUInt64Field(value: &self.upgradedBy) }()
      default: break
      }
    }
  }

  func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if self.upgradedBy != 0 {
      try visitor.visitSingularUInt64Field(value: self.upgradedBy, fieldNumber: 1)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  static func ==(lhs: Protocol_Chat_V1_Content.RoomUpgradedToGuild, rhs: Protocol_Chat_V1_Content.RoomUpgradedToGuild) -> Bool {
    if lhs.upgradedBy != rhs.upgradedBy {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Protocol_Chat_V1_Reaction: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static let protoMessageName: String = _protobuf_package + ".Reaction"
  static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "emote"),
    2: .same(proto: "count"),
  ]

  mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularMessageField(value: &self._emote) }()
      case 2: try { try decoder.decodeSingularUInt32Field(value: &self.count) }()
      default: break
      }
    }
  }

  func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if let v = self._emote {
      try visitor.visitSingularMessageField(value: v, fieldNumber: 1)
    }
    if self.count != 0 {
      try visitor.visitSingularUInt32Field(value: self.count, fieldNumber: 2)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  static func ==(lhs: Protocol_Chat_V1_Reaction, rhs: Protocol_Chat_V1_Reaction) -> Bool {
    if lhs._emote != rhs._emote {return false}
    if lhs.count != rhs.count {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Protocol_Chat_V1_Format: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static let protoMessageName: String = _protobuf_package + ".Format"
  static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "start"),
    2: .same(proto: "length"),
    3: .same(proto: "bold"),
    4: .same(proto: "italic"),
    5: .same(proto: "underline"),
    6: .same(proto: "monospace"),
    7: .same(proto: "superscript"),
    8: .same(proto: "subscript"),
    9: .standard(proto: "code_block"),
    10: .standard(proto: "user_mention"),
    11: .standard(proto: "role_mention"),
    12: .standard(proto: "channel_mention"),
    13: .standard(proto: "guild_mention"),
    14: .same(proto: "emoji"),
    15: .same(proto: "color"),
    16: .same(proto: "localization"),
  ]

  mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularUInt32Field(value: &self.start) }()
      case 2: try { try decoder.decodeSingularUInt32Field(value: &self.length) }()
      case 3: try {
        var v: Protocol_Chat_V1_Format.Bold?
        var hadOneofValue = false
        if let current = self.format {
          hadOneofValue = true
          if case .bold(let m) = current {v = m}
        }
        try decoder.decodeSingularMessageField(value: &v)
        if let v = v {
          if hadOneofValue {try decoder.handleConflictingOneOf()}
          self.format = .bold(v)
        }
      }()
      case 4: try {
        var v: Protocol_Chat_V1_Format.Italic?
        var hadOneofValue = false
        if let current = self.format {
          hadOneofValue = true
          if case .italic(let m) = current {v = m}
        }
        try decoder.decodeSingularMessageField(value: &v)
        if let v = v {
          if hadOneofValue {try decoder.handleConflictingOneOf()}
          self.format = .italic(v)
        }
      }()
      case 5: try {
        var v: Protocol_Chat_V1_Format.Underline?
        var hadOneofValue = false
        if let current = self.format {
          hadOneofValue = true
          if case .underline(let m) = current {v = m}
        }
        try decoder.decodeSingularMessageField(value: &v)
        if let v = v {
          if hadOneofValue {try decoder.handleConflictingOneOf()}
          self.format = .underline(v)
        }
      }()
      case 6: try {
        var v: Protocol_Chat_V1_Format.Monospace?
        var hadOneofValue = false
        if let current = self.format {
          hadOneofValue = true
          if case .monospace(let m) = current {v = m}
        }
        try decoder.decodeSingularMessageField(value: &v)
        if let v = v {
          if hadOneofValue {try decoder.handleConflictingOneOf()}
          self.format = .monospace(v)
        }
      }()
      case 7: try {
        var v: Protocol_Chat_V1_Format.Superscript?
        var hadOneofValue = false
        if let current = self.format {
          hadOneofValue = true
          if case .superscript(let m) = current {v = m}
        }
        try decoder.decodeSingularMessageField(value: &v)
        if let v = v {
          if hadOneofValue {try decoder.handleConflictingOneOf()}
          self.format = .superscript(v)
        }
      }()
      case 8: try {
        var v: Protocol_Chat_V1_Format.Subscript?
        var hadOneofValue = false
        if let current = self.format {
          hadOneofValue = true
          if case .subscript(let m) = current {v = m}
        }
        try decoder.decodeSingularMessageField(value: &v)
        if let v = v {
          if hadOneofValue {try decoder.handleConflictingOneOf()}
          self.format = .subscript(v)
        }
      }()
      case 9: try {
        var v: Protocol_Chat_V1_Format.CodeBlock?
        var hadOneofValue = false
        if let current = self.format {
          hadOneofValue = true
          if case .codeBlock(let m) = current {v = m}
        }
        try decoder.decodeSingularMessageField(value: &v)
        if let v = v {
          if hadOneofValue {try decoder.handleConflictingOneOf()}
          self.format = .codeBlock(v)
        }
      }()
      case 10: try {
        var v: Protocol_Chat_V1_Format.UserMention?
        var hadOneofValue = false
        if let current = self.format {
          hadOneofValue = true
          if case .userMention(let m) = current {v = m}
        }
        try decoder.decodeSingularMessageField(value: &v)
        if let v = v {
          if hadOneofValue {try decoder.handleConflictingOneOf()}
          self.format = .userMention(v)
        }
      }()
      case 11: try {
        var v: Protocol_Chat_V1_Format.RoleMention?
        var hadOneofValue = false
        if let current = self.format {
          hadOneofValue = true
          if case .roleMention(let m) = current {v = m}
        }
        try decoder.decodeSingularMessageField(value: &v)
        if let v = v {
          if hadOneofValue {try decoder.handleConflictingOneOf()}
          self.format = .roleMention(v)
        }
      }()
      case 12: try {
        var v: Protocol_Chat_V1_Format.ChannelMention?
        var hadOneofValue = false
        if let current = self.format {
          hadOneofValue = true
          if case .channelMention(let m) = current {v = m}
        }
        try decoder.decodeSingularMessageField(value: &v)
        if let v = v {
          if hadOneofValue {try decoder.handleConflictingOneOf()}
          self.format = .channelMention(v)
        }
      }()
      case 13: try {
        var v: Protocol_Chat_V1_Format.GuildMention?
        var hadOneofValue = false
        if let current = self.format {
          hadOneofValue = true
          if case .guildMention(let m) = current {v = m}
        }
        try decoder.decodeSingularMessageField(value: &v)
        if let v = v {
          if hadOneofValue {try decoder.handleConflictingOneOf()}
          self.format = .guildMention(v)
        }
      }()
      case 14: try {
        var v: Protocol_Chat_V1_Format.Emoji?
        var hadOneofValue = false
        if let current = self.format {
          hadOneofValue = true
          if case .emoji(let m) = current {v = m}
        }
        try decoder.decodeSingularMessageField(value: &v)
        if let v = v {
          if hadOneofValue {try decoder.handleConflictingOneOf()}
          self.format = .emoji(v)
        }
      }()
      case 15: try {
        var v: Protocol_Chat_V1_Format.Color?
        var hadOneofValue = false
        if let current = self.format {
          hadOneofValue = true
          if case .color(let m) = current {v = m}
        }
        try decoder.decodeSingularMessageField(value: &v)
        if let v = v {
          if hadOneofValue {try decoder.handleConflictingOneOf()}
          self.format = .color(v)
        }
      }()
      case 16: try {
        var v: Protocol_Chat_V1_Format.Localization?
        var hadOneofValue = false
        if let current = self.format {
          hadOneofValue = true
          if case .localization(let m) = current {v = m}
        }
        try decoder.decodeSingularMessageField(value: &v)
        if let v = v {
          if hadOneofValue {try decoder.handleConflictingOneOf()}
          self.format = .localization(v)
        }
      }()
      default: break
      }
    }
  }

  func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if self.start != 0 {
      try visitor.visitSingularUInt32Field(value: self.start, fieldNumber: 1)
    }
    if self.length != 0 {
      try visitor.visitSingularUInt32Field(value: self.length, fieldNumber: 2)
    }
    // The use of inline closures is to circumvent an issue where the compiler
    // allocates stack space for every case branch when no optimizations are
    // enabled. https://github.com/apple/swift-protobuf/issues/1034
    switch self.format {
    case .bold?: try {
      guard case .bold(let v)? = self.format else { preconditionFailure() }
      try visitor.visitSingularMessageField(value: v, fieldNumber: 3)
    }()
    case .italic?: try {
      guard case .italic(let v)? = self.format else { preconditionFailure() }
      try visitor.visitSingularMessageField(value: v, fieldNumber: 4)
    }()
    case .underline?: try {
      guard case .underline(let v)? = self.format else { preconditionFailure() }
      try visitor.visitSingularMessageField(value: v, fieldNumber: 5)
    }()
    case .monospace?: try {
      guard case .monospace(let v)? = self.format else { preconditionFailure() }
      try visitor.visitSingularMessageField(value: v, fieldNumber: 6)
    }()
    case .superscript?: try {
      guard case .superscript(let v)? = self.format else { preconditionFailure() }
      try visitor.visitSingularMessageField(value: v, fieldNumber: 7)
    }()
    case .subscript?: try {
      guard case .subscript(let v)? = self.format else { preconditionFailure() }
      try visitor.visitSingularMessageField(value: v, fieldNumber: 8)
    }()
    case .codeBlock?: try {
      guard case .codeBlock(let v)? = self.format else { preconditionFailure() }
      try visitor.visitSingularMessageField(value: v, fieldNumber: 9)
    }()
    case .userMention?: try {
      guard case .userMention(let v)? = self.format else { preconditionFailure() }
      try visitor.visitSingularMessageField(value: v, fieldNumber: 10)
    }()
    case .roleMention?: try {
      guard case .roleMention(let v)? = self.format else { preconditionFailure() }
      try visitor.visitSingularMessageField(value: v, fieldNumber: 11)
    }()
    case .channelMention?: try {
      guard case .channelMention(let v)? = self.format else { preconditionFailure() }
      try visitor.visitSingularMessageField(value: v, fieldNumber: 12)
    }()
    case .guildMention?: try {
      guard case .guildMention(let v)? = self.format else { preconditionFailure() }
      try visitor.visitSingularMessageField(value: v, fieldNumber: 13)
    }()
    case .emoji?: try {
      guard case .emoji(let v)? = self.format else { preconditionFailure() }
      try visitor.visitSingularMessageField(value: v, fieldNumber: 14)
    }()
    case .color?: try {
      guard case .color(let v)? = self.format else { preconditionFailure() }
      try visitor.visitSingularMessageField(value: v, fieldNumber: 15)
    }()
    case .localization?: try {
      guard case .localization(let v)? = self.format else { preconditionFailure() }
      try visitor.visitSingularMessageField(value: v, fieldNumber: 16)
    }()
    case nil: break
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  static func ==(lhs: Protocol_Chat_V1_Format, rhs: Protocol_Chat_V1_Format) -> Bool {
    if lhs.start != rhs.start {return false}
    if lhs.length != rhs.length {return false}
    if lhs.format != rhs.format {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Protocol_Chat_V1_Format.Bold: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static let protoMessageName: String = Protocol_Chat_V1_Format.protoMessageName + ".Bold"
  static let _protobuf_nameMap = SwiftProtobuf._NameMap()

  mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let _ = try decoder.nextFieldNumber() {
    }
  }

  func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    try unknownFields.traverse(visitor: &visitor)
  }

  static func ==(lhs: Protocol_Chat_V1_Format.Bold, rhs: Protocol_Chat_V1_Format.Bold) -> Bool {
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Protocol_Chat_V1_Format.Italic: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static let protoMessageName: String = Protocol_Chat_V1_Format.protoMessageName + ".Italic"
  static let _protobuf_nameMap = SwiftProtobuf._NameMap()

  mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let _ = try decoder.nextFieldNumber() {
    }
  }

  func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    try unknownFields.traverse(visitor: &visitor)
  }

  static func ==(lhs: Protocol_Chat_V1_Format.Italic, rhs: Protocol_Chat_V1_Format.Italic) -> Bool {
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Protocol_Chat_V1_Format.Underline: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static let protoMessageName: String = Protocol_Chat_V1_Format.protoMessageName + ".Underline"
  static let _protobuf_nameMap = SwiftProtobuf._NameMap()

  mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let _ = try decoder.nextFieldNumber() {
    }
  }

  func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    try unknownFields.traverse(visitor: &visitor)
  }

  static func ==(lhs: Protocol_Chat_V1_Format.Underline, rhs: Protocol_Chat_V1_Format.Underline) -> Bool {
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Protocol_Chat_V1_Format.Monospace: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static let protoMessageName: String = Protocol_Chat_V1_Format.protoMessageName + ".Monospace"
  static let _protobuf_nameMap = SwiftProtobuf._NameMap()

  mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let _ = try decoder.nextFieldNumber() {
    }
  }

  func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    try unknownFields.traverse(visitor: &visitor)
  }

  static func ==(lhs: Protocol_Chat_V1_Format.Monospace, rhs: Protocol_Chat_V1_Format.Monospace) -> Bool {
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Protocol_Chat_V1_Format.Superscript: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static let protoMessageName: String = Protocol_Chat_V1_Format.protoMessageName + ".Superscript"
  static let _protobuf_nameMap = SwiftProtobuf._NameMap()

  mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let _ = try decoder.nextFieldNumber() {
    }
  }

  func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    try unknownFields.traverse(visitor: &visitor)
  }

  static func ==(lhs: Protocol_Chat_V1_Format.Superscript, rhs: Protocol_Chat_V1_Format.Superscript) -> Bool {
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Protocol_Chat_V1_Format.Subscript: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static let protoMessageName: String = Protocol_Chat_V1_Format.protoMessageName + ".Subscript"
  static let _protobuf_nameMap = SwiftProtobuf._NameMap()

  mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let _ = try decoder.nextFieldNumber() {
    }
  }

  func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    try unknownFields.traverse(visitor: &visitor)
  }

  static func ==(lhs: Protocol_Chat_V1_Format.Subscript, rhs: Protocol_Chat_V1_Format.Subscript) -> Bool {
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Protocol_Chat_V1_Format.CodeBlock: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static let protoMessageName: String = Protocol_Chat_V1_Format.protoMessageName + ".CodeBlock"
  static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "language"),
  ]

  mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularStringField(value: &self.language) }()
      default: break
      }
    }
  }

  func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if !self.language.isEmpty {
      try visitor.visitSingularStringField(value: self.language, fieldNumber: 1)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  static func ==(lhs: Protocol_Chat_V1_Format.CodeBlock, rhs: Protocol_Chat_V1_Format.CodeBlock) -> Bool {
    if lhs.language != rhs.language {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Protocol_Chat_V1_Format.UserMention: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static let protoMessageName: String = Protocol_Chat_V1_Format.protoMessageName + ".UserMention"
  static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .standard(proto: "user_id"),
  ]

  mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularUInt64Field(value: &self.userID) }()
      default: break
      }
    }
  }

  func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if self.userID != 0 {
      try visitor.visitSingularUInt64Field(value: self.userID, fieldNumber: 1)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  static func ==(lhs: Protocol_Chat_V1_Format.UserMention, rhs: Protocol_Chat_V1_Format.UserMention) -> Bool {
    if lhs.userID != rhs.userID {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Protocol_Chat_V1_Format.RoleMention: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static let protoMessageName: String = Protocol_Chat_V1_Format.protoMessageName + ".RoleMention"
  static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .standard(proto: "role_id"),
  ]

  mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularUInt64Field(value: &self.roleID) }()
      default: break
      }
    }
  }

  func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if self.roleID != 0 {
      try visitor.visitSingularUInt64Field(value: self.roleID, fieldNumber: 1)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  static func ==(lhs: Protocol_Chat_V1_Format.RoleMention, rhs: Protocol_Chat_V1_Format.RoleMention) -> Bool {
    if lhs.roleID != rhs.roleID {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Protocol_Chat_V1_Format.ChannelMention: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static let protoMessageName: String = Protocol_Chat_V1_Format.protoMessageName + ".ChannelMention"
  static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .standard(proto: "channel_id"),
  ]

  mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularUInt64Field(value: &self.channelID) }()
      default: break
      }
    }
  }

  func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if self.channelID != 0 {
      try visitor.visitSingularUInt64Field(value: self.channelID, fieldNumber: 1)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  static func ==(lhs: Protocol_Chat_V1_Format.ChannelMention, rhs: Protocol_Chat_V1_Format.ChannelMention) -> Bool {
    if lhs.channelID != rhs.channelID {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Protocol_Chat_V1_Format.GuildMention: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static let protoMessageName: String = Protocol_Chat_V1_Format.protoMessageName + ".GuildMention"
  static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .standard(proto: "guild_id"),
    2: .same(proto: "homeserver"),
  ]

  mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularUInt64Field(value: &self.guildID) }()
      case 2: try { try decoder.decodeSingularStringField(value: &self.homeserver) }()
      default: break
      }
    }
  }

  func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if self.guildID != 0 {
      try visitor.visitSingularUInt64Field(value: self.guildID, fieldNumber: 1)
    }
    if !self.homeserver.isEmpty {
      try visitor.visitSingularStringField(value: self.homeserver, fieldNumber: 2)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  static func ==(lhs: Protocol_Chat_V1_Format.GuildMention, rhs: Protocol_Chat_V1_Format.GuildMention) -> Bool {
    if lhs.guildID != rhs.guildID {return false}
    if lhs.homeserver != rhs.homeserver {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Protocol_Chat_V1_Format.Emoji: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static let protoMessageName: String = Protocol_Chat_V1_Format.protoMessageName + ".Emoji"
  static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .standard(proto: "image_hmc"),
    2: .standard(proto: "pack_id"),
  ]

  mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularStringField(value: &self.imageHmc) }()
      case 2: try { try decoder.decodeSingularUInt64Field(value: &self.packID) }()
      default: break
      }
    }
  }

  func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if !self.imageHmc.isEmpty {
      try visitor.visitSingularStringField(value: self.imageHmc, fieldNumber: 1)
    }
    if self.packID != 0 {
      try visitor.visitSingularUInt64Field(value: self.packID, fieldNumber: 2)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  static func ==(lhs: Protocol_Chat_V1_Format.Emoji, rhs: Protocol_Chat_V1_Format.Emoji) -> Bool {
    if lhs.imageHmc != rhs.imageHmc {return false}
    if lhs.packID != rhs.packID {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Protocol_Chat_V1_Format.Color: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static let protoMessageName: String = Protocol_Chat_V1_Format.protoMessageName + ".Color"
  static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "kind"),
  ]

  mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularEnumField(value: &self.kind) }()
      default: break
      }
    }
  }

  func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if self.kind != .dimUnspecified {
      try visitor.visitSingularEnumField(value: self.kind, fieldNumber: 1)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  static func ==(lhs: Protocol_Chat_V1_Format.Color, rhs: Protocol_Chat_V1_Format.Color) -> Bool {
    if lhs.kind != rhs.kind {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Protocol_Chat_V1_Format.Color.Kind: SwiftProtobuf._ProtoNameProviding {
  static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    0: .same(proto: "KIND_DIM_UNSPECIFIED"),
    1: .same(proto: "KIND_BRIGHT"),
    2: .same(proto: "KIND_NEGATIVE"),
    3: .same(proto: "KIND_POSITIVE"),
    4: .same(proto: "KIND_INFO"),
    5: .same(proto: "KIND_WARNING"),
  ]
}

extension Protocol_Chat_V1_Format.Localization: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static let protoMessageName: String = Protocol_Chat_V1_Format.protoMessageName + ".Localization"
  static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .standard(proto: "i18n_code"),
  ]

  mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularStringField(value: &self.i18NCode) }()
      default: break
      }
    }
  }

  func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if !self.i18NCode.isEmpty {
      try visitor.visitSingularStringField(value: self.i18NCode, fieldNumber: 1)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  static func ==(lhs: Protocol_Chat_V1_Format.Localization, rhs: Protocol_Chat_V1_Format.Localization) -> Bool {
    if lhs.i18NCode != rhs.i18NCode {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Protocol_Chat_V1_FormattedText: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static let protoMessageName: String = _protobuf_package + ".FormattedText"
  static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "text"),
    2: .same(proto: "format"),
  ]

  mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularStringField(value: &self.text) }()
      case 2: try { try decoder.decodeRepeatedMessageField(value: &self.format) }()
      default: break
      }
    }
  }

  func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if !self.text.isEmpty {
      try visitor.visitSingularStringField(value: self.text, fieldNumber: 1)
    }
    if !self.format.isEmpty {
      try visitor.visitRepeatedMessageField(value: self.format, fieldNumber: 2)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  static func ==(lhs: Protocol_Chat_V1_FormattedText, rhs: Protocol_Chat_V1_FormattedText) -> Bool {
    if lhs.text != rhs.text {return false}
    if lhs.format != rhs.format {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Protocol_Chat_V1_Message: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static let protoMessageName: String = _protobuf_package + ".Message"
  static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "metadata"),
    2: .same(proto: "overrides"),
    3: .standard(proto: "author_id"),
    4: .standard(proto: "created_at"),
    5: .standard(proto: "edited_at"),
    6: .standard(proto: "in_reply_to"),
    7: .same(proto: "content"),
    8: .same(proto: "reactions"),
  ]

  mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularMessageField(value: &self._metadata) }()
      case 2: try { try decoder.decodeSingularMessageField(value: &self._overrides) }()
      case 3: try { try decoder.decodeSingularUInt64Field(value: &self.authorID) }()
      case 4: try { try decoder.decodeSingularUInt64Field(value: &self.createdAt) }()
      case 5: try { try decoder.decodeSingularUInt64Field(value: &self._editedAt) }()
      case 6: try { try decoder.decodeSingularUInt64Field(value: &self._inReplyTo) }()
      case 7: try { try decoder.decodeSingularMessageField(value: &self._content) }()
      case 8: try { try decoder.decodeRepeatedMessageField(value: &self.reactions) }()
      default: break
      }
    }
  }

  func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if let v = self._metadata {
      try visitor.visitSingularMessageField(value: v, fieldNumber: 1)
    }
    if let v = self._overrides {
      try visitor.visitSingularMessageField(value: v, fieldNumber: 2)
    }
    if self.authorID != 0 {
      try visitor.visitSingularUInt64Field(value: self.authorID, fieldNumber: 3)
    }
    if self.createdAt != 0 {
      try visitor.visitSingularUInt64Field(value: self.createdAt, fieldNumber: 4)
    }
    if let v = self._editedAt {
      try visitor.visitSingularUInt64Field(value: v, fieldNumber: 5)
    }
    if let v = self._inReplyTo {
      try visitor.visitSingularUInt64Field(value: v, fieldNumber: 6)
    }
    if let v = self._content {
      try visitor.visitSingularMessageField(value: v, fieldNumber: 7)
    }
    if !self.reactions.isEmpty {
      try visitor.visitRepeatedMessageField(value: self.reactions, fieldNumber: 8)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  static func ==(lhs: Protocol_Chat_V1_Message, rhs: Protocol_Chat_V1_Message) -> Bool {
    if lhs._metadata != rhs._metadata {return false}
    if lhs._overrides != rhs._overrides {return false}
    if lhs.authorID != rhs.authorID {return false}
    if lhs.createdAt != rhs.createdAt {return false}
    if lhs._editedAt != rhs._editedAt {return false}
    if lhs._inReplyTo != rhs._inReplyTo {return false}
    if lhs._content != rhs._content {return false}
    if lhs.reactions != rhs.reactions {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Protocol_Chat_V1_MessageWithId: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static let protoMessageName: String = _protobuf_package + ".MessageWithId"
  static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .standard(proto: "message_id"),
    2: .same(proto: "message"),
  ]

  mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularUInt64Field(value: &self.messageID) }()
      case 2: try { try decoder.decodeSingularMessageField(value: &self._message) }()
      default: break
      }
    }
  }

  func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if self.messageID != 0 {
      try visitor.visitSingularUInt64Field(value: self.messageID, fieldNumber: 1)
    }
    if let v = self._message {
      try visitor.visitSingularMessageField(value: v, fieldNumber: 2)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  static func ==(lhs: Protocol_Chat_V1_MessageWithId, rhs: Protocol_Chat_V1_MessageWithId) -> Bool {
    if lhs.messageID != rhs.messageID {return false}
    if lhs._message != rhs._message {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Protocol_Chat_V1_GetChannelMessagesRequest: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static let protoMessageName: String = _protobuf_package + ".GetChannelMessagesRequest"
  static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .standard(proto: "guild_id"),
    2: .standard(proto: "channel_id"),
    3: .standard(proto: "message_id"),
    4: .same(proto: "direction"),
    5: .same(proto: "count"),
  ]

  mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularUInt64Field(value: &self.guildID) }()
      case 2: try { try decoder.decodeSingularUInt64Field(value: &self.channelID) }()
      case 3: try { try decoder.decodeSingularUInt64Field(value: &self._messageID) }()
      case 4: try { try decoder.decodeSingularEnumField(value: &self._direction) }()
      case 5: try { try decoder.decodeSingularUInt32Field(value: &self._count) }()
      default: break
      }
    }
  }

  func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if self.guildID != 0 {
      try visitor.visitSingularUInt64Field(value: self.guildID, fieldNumber: 1)
    }
    if self.channelID != 0 {
      try visitor.visitSingularUInt64Field(value: self.channelID, fieldNumber: 2)
    }
    if let v = self._messageID {
      try visitor.visitSingularUInt64Field(value: v, fieldNumber: 3)
    }
    if let v = self._direction {
      try visitor.visitSingularEnumField(value: v, fieldNumber: 4)
    }
    if let v = self._count {
      try visitor.visitSingularUInt32Field(value: v, fieldNumber: 5)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  static func ==(lhs: Protocol_Chat_V1_GetChannelMessagesRequest, rhs: Protocol_Chat_V1_GetChannelMessagesRequest) -> Bool {
    if lhs.guildID != rhs.guildID {return false}
    if lhs.channelID != rhs.channelID {return false}
    if lhs._messageID != rhs._messageID {return false}
    if lhs._direction != rhs._direction {return false}
    if lhs._count != rhs._count {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Protocol_Chat_V1_GetChannelMessagesRequest.Direction: SwiftProtobuf._ProtoNameProviding {
  static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    0: .same(proto: "DIRECTION_BEFORE_UNSPECIFIED"),
    1: .same(proto: "DIRECTION_AROUND"),
    2: .same(proto: "DIRECTION_AFTER"),
  ]
}

extension Protocol_Chat_V1_GetChannelMessagesResponse: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static let protoMessageName: String = _protobuf_package + ".GetChannelMessagesResponse"
  static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .standard(proto: "reached_top"),
    2: .standard(proto: "reached_bottom"),
    3: .same(proto: "messages"),
  ]

  mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularBoolField(value: &self.reachedTop) }()
      case 2: try { try decoder.decodeSingularBoolField(value: &self.reachedBottom) }()
      case 3: try { try decoder.decodeRepeatedMessageField(value: &self.messages) }()
      default: break
      }
    }
  }

  func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if self.reachedTop != false {
      try visitor.visitSingularBoolField(value: self.reachedTop, fieldNumber: 1)
    }
    if self.reachedBottom != false {
      try visitor.visitSingularBoolField(value: self.reachedBottom, fieldNumber: 2)
    }
    if !self.messages.isEmpty {
      try visitor.visitRepeatedMessageField(value: self.messages, fieldNumber: 3)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  static func ==(lhs: Protocol_Chat_V1_GetChannelMessagesResponse, rhs: Protocol_Chat_V1_GetChannelMessagesResponse) -> Bool {
    if lhs.reachedTop != rhs.reachedTop {return false}
    if lhs.reachedBottom != rhs.reachedBottom {return false}
    if lhs.messages != rhs.messages {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Protocol_Chat_V1_GetMessageRequest: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static let protoMessageName: String = _protobuf_package + ".GetMessageRequest"
  static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .standard(proto: "guild_id"),
    2: .standard(proto: "channel_id"),
    3: .standard(proto: "message_id"),
  ]

  mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularUInt64Field(value: &self.guildID) }()
      case 2: try { try decoder.decodeSingularUInt64Field(value: &self.channelID) }()
      case 3: try { try decoder.decodeSingularUInt64Field(value: &self.messageID) }()
      default: break
      }
    }
  }

  func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if self.guildID != 0 {
      try visitor.visitSingularUInt64Field(value: self.guildID, fieldNumber: 1)
    }
    if self.channelID != 0 {
      try visitor.visitSingularUInt64Field(value: self.channelID, fieldNumber: 2)
    }
    if self.messageID != 0 {
      try visitor.visitSingularUInt64Field(value: self.messageID, fieldNumber: 3)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  static func ==(lhs: Protocol_Chat_V1_GetMessageRequest, rhs: Protocol_Chat_V1_GetMessageRequest) -> Bool {
    if lhs.guildID != rhs.guildID {return false}
    if lhs.channelID != rhs.channelID {return false}
    if lhs.messageID != rhs.messageID {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Protocol_Chat_V1_GetMessageResponse: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static let protoMessageName: String = _protobuf_package + ".GetMessageResponse"
  static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "message"),
  ]

  mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularMessageField(value: &self._message) }()
      default: break
      }
    }
  }

  func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if let v = self._message {
      try visitor.visitSingularMessageField(value: v, fieldNumber: 1)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  static func ==(lhs: Protocol_Chat_V1_GetMessageResponse, rhs: Protocol_Chat_V1_GetMessageResponse) -> Bool {
    if lhs._message != rhs._message {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Protocol_Chat_V1_DeleteMessageRequest: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static let protoMessageName: String = _protobuf_package + ".DeleteMessageRequest"
  static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .standard(proto: "guild_id"),
    2: .standard(proto: "channel_id"),
    3: .standard(proto: "message_id"),
  ]

  mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularUInt64Field(value: &self.guildID) }()
      case 2: try { try decoder.decodeSingularUInt64Field(value: &self.channelID) }()
      case 3: try { try decoder.decodeSingularUInt64Field(value: &self.messageID) }()
      default: break
      }
    }
  }

  func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if self.guildID != 0 {
      try visitor.visitSingularUInt64Field(value: self.guildID, fieldNumber: 1)
    }
    if self.channelID != 0 {
      try visitor.visitSingularUInt64Field(value: self.channelID, fieldNumber: 2)
    }
    if self.messageID != 0 {
      try visitor.visitSingularUInt64Field(value: self.messageID, fieldNumber: 3)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  static func ==(lhs: Protocol_Chat_V1_DeleteMessageRequest, rhs: Protocol_Chat_V1_DeleteMessageRequest) -> Bool {
    if lhs.guildID != rhs.guildID {return false}
    if lhs.channelID != rhs.channelID {return false}
    if lhs.messageID != rhs.messageID {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Protocol_Chat_V1_DeleteMessageResponse: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static let protoMessageName: String = _protobuf_package + ".DeleteMessageResponse"
  static let _protobuf_nameMap = SwiftProtobuf._NameMap()

  mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let _ = try decoder.nextFieldNumber() {
    }
  }

  func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    try unknownFields.traverse(visitor: &visitor)
  }

  static func ==(lhs: Protocol_Chat_V1_DeleteMessageResponse, rhs: Protocol_Chat_V1_DeleteMessageResponse) -> Bool {
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Protocol_Chat_V1_TriggerActionRequest: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static let protoMessageName: String = _protobuf_package + ".TriggerActionRequest"
  static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .standard(proto: "guild_id"),
    2: .standard(proto: "channel_id"),
    3: .standard(proto: "message_id"),
    4: .same(proto: "payload"),
  ]

  mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularUInt64Field(value: &self.guildID) }()
      case 2: try { try decoder.decodeSingularUInt64Field(value: &self.channelID) }()
      case 3: try { try decoder.decodeSingularUInt64Field(value: &self.messageID) }()
      case 4: try { try decoder.decodeSingularMessageField(value: &self._payload) }()
      default: break
      }
    }
  }

  func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if self.guildID != 0 {
      try visitor.visitSingularUInt64Field(value: self.guildID, fieldNumber: 1)
    }
    if self.channelID != 0 {
      try visitor.visitSingularUInt64Field(value: self.channelID, fieldNumber: 2)
    }
    if self.messageID != 0 {
      try visitor.visitSingularUInt64Field(value: self.messageID, fieldNumber: 3)
    }
    if let v = self._payload {
      try visitor.visitSingularMessageField(value: v, fieldNumber: 4)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  static func ==(lhs: Protocol_Chat_V1_TriggerActionRequest, rhs: Protocol_Chat_V1_TriggerActionRequest) -> Bool {
    if lhs.guildID != rhs.guildID {return false}
    if lhs.channelID != rhs.channelID {return false}
    if lhs.messageID != rhs.messageID {return false}
    if lhs._payload != rhs._payload {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Protocol_Chat_V1_TriggerActionResponse: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static let protoMessageName: String = _protobuf_package + ".TriggerActionResponse"
  static let _protobuf_nameMap = SwiftProtobuf._NameMap()

  mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let _ = try decoder.nextFieldNumber() {
    }
  }

  func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    try unknownFields.traverse(visitor: &visitor)
  }

  static func ==(lhs: Protocol_Chat_V1_TriggerActionResponse, rhs: Protocol_Chat_V1_TriggerActionResponse) -> Bool {
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Protocol_Chat_V1_SendMessageRequest: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static let protoMessageName: String = _protobuf_package + ".SendMessageRequest"
  static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .standard(proto: "guild_id"),
    2: .standard(proto: "channel_id"),
    3: .same(proto: "content"),
    4: .standard(proto: "echo_id"),
    6: .same(proto: "overrides"),
    7: .standard(proto: "in_reply_to"),
    5: .same(proto: "metadata"),
  ]

  mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularUInt64Field(value: &self.guildID) }()
      case 2: try { try decoder.decodeSingularUInt64Field(value: &self.channelID) }()
      case 3: try { try decoder.decodeSingularMessageField(value: &self._content) }()
      case 4: try { try decoder.decodeSingularUInt64Field(value: &self._echoID) }()
      case 5: try { try decoder.decodeSingularMessageField(value: &self._metadata) }()
      case 6: try { try decoder.decodeSingularMessageField(value: &self._overrides) }()
      case 7: try { try decoder.decodeSingularUInt64Field(value: &self._inReplyTo) }()
      default: break
      }
    }
  }

  func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if self.guildID != 0 {
      try visitor.visitSingularUInt64Field(value: self.guildID, fieldNumber: 1)
    }
    if self.channelID != 0 {
      try visitor.visitSingularUInt64Field(value: self.channelID, fieldNumber: 2)
    }
    if let v = self._content {
      try visitor.visitSingularMessageField(value: v, fieldNumber: 3)
    }
    if let v = self._echoID {
      try visitor.visitSingularUInt64Field(value: v, fieldNumber: 4)
    }
    if let v = self._metadata {
      try visitor.visitSingularMessageField(value: v, fieldNumber: 5)
    }
    if let v = self._overrides {
      try visitor.visitSingularMessageField(value: v, fieldNumber: 6)
    }
    if let v = self._inReplyTo {
      try visitor.visitSingularUInt64Field(value: v, fieldNumber: 7)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  static func ==(lhs: Protocol_Chat_V1_SendMessageRequest, rhs: Protocol_Chat_V1_SendMessageRequest) -> Bool {
    if lhs.guildID != rhs.guildID {return false}
    if lhs.channelID != rhs.channelID {return false}
    if lhs._content != rhs._content {return false}
    if lhs._echoID != rhs._echoID {return false}
    if lhs._overrides != rhs._overrides {return false}
    if lhs._inReplyTo != rhs._inReplyTo {return false}
    if lhs._metadata != rhs._metadata {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Protocol_Chat_V1_SendMessageResponse: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static let protoMessageName: String = _protobuf_package + ".SendMessageResponse"
  static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .standard(proto: "message_id"),
  ]

  mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularUInt64Field(value: &self.messageID) }()
      default: break
      }
    }
  }

  func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if self.messageID != 0 {
      try visitor.visitSingularUInt64Field(value: self.messageID, fieldNumber: 1)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  static func ==(lhs: Protocol_Chat_V1_SendMessageResponse, rhs: Protocol_Chat_V1_SendMessageResponse) -> Bool {
    if lhs.messageID != rhs.messageID {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Protocol_Chat_V1_UpdateMessageTextRequest: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static let protoMessageName: String = _protobuf_package + ".UpdateMessageTextRequest"
  static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .standard(proto: "guild_id"),
    2: .standard(proto: "channel_id"),
    3: .standard(proto: "message_id"),
    4: .standard(proto: "new_content"),
  ]

  mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularUInt64Field(value: &self.guildID) }()
      case 2: try { try decoder.decodeSingularUInt64Field(value: &self.channelID) }()
      case 3: try { try decoder.decodeSingularUInt64Field(value: &self.messageID) }()
      case 4: try { try decoder.decodeSingularMessageField(value: &self._newContent) }()
      default: break
      }
    }
  }

  func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if self.guildID != 0 {
      try visitor.visitSingularUInt64Field(value: self.guildID, fieldNumber: 1)
    }
    if self.channelID != 0 {
      try visitor.visitSingularUInt64Field(value: self.channelID, fieldNumber: 2)
    }
    if self.messageID != 0 {
      try visitor.visitSingularUInt64Field(value: self.messageID, fieldNumber: 3)
    }
    if let v = self._newContent {
      try visitor.visitSingularMessageField(value: v, fieldNumber: 4)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  static func ==(lhs: Protocol_Chat_V1_UpdateMessageTextRequest, rhs: Protocol_Chat_V1_UpdateMessageTextRequest) -> Bool {
    if lhs.guildID != rhs.guildID {return false}
    if lhs.channelID != rhs.channelID {return false}
    if lhs.messageID != rhs.messageID {return false}
    if lhs._newContent != rhs._newContent {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Protocol_Chat_V1_UpdateMessageTextResponse: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static let protoMessageName: String = _protobuf_package + ".UpdateMessageTextResponse"
  static let _protobuf_nameMap = SwiftProtobuf._NameMap()

  mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let _ = try decoder.nextFieldNumber() {
    }
  }

  func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    try unknownFields.traverse(visitor: &visitor)
  }

  static func ==(lhs: Protocol_Chat_V1_UpdateMessageTextResponse, rhs: Protocol_Chat_V1_UpdateMessageTextResponse) -> Bool {
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Protocol_Chat_V1_PinMessageRequest: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static let protoMessageName: String = _protobuf_package + ".PinMessageRequest"
  static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .standard(proto: "guild_id"),
    2: .standard(proto: "channel_id"),
    3: .standard(proto: "message_id"),
  ]

  mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularUInt64Field(value: &self.guildID) }()
      case 2: try { try decoder.decodeSingularUInt64Field(value: &self.channelID) }()
      case 3: try { try decoder.decodeSingularUInt64Field(value: &self.messageID) }()
      default: break
      }
    }
  }

  func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if self.guildID != 0 {
      try visitor.visitSingularUInt64Field(value: self.guildID, fieldNumber: 1)
    }
    if self.channelID != 0 {
      try visitor.visitSingularUInt64Field(value: self.channelID, fieldNumber: 2)
    }
    if self.messageID != 0 {
      try visitor.visitSingularUInt64Field(value: self.messageID, fieldNumber: 3)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  static func ==(lhs: Protocol_Chat_V1_PinMessageRequest, rhs: Protocol_Chat_V1_PinMessageRequest) -> Bool {
    if lhs.guildID != rhs.guildID {return false}
    if lhs.channelID != rhs.channelID {return false}
    if lhs.messageID != rhs.messageID {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Protocol_Chat_V1_PinMessageResponse: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static let protoMessageName: String = _protobuf_package + ".PinMessageResponse"
  static let _protobuf_nameMap = SwiftProtobuf._NameMap()

  mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let _ = try decoder.nextFieldNumber() {
    }
  }

  func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    try unknownFields.traverse(visitor: &visitor)
  }

  static func ==(lhs: Protocol_Chat_V1_PinMessageResponse, rhs: Protocol_Chat_V1_PinMessageResponse) -> Bool {
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Protocol_Chat_V1_UnpinMessageRequest: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static let protoMessageName: String = _protobuf_package + ".UnpinMessageRequest"
  static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .standard(proto: "guild_id"),
    2: .standard(proto: "channel_id"),
    3: .standard(proto: "message_id"),
  ]

  mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularUInt64Field(value: &self.guildID) }()
      case 2: try { try decoder.decodeSingularUInt64Field(value: &self.channelID) }()
      case 3: try { try decoder.decodeSingularUInt64Field(value: &self.messageID) }()
      default: break
      }
    }
  }

  func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if self.guildID != 0 {
      try visitor.visitSingularUInt64Field(value: self.guildID, fieldNumber: 1)
    }
    if self.channelID != 0 {
      try visitor.visitSingularUInt64Field(value: self.channelID, fieldNumber: 2)
    }
    if self.messageID != 0 {
      try visitor.visitSingularUInt64Field(value: self.messageID, fieldNumber: 3)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  static func ==(lhs: Protocol_Chat_V1_UnpinMessageRequest, rhs: Protocol_Chat_V1_UnpinMessageRequest) -> Bool {
    if lhs.guildID != rhs.guildID {return false}
    if lhs.channelID != rhs.channelID {return false}
    if lhs.messageID != rhs.messageID {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Protocol_Chat_V1_UnpinMessageResponse: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static let protoMessageName: String = _protobuf_package + ".UnpinMessageResponse"
  static let _protobuf_nameMap = SwiftProtobuf._NameMap()

  mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let _ = try decoder.nextFieldNumber() {
    }
  }

  func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    try unknownFields.traverse(visitor: &visitor)
  }

  static func ==(lhs: Protocol_Chat_V1_UnpinMessageResponse, rhs: Protocol_Chat_V1_UnpinMessageResponse) -> Bool {
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Protocol_Chat_V1_GetPinnedMessagesRequest: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static let protoMessageName: String = _protobuf_package + ".GetPinnedMessagesRequest"
  static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .standard(proto: "guild_id"),
    2: .standard(proto: "channel_id"),
  ]

  mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularUInt64Field(value: &self.guildID) }()
      case 2: try { try decoder.decodeSingularUInt64Field(value: &self.channelID) }()
      default: break
      }
    }
  }

  func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if self.guildID != 0 {
      try visitor.visitSingularUInt64Field(value: self.guildID, fieldNumber: 1)
    }
    if self.channelID != 0 {
      try visitor.visitSingularUInt64Field(value: self.channelID, fieldNumber: 2)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  static func ==(lhs: Protocol_Chat_V1_GetPinnedMessagesRequest, rhs: Protocol_Chat_V1_GetPinnedMessagesRequest) -> Bool {
    if lhs.guildID != rhs.guildID {return false}
    if lhs.channelID != rhs.channelID {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Protocol_Chat_V1_GetPinnedMessagesResponse: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static let protoMessageName: String = _protobuf_package + ".GetPinnedMessagesResponse"
  static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .standard(proto: "pinned_message_ids"),
  ]

  mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeRepeatedUInt64Field(value: &self.pinnedMessageIds) }()
      default: break
      }
    }
  }

  func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if !self.pinnedMessageIds.isEmpty {
      try visitor.visitPackedUInt64Field(value: self.pinnedMessageIds, fieldNumber: 1)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  static func ==(lhs: Protocol_Chat_V1_GetPinnedMessagesResponse, rhs: Protocol_Chat_V1_GetPinnedMessagesResponse) -> Bool {
    if lhs.pinnedMessageIds != rhs.pinnedMessageIds {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Protocol_Chat_V1_AddReactionRequest: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static let protoMessageName: String = _protobuf_package + ".AddReactionRequest"
  static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .standard(proto: "guild_id"),
    2: .standard(proto: "channel_id"),
    3: .standard(proto: "message_id"),
    4: .same(proto: "emote"),
  ]

  mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularUInt64Field(value: &self.guildID) }()
      case 2: try { try decoder.decodeSingularUInt64Field(value: &self.channelID) }()
      case 3: try { try decoder.decodeSingularUInt64Field(value: &self.messageID) }()
      case 4: try { try decoder.decodeSingularMessageField(value: &self._emote) }()
      default: break
      }
    }
  }

  func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if self.guildID != 0 {
      try visitor.visitSingularUInt64Field(value: self.guildID, fieldNumber: 1)
    }
    if self.channelID != 0 {
      try visitor.visitSingularUInt64Field(value: self.channelID, fieldNumber: 2)
    }
    if self.messageID != 0 {
      try visitor.visitSingularUInt64Field(value: self.messageID, fieldNumber: 3)
    }
    if let v = self._emote {
      try visitor.visitSingularMessageField(value: v, fieldNumber: 4)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  static func ==(lhs: Protocol_Chat_V1_AddReactionRequest, rhs: Protocol_Chat_V1_AddReactionRequest) -> Bool {
    if lhs.guildID != rhs.guildID {return false}
    if lhs.channelID != rhs.channelID {return false}
    if lhs.messageID != rhs.messageID {return false}
    if lhs._emote != rhs._emote {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Protocol_Chat_V1_AddReactionResponse: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static let protoMessageName: String = _protobuf_package + ".AddReactionResponse"
  static let _protobuf_nameMap = SwiftProtobuf._NameMap()

  mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let _ = try decoder.nextFieldNumber() {
    }
  }

  func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    try unknownFields.traverse(visitor: &visitor)
  }

  static func ==(lhs: Protocol_Chat_V1_AddReactionResponse, rhs: Protocol_Chat_V1_AddReactionResponse) -> Bool {
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Protocol_Chat_V1_RemoveReactionRequest: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static let protoMessageName: String = _protobuf_package + ".RemoveReactionRequest"
  static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .standard(proto: "guild_id"),
    2: .standard(proto: "channel_id"),
    3: .standard(proto: "message_id"),
    4: .same(proto: "emote"),
  ]

  mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularUInt64Field(value: &self.guildID) }()
      case 2: try { try decoder.decodeSingularUInt64Field(value: &self.channelID) }()
      case 3: try { try decoder.decodeSingularUInt64Field(value: &self.messageID) }()
      case 4: try { try decoder.decodeSingularMessageField(value: &self._emote) }()
      default: break
      }
    }
  }

  func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if self.guildID != 0 {
      try visitor.visitSingularUInt64Field(value: self.guildID, fieldNumber: 1)
    }
    if self.channelID != 0 {
      try visitor.visitSingularUInt64Field(value: self.channelID, fieldNumber: 2)
    }
    if self.messageID != 0 {
      try visitor.visitSingularUInt64Field(value: self.messageID, fieldNumber: 3)
    }
    if let v = self._emote {
      try visitor.visitSingularMessageField(value: v, fieldNumber: 4)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  static func ==(lhs: Protocol_Chat_V1_RemoveReactionRequest, rhs: Protocol_Chat_V1_RemoveReactionRequest) -> Bool {
    if lhs.guildID != rhs.guildID {return false}
    if lhs.channelID != rhs.channelID {return false}
    if lhs.messageID != rhs.messageID {return false}
    if lhs._emote != rhs._emote {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Protocol_Chat_V1_RemoveReactionResponse: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static let protoMessageName: String = _protobuf_package + ".RemoveReactionResponse"
  static let _protobuf_nameMap = SwiftProtobuf._NameMap()

  mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let _ = try decoder.nextFieldNumber() {
    }
  }

  func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    try unknownFields.traverse(visitor: &visitor)
  }

  static func ==(lhs: Protocol_Chat_V1_RemoveReactionResponse, rhs: Protocol_Chat_V1_RemoveReactionResponse) -> Bool {
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}
