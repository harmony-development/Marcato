// DO NOT EDIT.
// swift-format-ignore-file
//
// Generated by the Swift generator plugin for the protocol buffer compiler.
// Source: chat/v1/permissions.proto
//
// For information on using the generated types, please see the documentation:
//   https://github.com/apple/swift-protobuf/

import Foundation
import SwiftProtobuf

// If the compiler emits an error on this type, it is because this file
// was generated by a version of the `protoc` Swift plug-in that is
// incompatible with the version of SwiftProtobuf to which you are linking.
// Please ensure that you are building against the same version of the API
// that was used to generate this file.
fileprivate struct _GeneratedWithProtocGenSwiftVersion: SwiftProtobuf.ProtobufAPIVersionCheck {
  struct _2: SwiftProtobuf.ProtobufAPIVersion_2 {}
  typealias Version = _2
}

/// Object representing a single permission node.
struct Protocol_Chat_V1_Permission {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  /// the permission matcher. (example: roles.manage)
  var matches: String = String()

  /// whether the permission is allowed or not.
  var ok: Bool = false

  var unknownFields = SwiftProtobuf.UnknownStorage()

  init() {}
}

/// Object representing a role without the ID.
struct Protocol_Chat_V1_Role {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  /// the role name.
  var name: String = String()

  /// the role color.
  var color: Int32 = 0

  /// whether the role is hoisted or not.
  var hoist: Bool = false

  /// whether the role is mentionable or not.
  var pingable: Bool = false

  var unknownFields = SwiftProtobuf.UnknownStorage()

  init() {}
}

/// Object representing a role with it's ID.
///
/// The role ID for the default role in a guild should always be 0.
struct Protocol_Chat_V1_RoleWithId {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  /// ID of the role.
  var roleID: UInt64 = 0

  /// The role data.
  var role: Protocol_Chat_V1_Role {
    get {return _role ?? Protocol_Chat_V1_Role()}
    set {_role = newValue}
  }
  /// Returns true if `role` has been explicitly set.
  var hasRole: Bool {return self._role != nil}
  /// Clears the value of `role`. Subsequent reads from it will return its default value.
  mutating func clearRole() {self._role = nil}

  var unknownFields = SwiftProtobuf.UnknownStorage()

  init() {}

  fileprivate var _role: Protocol_Chat_V1_Role? = nil
}

/// Used in the `QueryHasPermission` endpoint.
struct Protocol_Chat_V1_QueryHasPermissionRequest {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  /// the guild ID to query permissions for
  var guildID: UInt64 = 0

  /// the channel ID to query permissions for. If not set, it will query
  /// permissions for the guild.
  var channelID: UInt64 {
    get {return _channelID ?? 0}
    set {_channelID = newValue}
  }
  /// Returns true if `channelID` has been explicitly set.
  var hasChannelID: Bool {return self._channelID != nil}
  /// Clears the value of `channelID`. Subsequent reads from it will return its default value.
  mutating func clearChannelID() {self._channelID = nil}

  /// the user ID to query permissions for (if not provided, the current user is
  /// assumed).
  var `as`: UInt64 {
    get {return _as ?? 0}
    set {_as = newValue}
  }
  /// Returns true if ``as`` has been explicitly set.
  var hasAs: Bool {return self._as != nil}
  /// Clears the value of ``as``. Subsequent reads from it will return its default value.
  mutating func clearAs() {self._as = nil}

  /// the permission node to check for.
  var checkFor: String = String()

  var unknownFields = SwiftProtobuf.UnknownStorage()

  init() {}

  fileprivate var _channelID: UInt64? = nil
  fileprivate var _as: UInt64? = nil
}

/// Used in the `QueryHasPermission` endpoint.
struct Protocol_Chat_V1_QueryHasPermissionResponse {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  /// the permissions for the given node.
  var ok: Bool = false

  var unknownFields = SwiftProtobuf.UnknownStorage()

  init() {}
}

/// Used in the `SetPermissions` endpoint.
struct Protocol_Chat_V1_SetPermissionsRequest {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  /// the guild ID to set permissions for.
  var guildID: UInt64 = 0

  /// the channel ID to set permissions for. Only set if the role is for a
  /// channel.
  var channelID: UInt64 {
    get {return _channelID ?? 0}
    set {_channelID = newValue}
  }
  /// Returns true if `channelID` has been explicitly set.
  var hasChannelID: Bool {return self._channelID != nil}
  /// Clears the value of `channelID`. Subsequent reads from it will return its default value.
  mutating func clearChannelID() {self._channelID = nil}

  /// the role ID to set permissions for.
  var roleID: UInt64 = 0

  /// the permission list to give.
  ///
  /// There is no "perms_to_take" because not given permissions are by
  /// default not allowed.
  var permsToGive: [Protocol_Chat_V1_Permission] = []

  var unknownFields = SwiftProtobuf.UnknownStorage()

  init() {}

  fileprivate var _channelID: UInt64? = nil
}

/// Used in the `SetPermissions` endpoint.
struct Protocol_Chat_V1_SetPermissionsResponse {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  var unknownFields = SwiftProtobuf.UnknownStorage()

  init() {}
}

/// Used in the `GetPermissions` endpoint.
struct Protocol_Chat_V1_GetPermissionsRequest {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  /// the guild ID to get permissions for.
  var guildID: UInt64 = 0

  /// the channel ID to get permissions for. Only applicable for roles in a
  /// channel.
  var channelID: UInt64 {
    get {return _channelID ?? 0}
    set {_channelID = newValue}
  }
  /// Returns true if `channelID` has been explicitly set.
  var hasChannelID: Bool {return self._channelID != nil}
  /// Clears the value of `channelID`. Subsequent reads from it will return its default value.
  mutating func clearChannelID() {self._channelID = nil}

  /// the role ID to get permissions for.
  var roleID: UInt64 = 0

  var unknownFields = SwiftProtobuf.UnknownStorage()

  init() {}

  fileprivate var _channelID: UInt64? = nil
}

/// Used in the `GetPermissions` endpoint.
struct Protocol_Chat_V1_GetPermissionsResponse {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  /// the permissions list for the given role.
  var perms: [Protocol_Chat_V1_Permission] = []

  var unknownFields = SwiftProtobuf.UnknownStorage()

  init() {}
}

/// Used in the `MoveRole` endpoint.
struct Protocol_Chat_V1_MoveRoleRequest {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  /// the guild ID to move the role in.
  var guildID: UInt64 = 0

  /// the role ID to move.
  var roleID: UInt64 = 0

  /// the new position of the role.
  var newPosition: Protocol_Harmonytypes_V1_ItemPosition {
    get {return _newPosition ?? Protocol_Harmonytypes_V1_ItemPosition()}
    set {_newPosition = newValue}
  }
  /// Returns true if `newPosition` has been explicitly set.
  var hasNewPosition: Bool {return self._newPosition != nil}
  /// Clears the value of `newPosition`. Subsequent reads from it will return its default value.
  mutating func clearNewPosition() {self._newPosition = nil}

  var unknownFields = SwiftProtobuf.UnknownStorage()

  init() {}

  fileprivate var _newPosition: Protocol_Harmonytypes_V1_ItemPosition? = nil
}

/// Used in the `MoveRole` endpoint.
struct Protocol_Chat_V1_MoveRoleResponse {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  var unknownFields = SwiftProtobuf.UnknownStorage()

  init() {}
}

/// Used in the `GetGuildRoles` endpoint.
struct Protocol_Chat_V1_GetGuildRolesRequest {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  /// the guild ID to get roles for.
  var guildID: UInt64 = 0

  var unknownFields = SwiftProtobuf.UnknownStorage()

  init() {}
}

/// Used in the `GetGuildRoles` endpoint.
struct Protocol_Chat_V1_GetGuildRolesResponse {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  /// the list of roles in the guild.
  var roles: [Protocol_Chat_V1_RoleWithId] = []

  var unknownFields = SwiftProtobuf.UnknownStorage()

  init() {}
}

/// Used in the `AddGuildRole` endpoint.
struct Protocol_Chat_V1_AddGuildRoleRequest {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  /// the guild ID to add the role to.
  var guildID: UInt64 = 0

  /// the role name.
  var name: String = String()

  /// the role color.
  var color: Int32 = 0

  /// whether the role is hoisted or not.
  var hoist: Bool = false

  /// whether the role is mentionable or not.
  var pingable: Bool = false

  var unknownFields = SwiftProtobuf.UnknownStorage()

  init() {}
}

/// Used in the `AddGuildRole` endpoint.
struct Protocol_Chat_V1_AddGuildRoleResponse {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  /// the ID of the newly created role.
  var roleID: UInt64 = 0

  var unknownFields = SwiftProtobuf.UnknownStorage()

  init() {}
}

/// Used in the `DeleteGuildRole` endpoint.
struct Protocol_Chat_V1_DeleteGuildRoleRequest {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  /// the guild ID to delete the role from.
  var guildID: UInt64 = 0

  /// the role ID to delete.
  var roleID: UInt64 = 0

  var unknownFields = SwiftProtobuf.UnknownStorage()

  init() {}
}

/// Used in the `DeleteGuildRole` endpoint.
struct Protocol_Chat_V1_DeleteGuildRoleResponse {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  var unknownFields = SwiftProtobuf.UnknownStorage()

  init() {}
}

/// Used in the `ModifyGuildRole` endpoint.
struct Protocol_Chat_V1_ModifyGuildRoleRequest {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  /// the ID of the guild where the role is located
  var guildID: UInt64 = 0

  /// the ID of the role to modify
  var roleID: UInt64 = 0

  /// the new name of the role
  var newName: String {
    get {return _newName ?? String()}
    set {_newName = newValue}
  }
  /// Returns true if `newName` has been explicitly set.
  var hasNewName: Bool {return self._newName != nil}
  /// Clears the value of `newName`. Subsequent reads from it will return its default value.
  mutating func clearNewName() {self._newName = nil}

  /// the new color of the role
  var newColor: Int32 {
    get {return _newColor ?? 0}
    set {_newColor = newValue}
  }
  /// Returns true if `newColor` has been explicitly set.
  var hasNewColor: Bool {return self._newColor != nil}
  /// Clears the value of `newColor`. Subsequent reads from it will return its default value.
  mutating func clearNewColor() {self._newColor = nil}

  /// the new hoist status of the role
  var newHoist: Bool {
    get {return _newHoist ?? false}
    set {_newHoist = newValue}
  }
  /// Returns true if `newHoist` has been explicitly set.
  var hasNewHoist: Bool {return self._newHoist != nil}
  /// Clears the value of `newHoist`. Subsequent reads from it will return its default value.
  mutating func clearNewHoist() {self._newHoist = nil}

  /// the new pingable status of the role
  var newPingable: Bool {
    get {return _newPingable ?? false}
    set {_newPingable = newValue}
  }
  /// Returns true if `newPingable` has been explicitly set.
  var hasNewPingable: Bool {return self._newPingable != nil}
  /// Clears the value of `newPingable`. Subsequent reads from it will return its default value.
  mutating func clearNewPingable() {self._newPingable = nil}

  var unknownFields = SwiftProtobuf.UnknownStorage()

  init() {}

  fileprivate var _newName: String? = nil
  fileprivate var _newColor: Int32? = nil
  fileprivate var _newHoist: Bool? = nil
  fileprivate var _newPingable: Bool? = nil
}

/// Used in the `ModifyGuildRole` endpoint.
struct Protocol_Chat_V1_ModifyGuildRoleResponse {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  var unknownFields = SwiftProtobuf.UnknownStorage()

  init() {}
}

/// Used in the `ManageUserRoles` endpoint.
struct Protocol_Chat_V1_ManageUserRolesRequest {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  /// the ID of the guild where the user is being managed
  var guildID: UInt64 = 0

  /// the ID of the user to modify
  var userID: UInt64 = 0

  /// the IDs of the roles to add
  var giveRoleIds: [UInt64] = []

  /// the IDs of the roles to remove
  var takeRoleIds: [UInt64] = []

  var unknownFields = SwiftProtobuf.UnknownStorage()

  init() {}
}

/// Used in the `ManageUserRoles` endpoint.
struct Protocol_Chat_V1_ManageUserRolesResponse {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  var unknownFields = SwiftProtobuf.UnknownStorage()

  init() {}
}

/// Used in the `GetUserRoles` endpoint.
struct Protocol_Chat_V1_GetUserRolesRequest {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  /// the ID of the guild where the user is located
  var guildID: UInt64 = 0

  /// the ID of the user to get roles for
  var userID: UInt64 = 0

  var unknownFields = SwiftProtobuf.UnknownStorage()

  init() {}
}

/// Used in the `GetUserRoles` endpoint.
struct Protocol_Chat_V1_GetUserRolesResponse {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  /// a list of IDs of the roles the user has
  var roles: [UInt64] = []

  var unknownFields = SwiftProtobuf.UnknownStorage()

  init() {}
}

// MARK: - Code below here is support for the SwiftProtobuf runtime.

fileprivate let _protobuf_package = "protocol.chat.v1"

extension Protocol_Chat_V1_Permission: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static let protoMessageName: String = _protobuf_package + ".Permission"
  static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "matches"),
    2: .same(proto: "ok"),
  ]

  mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularStringField(value: &self.matches) }()
      case 2: try { try decoder.decodeSingularBoolField(value: &self.ok) }()
      default: break
      }
    }
  }

  func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if !self.matches.isEmpty {
      try visitor.visitSingularStringField(value: self.matches, fieldNumber: 1)
    }
    if self.ok != false {
      try visitor.visitSingularBoolField(value: self.ok, fieldNumber: 2)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  static func ==(lhs: Protocol_Chat_V1_Permission, rhs: Protocol_Chat_V1_Permission) -> Bool {
    if lhs.matches != rhs.matches {return false}
    if lhs.ok != rhs.ok {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Protocol_Chat_V1_Role: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static let protoMessageName: String = _protobuf_package + ".Role"
  static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "name"),
    2: .same(proto: "color"),
    3: .same(proto: "hoist"),
    4: .same(proto: "pingable"),
  ]

  mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularStringField(value: &self.name) }()
      case 2: try { try decoder.decodeSingularInt32Field(value: &self.color) }()
      case 3: try { try decoder.decodeSingularBoolField(value: &self.hoist) }()
      case 4: try { try decoder.decodeSingularBoolField(value: &self.pingable) }()
      default: break
      }
    }
  }

  func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if !self.name.isEmpty {
      try visitor.visitSingularStringField(value: self.name, fieldNumber: 1)
    }
    if self.color != 0 {
      try visitor.visitSingularInt32Field(value: self.color, fieldNumber: 2)
    }
    if self.hoist != false {
      try visitor.visitSingularBoolField(value: self.hoist, fieldNumber: 3)
    }
    if self.pingable != false {
      try visitor.visitSingularBoolField(value: self.pingable, fieldNumber: 4)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  static func ==(lhs: Protocol_Chat_V1_Role, rhs: Protocol_Chat_V1_Role) -> Bool {
    if lhs.name != rhs.name {return false}
    if lhs.color != rhs.color {return false}
    if lhs.hoist != rhs.hoist {return false}
    if lhs.pingable != rhs.pingable {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Protocol_Chat_V1_RoleWithId: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static let protoMessageName: String = _protobuf_package + ".RoleWithId"
  static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .standard(proto: "role_id"),
    2: .same(proto: "role"),
  ]

  mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularUInt64Field(value: &self.roleID) }()
      case 2: try { try decoder.decodeSingularMessageField(value: &self._role) }()
      default: break
      }
    }
  }

  func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if self.roleID != 0 {
      try visitor.visitSingularUInt64Field(value: self.roleID, fieldNumber: 1)
    }
    if let v = self._role {
      try visitor.visitSingularMessageField(value: v, fieldNumber: 2)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  static func ==(lhs: Protocol_Chat_V1_RoleWithId, rhs: Protocol_Chat_V1_RoleWithId) -> Bool {
    if lhs.roleID != rhs.roleID {return false}
    if lhs._role != rhs._role {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Protocol_Chat_V1_QueryHasPermissionRequest: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static let protoMessageName: String = _protobuf_package + ".QueryHasPermissionRequest"
  static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .standard(proto: "guild_id"),
    2: .standard(proto: "channel_id"),
    4: .same(proto: "as"),
    3: .standard(proto: "check_for"),
  ]

  mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularUInt64Field(value: &self.guildID) }()
      case 2: try { try decoder.decodeSingularUInt64Field(value: &self._channelID) }()
      case 3: try { try decoder.decodeSingularStringField(value: &self.checkFor) }()
      case 4: try { try decoder.decodeSingularUInt64Field(value: &self._as) }()
      default: break
      }
    }
  }

  func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if self.guildID != 0 {
      try visitor.visitSingularUInt64Field(value: self.guildID, fieldNumber: 1)
    }
    if let v = self._channelID {
      try visitor.visitSingularUInt64Field(value: v, fieldNumber: 2)
    }
    if !self.checkFor.isEmpty {
      try visitor.visitSingularStringField(value: self.checkFor, fieldNumber: 3)
    }
    if let v = self._as {
      try visitor.visitSingularUInt64Field(value: v, fieldNumber: 4)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  static func ==(lhs: Protocol_Chat_V1_QueryHasPermissionRequest, rhs: Protocol_Chat_V1_QueryHasPermissionRequest) -> Bool {
    if lhs.guildID != rhs.guildID {return false}
    if lhs._channelID != rhs._channelID {return false}
    if lhs._as != rhs._as {return false}
    if lhs.checkFor != rhs.checkFor {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Protocol_Chat_V1_QueryHasPermissionResponse: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static let protoMessageName: String = _protobuf_package + ".QueryHasPermissionResponse"
  static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "ok"),
  ]

  mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularBoolField(value: &self.ok) }()
      default: break
      }
    }
  }

  func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if self.ok != false {
      try visitor.visitSingularBoolField(value: self.ok, fieldNumber: 1)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  static func ==(lhs: Protocol_Chat_V1_QueryHasPermissionResponse, rhs: Protocol_Chat_V1_QueryHasPermissionResponse) -> Bool {
    if lhs.ok != rhs.ok {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Protocol_Chat_V1_SetPermissionsRequest: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static let protoMessageName: String = _protobuf_package + ".SetPermissionsRequest"
  static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .standard(proto: "guild_id"),
    2: .standard(proto: "channel_id"),
    3: .standard(proto: "role_id"),
    4: .standard(proto: "perms_to_give"),
  ]

  mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularUInt64Field(value: &self.guildID) }()
      case 2: try { try decoder.decodeSingularUInt64Field(value: &self._channelID) }()
      case 3: try { try decoder.decodeSingularUInt64Field(value: &self.roleID) }()
      case 4: try { try decoder.decodeRepeatedMessageField(value: &self.permsToGive) }()
      default: break
      }
    }
  }

  func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if self.guildID != 0 {
      try visitor.visitSingularUInt64Field(value: self.guildID, fieldNumber: 1)
    }
    if let v = self._channelID {
      try visitor.visitSingularUInt64Field(value: v, fieldNumber: 2)
    }
    if self.roleID != 0 {
      try visitor.visitSingularUInt64Field(value: self.roleID, fieldNumber: 3)
    }
    if !self.permsToGive.isEmpty {
      try visitor.visitRepeatedMessageField(value: self.permsToGive, fieldNumber: 4)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  static func ==(lhs: Protocol_Chat_V1_SetPermissionsRequest, rhs: Protocol_Chat_V1_SetPermissionsRequest) -> Bool {
    if lhs.guildID != rhs.guildID {return false}
    if lhs._channelID != rhs._channelID {return false}
    if lhs.roleID != rhs.roleID {return false}
    if lhs.permsToGive != rhs.permsToGive {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Protocol_Chat_V1_SetPermissionsResponse: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static let protoMessageName: String = _protobuf_package + ".SetPermissionsResponse"
  static let _protobuf_nameMap = SwiftProtobuf._NameMap()

  mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let _ = try decoder.nextFieldNumber() {
    }
  }

  func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    try unknownFields.traverse(visitor: &visitor)
  }

  static func ==(lhs: Protocol_Chat_V1_SetPermissionsResponse, rhs: Protocol_Chat_V1_SetPermissionsResponse) -> Bool {
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Protocol_Chat_V1_GetPermissionsRequest: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static let protoMessageName: String = _protobuf_package + ".GetPermissionsRequest"
  static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .standard(proto: "guild_id"),
    2: .standard(proto: "channel_id"),
    3: .standard(proto: "role_id"),
  ]

  mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularUInt64Field(value: &self.guildID) }()
      case 2: try { try decoder.decodeSingularUInt64Field(value: &self._channelID) }()
      case 3: try { try decoder.decodeSingularUInt64Field(value: &self.roleID) }()
      default: break
      }
    }
  }

  func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if self.guildID != 0 {
      try visitor.visitSingularUInt64Field(value: self.guildID, fieldNumber: 1)
    }
    if let v = self._channelID {
      try visitor.visitSingularUInt64Field(value: v, fieldNumber: 2)
    }
    if self.roleID != 0 {
      try visitor.visitSingularUInt64Field(value: self.roleID, fieldNumber: 3)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  static func ==(lhs: Protocol_Chat_V1_GetPermissionsRequest, rhs: Protocol_Chat_V1_GetPermissionsRequest) -> Bool {
    if lhs.guildID != rhs.guildID {return false}
    if lhs._channelID != rhs._channelID {return false}
    if lhs.roleID != rhs.roleID {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Protocol_Chat_V1_GetPermissionsResponse: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static let protoMessageName: String = _protobuf_package + ".GetPermissionsResponse"
  static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "perms"),
  ]

  mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeRepeatedMessageField(value: &self.perms) }()
      default: break
      }
    }
  }

  func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if !self.perms.isEmpty {
      try visitor.visitRepeatedMessageField(value: self.perms, fieldNumber: 1)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  static func ==(lhs: Protocol_Chat_V1_GetPermissionsResponse, rhs: Protocol_Chat_V1_GetPermissionsResponse) -> Bool {
    if lhs.perms != rhs.perms {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Protocol_Chat_V1_MoveRoleRequest: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static let protoMessageName: String = _protobuf_package + ".MoveRoleRequest"
  static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .standard(proto: "guild_id"),
    2: .standard(proto: "role_id"),
    3: .standard(proto: "new_position"),
  ]

  mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularUInt64Field(value: &self.guildID) }()
      case 2: try { try decoder.decodeSingularUInt64Field(value: &self.roleID) }()
      case 3: try { try decoder.decodeSingularMessageField(value: &self._newPosition) }()
      default: break
      }
    }
  }

  func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if self.guildID != 0 {
      try visitor.visitSingularUInt64Field(value: self.guildID, fieldNumber: 1)
    }
    if self.roleID != 0 {
      try visitor.visitSingularUInt64Field(value: self.roleID, fieldNumber: 2)
    }
    if let v = self._newPosition {
      try visitor.visitSingularMessageField(value: v, fieldNumber: 3)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  static func ==(lhs: Protocol_Chat_V1_MoveRoleRequest, rhs: Protocol_Chat_V1_MoveRoleRequest) -> Bool {
    if lhs.guildID != rhs.guildID {return false}
    if lhs.roleID != rhs.roleID {return false}
    if lhs._newPosition != rhs._newPosition {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Protocol_Chat_V1_MoveRoleResponse: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static let protoMessageName: String = _protobuf_package + ".MoveRoleResponse"
  static let _protobuf_nameMap = SwiftProtobuf._NameMap()

  mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let _ = try decoder.nextFieldNumber() {
    }
  }

  func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    try unknownFields.traverse(visitor: &visitor)
  }

  static func ==(lhs: Protocol_Chat_V1_MoveRoleResponse, rhs: Protocol_Chat_V1_MoveRoleResponse) -> Bool {
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Protocol_Chat_V1_GetGuildRolesRequest: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static let protoMessageName: String = _protobuf_package + ".GetGuildRolesRequest"
  static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .standard(proto: "guild_id"),
  ]

  mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularUInt64Field(value: &self.guildID) }()
      default: break
      }
    }
  }

  func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if self.guildID != 0 {
      try visitor.visitSingularUInt64Field(value: self.guildID, fieldNumber: 1)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  static func ==(lhs: Protocol_Chat_V1_GetGuildRolesRequest, rhs: Protocol_Chat_V1_GetGuildRolesRequest) -> Bool {
    if lhs.guildID != rhs.guildID {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Protocol_Chat_V1_GetGuildRolesResponse: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static let protoMessageName: String = _protobuf_package + ".GetGuildRolesResponse"
  static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "roles"),
  ]

  mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeRepeatedMessageField(value: &self.roles) }()
      default: break
      }
    }
  }

  func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if !self.roles.isEmpty {
      try visitor.visitRepeatedMessageField(value: self.roles, fieldNumber: 1)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  static func ==(lhs: Protocol_Chat_V1_GetGuildRolesResponse, rhs: Protocol_Chat_V1_GetGuildRolesResponse) -> Bool {
    if lhs.roles != rhs.roles {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Protocol_Chat_V1_AddGuildRoleRequest: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static let protoMessageName: String = _protobuf_package + ".AddGuildRoleRequest"
  static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .standard(proto: "guild_id"),
    2: .same(proto: "name"),
    3: .same(proto: "color"),
    4: .same(proto: "hoist"),
    5: .same(proto: "pingable"),
  ]

  mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularUInt64Field(value: &self.guildID) }()
      case 2: try { try decoder.decodeSingularStringField(value: &self.name) }()
      case 3: try { try decoder.decodeSingularInt32Field(value: &self.color) }()
      case 4: try { try decoder.decodeSingularBoolField(value: &self.hoist) }()
      case 5: try { try decoder.decodeSingularBoolField(value: &self.pingable) }()
      default: break
      }
    }
  }

  func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if self.guildID != 0 {
      try visitor.visitSingularUInt64Field(value: self.guildID, fieldNumber: 1)
    }
    if !self.name.isEmpty {
      try visitor.visitSingularStringField(value: self.name, fieldNumber: 2)
    }
    if self.color != 0 {
      try visitor.visitSingularInt32Field(value: self.color, fieldNumber: 3)
    }
    if self.hoist != false {
      try visitor.visitSingularBoolField(value: self.hoist, fieldNumber: 4)
    }
    if self.pingable != false {
      try visitor.visitSingularBoolField(value: self.pingable, fieldNumber: 5)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  static func ==(lhs: Protocol_Chat_V1_AddGuildRoleRequest, rhs: Protocol_Chat_V1_AddGuildRoleRequest) -> Bool {
    if lhs.guildID != rhs.guildID {return false}
    if lhs.name != rhs.name {return false}
    if lhs.color != rhs.color {return false}
    if lhs.hoist != rhs.hoist {return false}
    if lhs.pingable != rhs.pingable {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Protocol_Chat_V1_AddGuildRoleResponse: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static let protoMessageName: String = _protobuf_package + ".AddGuildRoleResponse"
  static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .standard(proto: "role_id"),
  ]

  mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularUInt64Field(value: &self.roleID) }()
      default: break
      }
    }
  }

  func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if self.roleID != 0 {
      try visitor.visitSingularUInt64Field(value: self.roleID, fieldNumber: 1)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  static func ==(lhs: Protocol_Chat_V1_AddGuildRoleResponse, rhs: Protocol_Chat_V1_AddGuildRoleResponse) -> Bool {
    if lhs.roleID != rhs.roleID {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Protocol_Chat_V1_DeleteGuildRoleRequest: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static let protoMessageName: String = _protobuf_package + ".DeleteGuildRoleRequest"
  static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .standard(proto: "guild_id"),
    2: .standard(proto: "role_id"),
  ]

  mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularUInt64Field(value: &self.guildID) }()
      case 2: try { try decoder.decodeSingularUInt64Field(value: &self.roleID) }()
      default: break
      }
    }
  }

  func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if self.guildID != 0 {
      try visitor.visitSingularUInt64Field(value: self.guildID, fieldNumber: 1)
    }
    if self.roleID != 0 {
      try visitor.visitSingularUInt64Field(value: self.roleID, fieldNumber: 2)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  static func ==(lhs: Protocol_Chat_V1_DeleteGuildRoleRequest, rhs: Protocol_Chat_V1_DeleteGuildRoleRequest) -> Bool {
    if lhs.guildID != rhs.guildID {return false}
    if lhs.roleID != rhs.roleID {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Protocol_Chat_V1_DeleteGuildRoleResponse: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static let protoMessageName: String = _protobuf_package + ".DeleteGuildRoleResponse"
  static let _protobuf_nameMap = SwiftProtobuf._NameMap()

  mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let _ = try decoder.nextFieldNumber() {
    }
  }

  func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    try unknownFields.traverse(visitor: &visitor)
  }

  static func ==(lhs: Protocol_Chat_V1_DeleteGuildRoleResponse, rhs: Protocol_Chat_V1_DeleteGuildRoleResponse) -> Bool {
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Protocol_Chat_V1_ModifyGuildRoleRequest: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static let protoMessageName: String = _protobuf_package + ".ModifyGuildRoleRequest"
  static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .standard(proto: "guild_id"),
    2: .standard(proto: "role_id"),
    3: .standard(proto: "new_name"),
    4: .standard(proto: "new_color"),
    5: .standard(proto: "new_hoist"),
    6: .standard(proto: "new_pingable"),
  ]

  mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularUInt64Field(value: &self.guildID) }()
      case 2: try { try decoder.decodeSingularUInt64Field(value: &self.roleID) }()
      case 3: try { try decoder.decodeSingularStringField(value: &self._newName) }()
      case 4: try { try decoder.decodeSingularInt32Field(value: &self._newColor) }()
      case 5: try { try decoder.decodeSingularBoolField(value: &self._newHoist) }()
      case 6: try { try decoder.decodeSingularBoolField(value: &self._newPingable) }()
      default: break
      }
    }
  }

  func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if self.guildID != 0 {
      try visitor.visitSingularUInt64Field(value: self.guildID, fieldNumber: 1)
    }
    if self.roleID != 0 {
      try visitor.visitSingularUInt64Field(value: self.roleID, fieldNumber: 2)
    }
    if let v = self._newName {
      try visitor.visitSingularStringField(value: v, fieldNumber: 3)
    }
    if let v = self._newColor {
      try visitor.visitSingularInt32Field(value: v, fieldNumber: 4)
    }
    if let v = self._newHoist {
      try visitor.visitSingularBoolField(value: v, fieldNumber: 5)
    }
    if let v = self._newPingable {
      try visitor.visitSingularBoolField(value: v, fieldNumber: 6)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  static func ==(lhs: Protocol_Chat_V1_ModifyGuildRoleRequest, rhs: Protocol_Chat_V1_ModifyGuildRoleRequest) -> Bool {
    if lhs.guildID != rhs.guildID {return false}
    if lhs.roleID != rhs.roleID {return false}
    if lhs._newName != rhs._newName {return false}
    if lhs._newColor != rhs._newColor {return false}
    if lhs._newHoist != rhs._newHoist {return false}
    if lhs._newPingable != rhs._newPingable {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Protocol_Chat_V1_ModifyGuildRoleResponse: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static let protoMessageName: String = _protobuf_package + ".ModifyGuildRoleResponse"
  static let _protobuf_nameMap = SwiftProtobuf._NameMap()

  mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let _ = try decoder.nextFieldNumber() {
    }
  }

  func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    try unknownFields.traverse(visitor: &visitor)
  }

  static func ==(lhs: Protocol_Chat_V1_ModifyGuildRoleResponse, rhs: Protocol_Chat_V1_ModifyGuildRoleResponse) -> Bool {
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Protocol_Chat_V1_ManageUserRolesRequest: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static let protoMessageName: String = _protobuf_package + ".ManageUserRolesRequest"
  static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .standard(proto: "guild_id"),
    2: .standard(proto: "user_id"),
    3: .standard(proto: "give_role_ids"),
    4: .standard(proto: "take_role_ids"),
  ]

  mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularUInt64Field(value: &self.guildID) }()
      case 2: try { try decoder.decodeSingularUInt64Field(value: &self.userID) }()
      case 3: try { try decoder.decodeRepeatedUInt64Field(value: &self.giveRoleIds) }()
      case 4: try { try decoder.decodeRepeatedUInt64Field(value: &self.takeRoleIds) }()
      default: break
      }
    }
  }

  func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if self.guildID != 0 {
      try visitor.visitSingularUInt64Field(value: self.guildID, fieldNumber: 1)
    }
    if self.userID != 0 {
      try visitor.visitSingularUInt64Field(value: self.userID, fieldNumber: 2)
    }
    if !self.giveRoleIds.isEmpty {
      try visitor.visitPackedUInt64Field(value: self.giveRoleIds, fieldNumber: 3)
    }
    if !self.takeRoleIds.isEmpty {
      try visitor.visitPackedUInt64Field(value: self.takeRoleIds, fieldNumber: 4)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  static func ==(lhs: Protocol_Chat_V1_ManageUserRolesRequest, rhs: Protocol_Chat_V1_ManageUserRolesRequest) -> Bool {
    if lhs.guildID != rhs.guildID {return false}
    if lhs.userID != rhs.userID {return false}
    if lhs.giveRoleIds != rhs.giveRoleIds {return false}
    if lhs.takeRoleIds != rhs.takeRoleIds {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Protocol_Chat_V1_ManageUserRolesResponse: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static let protoMessageName: String = _protobuf_package + ".ManageUserRolesResponse"
  static let _protobuf_nameMap = SwiftProtobuf._NameMap()

  mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let _ = try decoder.nextFieldNumber() {
    }
  }

  func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    try unknownFields.traverse(visitor: &visitor)
  }

  static func ==(lhs: Protocol_Chat_V1_ManageUserRolesResponse, rhs: Protocol_Chat_V1_ManageUserRolesResponse) -> Bool {
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Protocol_Chat_V1_GetUserRolesRequest: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static let protoMessageName: String = _protobuf_package + ".GetUserRolesRequest"
  static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .standard(proto: "guild_id"),
    2: .standard(proto: "user_id"),
  ]

  mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularUInt64Field(value: &self.guildID) }()
      case 2: try { try decoder.decodeSingularUInt64Field(value: &self.userID) }()
      default: break
      }
    }
  }

  func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if self.guildID != 0 {
      try visitor.visitSingularUInt64Field(value: self.guildID, fieldNumber: 1)
    }
    if self.userID != 0 {
      try visitor.visitSingularUInt64Field(value: self.userID, fieldNumber: 2)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  static func ==(lhs: Protocol_Chat_V1_GetUserRolesRequest, rhs: Protocol_Chat_V1_GetUserRolesRequest) -> Bool {
    if lhs.guildID != rhs.guildID {return false}
    if lhs.userID != rhs.userID {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Protocol_Chat_V1_GetUserRolesResponse: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static let protoMessageName: String = _protobuf_package + ".GetUserRolesResponse"
  static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "roles"),
  ]

  mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeRepeatedUInt64Field(value: &self.roles) }()
      default: break
      }
    }
  }

  func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if !self.roles.isEmpty {
      try visitor.visitPackedUInt64Field(value: self.roles, fieldNumber: 1)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  static func ==(lhs: Protocol_Chat_V1_GetUserRolesResponse, rhs: Protocol_Chat_V1_GetUserRolesResponse) -> Bool {
    if lhs.roles != rhs.roles {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}
