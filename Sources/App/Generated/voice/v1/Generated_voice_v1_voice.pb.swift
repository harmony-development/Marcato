// DO NOT EDIT.
// swift-format-ignore-file
//
// Generated by the Swift generator plugin for the protocol buffer compiler.
// Source: voice/v1/voice.proto
//
// For information on using the generated types, please see the documentation:
//   https://github.com/apple/swift-protobuf/

import Foundation
import SwiftProtobuf

// If the compiler emits an error on this type, it is because this file
// was generated by a version of the `protoc` Swift plug-in that is
// incompatible with the version of SwiftProtobuf to which you are linking.
// Please ensure that you are building against the same version of the API
// that was used to generate this file.
fileprivate struct _GeneratedWithProtocGenSwiftVersion: SwiftProtobuf.ProtobufAPIVersionCheck {
  struct _2: SwiftProtobuf.ProtobufAPIVersion_2 {}
  typealias Version = _2
}

/// Data containing all the necessary information to
/// create a consumer for a user in a voice channel
///
/// This corresponds to https://mediasoup.org/documentation/v3/mediasoup-client/api/#ConsumerOptions on client:
/// - `consumer_id` -> `id`
/// - `producer_id` -> `producerId`
/// - `rtp_parameters` -> `rtpParameters`
/// - and `kind` should be set to "audio".
struct Protocol_Voice_V1_UserConsumerOptions {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  /// User ID of the user.
  var userID: UInt64 = 0

  /// Producer ID of the producer being consumed.
  var producerID: String = String()

  /// Consumer ID for the user's producer consumer.
  var consumerID: String = String()

  /// RTP paramaters for the user's audio track. Corresponds to `RtpParameters` in mediasoup's TypeScript API.
  var rtpParameters: String = String()

  var unknownFields = SwiftProtobuf.UnknownStorage()

  init() {}
}

/// Object containing all the necessary information about transport options required
/// from the server to establish transport connection on the client
///
/// This corresponds to https://mediasoup.org/documentation/v3/mediasoup-client/api/#TransportOptions on client:
/// - `id` -> `id`
/// - `ice_parameters` -> `iceParameters`
/// - `dtls_parameters` -> `dtlsParameters`
/// - `ice_candidates` -> `iceCandidates`
struct Protocol_Voice_V1_TransportOptions {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  /// The transport ID.
  var id: String = String()

  /// DTLS paramaters in JSON. Corresponds to `DtlsParameters` in mediasoup's TypeScript API.
  var dtlsParameters: String = String()

  /// ICE candidates in JSON. Corresponds to `IceCandidate` in mediasoup's TypeScript API.
  var iceCandidates: [String] = []

  /// ICE paramaters in JSON. Corresponds to `IceParameters` in mediasoup's TypeScript API.
  var iceParameters: String = String()

  var unknownFields = SwiftProtobuf.UnknownStorage()

  init() {}
}

/// Used in `StreamMessage` endpoint.
struct Protocol_Voice_V1_StreamMessageRequest {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  /// Message for this response
  var message: Protocol_Voice_V1_StreamMessageRequest.OneOf_Message? = nil

  /// Sent to initialize the WS and receive necessary information
  var initialize: Protocol_Voice_V1_StreamMessageRequest.Initialize {
    get {
      if case .initialize(let v)? = message {return v}
      return Protocol_Voice_V1_StreamMessageRequest.Initialize()
    }
    set {message = .initialize(newValue)}
  }

  /// Sent to prepare for joining channel
  var prepareForJoinChannel: Protocol_Voice_V1_StreamMessageRequest.PrepareForJoinChannel {
    get {
      if case .prepareForJoinChannel(let v)? = message {return v}
      return Protocol_Voice_V1_StreamMessageRequest.PrepareForJoinChannel()
    }
    set {message = .prepareForJoinChannel(newValue)}
  }

  /// Sent to join a channel
  var joinChannel: Protocol_Voice_V1_StreamMessageRequest.JoinChannel {
    get {
      if case .joinChannel(let v)? = message {return v}
      return Protocol_Voice_V1_StreamMessageRequest.JoinChannel()
    }
    set {message = .joinChannel(newValue)}
  }

  /// Sent to resume a consumer
  var resumeConsumer: Protocol_Voice_V1_StreamMessageRequest.ResumeConsumer {
    get {
      if case .resumeConsumer(let v)? = message {return v}
      return Protocol_Voice_V1_StreamMessageRequest.ResumeConsumer()
    }
    set {message = .resumeConsumer(newValue)}
  }

  var unknownFields = SwiftProtobuf.UnknownStorage()

  /// Message for this response
  enum OneOf_Message: Equatable {
    /// Sent to initialize the WS and receive necessary information
    case initialize(Protocol_Voice_V1_StreamMessageRequest.Initialize)
    /// Sent to prepare for joining channel
    case prepareForJoinChannel(Protocol_Voice_V1_StreamMessageRequest.PrepareForJoinChannel)
    /// Sent to join a channel
    case joinChannel(Protocol_Voice_V1_StreamMessageRequest.JoinChannel)
    /// Sent to resume a consumer
    case resumeConsumer(Protocol_Voice_V1_StreamMessageRequest.ResumeConsumer)

  #if !swift(>=4.1)
    static func ==(lhs: Protocol_Voice_V1_StreamMessageRequest.OneOf_Message, rhs: Protocol_Voice_V1_StreamMessageRequest.OneOf_Message) -> Bool {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch (lhs, rhs) {
      case (.initialize, .initialize): return {
        guard case .initialize(let l) = lhs, case .initialize(let r) = rhs else { preconditionFailure() }
        return l == r
      }()
      case (.prepareForJoinChannel, .prepareForJoinChannel): return {
        guard case .prepareForJoinChannel(let l) = lhs, case .prepareForJoinChannel(let r) = rhs else { preconditionFailure() }
        return l == r
      }()
      case (.joinChannel, .joinChannel): return {
        guard case .joinChannel(let l) = lhs, case .joinChannel(let r) = rhs else { preconditionFailure() }
        return l == r
      }()
      case (.resumeConsumer, .resumeConsumer): return {
        guard case .resumeConsumer(let l) = lhs, case .resumeConsumer(let r) = rhs else { preconditionFailure() }
        return l == r
      }()
      default: return false
      }
    }
  #endif
  }

  /// IDs that will be used to know which channel this WS will operate in
  struct Initialize {
    // SwiftProtobuf.Message conformance is added in an extension below. See the
    // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
    // methods supported on all messages.

    /// Guild ID of the guild where the channel is.
    var guildID: UInt64 = 0

    /// Channel ID of the voice channel to initialize for.
    var channelID: UInt64 = 0

    var unknownFields = SwiftProtobuf.UnknownStorage()

    init() {}
  }

  /// Data needed to prepare for joining a channel
  struct PrepareForJoinChannel {
    // SwiftProtobuf.Message conformance is added in an extension below. See the
    // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
    // methods supported on all messages.

    /// RTP capabilities in JSON.
    var rtpCapabilities: String = String()

    var unknownFields = SwiftProtobuf.UnknownStorage()

    init() {}
  }

  /// Data needed to join a channel
  ///
  /// This takes one RTP paramaters for one track, which will be
  /// assumed to be Audio
  ///
  /// It also takes DTLS paramaters for connecting both producer and consumer
  struct JoinChannel {
    // SwiftProtobuf.Message conformance is added in an extension below. See the
    // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
    // methods supported on all messages.

    /// RTP paramaters in JSON. Corresponds to `RtpParameters` in mediasoup's TypeScript API.
    var rtpParamaters: String = String()

    /// DTLS paramaters for producer transport, in JSON. Corresponds to `DtlsParameters` in mediasoup's TypeScript API.
    var producerDtlsParamaters: String = String()

    /// DTLS paramaters for consumer transport, in JSON. Corresponds to `DtlsParameters` in mediasoup's TypeScript API.
    var consumerDtlsParamaters: String = String()

    var unknownFields = SwiftProtobuf.UnknownStorage()

    init() {}
  }

  /// Message to resume a consumer
  struct ResumeConsumer {
    // SwiftProtobuf.Message conformance is added in an extension below. See the
    // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
    // methods supported on all messages.

    /// ID of the consumer to resume.
    var consumerID: String = String()

    var unknownFields = SwiftProtobuf.UnknownStorage()

    init() {}
  }

  init() {}
}

/// Used in `StreamMessage` endpoint.
struct Protocol_Voice_V1_StreamMessageResponse {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  /// Message for this response
  var message: Protocol_Voice_V1_StreamMessageResponse.OneOf_Message? = nil

  /// Sent when connection is started
  var initialized: Protocol_Voice_V1_StreamMessageResponse.Initialized {
    get {
      if case .initialized(let v)? = message {return v}
      return Protocol_Voice_V1_StreamMessageResponse.Initialized()
    }
    set {message = .initialized(newValue)}
  }

  /// Sent when preparing to join a channel is successful
  var preparedForJoinChannel: Protocol_Voice_V1_StreamMessageResponse.PreparedForJoinChannel {
    get {
      if case .preparedForJoinChannel(let v)? = message {return v}
      return Protocol_Voice_V1_StreamMessageResponse.PreparedForJoinChannel()
    }
    set {message = .preparedForJoinChannel(newValue)}
  }

  /// Sent when joining a channel is successful
  var joinedChannel: Protocol_Voice_V1_StreamMessageResponse.JoinedChannel {
    get {
      if case .joinedChannel(let v)? = message {return v}
      return Protocol_Voice_V1_StreamMessageResponse.JoinedChannel()
    }
    set {message = .joinedChannel(newValue)}
  }

  /// Sent when another user joins the channel
  var userJoined: Protocol_Voice_V1_StreamMessageResponse.UserJoined {
    get {
      if case .userJoined(let v)? = message {return v}
      return Protocol_Voice_V1_StreamMessageResponse.UserJoined()
    }
    set {message = .userJoined(newValue)}
  }

  /// Sent when another user leaves the channel
  var userLeft: Protocol_Voice_V1_StreamMessageResponse.UserLeft {
    get {
      if case .userLeft(let v)? = message {return v}
      return Protocol_Voice_V1_StreamMessageResponse.UserLeft()
    }
    set {message = .userLeft(newValue)}
  }

  var unknownFields = SwiftProtobuf.UnknownStorage()

  /// Message for this response
  enum OneOf_Message: Equatable {
    /// Sent when connection is started
    case initialized(Protocol_Voice_V1_StreamMessageResponse.Initialized)
    /// Sent when preparing to join a channel is successful
    case preparedForJoinChannel(Protocol_Voice_V1_StreamMessageResponse.PreparedForJoinChannel)
    /// Sent when joining a channel is successful
    case joinedChannel(Protocol_Voice_V1_StreamMessageResponse.JoinedChannel)
    /// Sent when another user joins the channel
    case userJoined(Protocol_Voice_V1_StreamMessageResponse.UserJoined)
    /// Sent when another user leaves the channel
    case userLeft(Protocol_Voice_V1_StreamMessageResponse.UserLeft)

  #if !swift(>=4.1)
    static func ==(lhs: Protocol_Voice_V1_StreamMessageResponse.OneOf_Message, rhs: Protocol_Voice_V1_StreamMessageResponse.OneOf_Message) -> Bool {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch (lhs, rhs) {
      case (.initialized, .initialized): return {
        guard case .initialized(let l) = lhs, case .initialized(let r) = rhs else { preconditionFailure() }
        return l == r
      }()
      case (.preparedForJoinChannel, .preparedForJoinChannel): return {
        guard case .preparedForJoinChannel(let l) = lhs, case .preparedForJoinChannel(let r) = rhs else { preconditionFailure() }
        return l == r
      }()
      case (.joinedChannel, .joinedChannel): return {
        guard case .joinedChannel(let l) = lhs, case .joinedChannel(let r) = rhs else { preconditionFailure() }
        return l == r
      }()
      case (.userJoined, .userJoined): return {
        guard case .userJoined(let l) = lhs, case .userJoined(let r) = rhs else { preconditionFailure() }
        return l == r
      }()
      case (.userLeft, .userLeft): return {
        guard case .userLeft(let l) = lhs, case .userLeft(let r) = rhs else { preconditionFailure() }
        return l == r
      }()
      default: return false
      }
    }
  #endif
  }

  /// Initialization data for client
  struct Initialized {
    // SwiftProtobuf.Message conformance is added in an extension below. See the
    // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
    // methods supported on all messages.

    /// Server RTP capabilities in JSON. Corresponds to `RtpCapabilities` in mediasoup's TypeScript API.
    var rtpCapabilities: String = String()

    var unknownFields = SwiftProtobuf.UnknownStorage()

    init() {}
  }

  /// RTP capabilities validated
  struct PreparedForJoinChannel {
    // SwiftProtobuf.Message conformance is added in an extension below. See the
    // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
    // methods supported on all messages.

    /// Consumer transport options
    var consumerTransportOptions: Protocol_Voice_V1_TransportOptions {
      get {return _consumerTransportOptions ?? Protocol_Voice_V1_TransportOptions()}
      set {_consumerTransportOptions = newValue}
    }
    /// Returns true if `consumerTransportOptions` has been explicitly set.
    var hasConsumerTransportOptions: Bool {return self._consumerTransportOptions != nil}
    /// Clears the value of `consumerTransportOptions`. Subsequent reads from it will return its default value.
    mutating func clearConsumerTransportOptions() {self._consumerTransportOptions = nil}

    /// Producer transport options
    var producerTransportOptions: Protocol_Voice_V1_TransportOptions {
      get {return _producerTransportOptions ?? Protocol_Voice_V1_TransportOptions()}
      set {_producerTransportOptions = newValue}
    }
    /// Returns true if `producerTransportOptions` has been explicitly set.
    var hasProducerTransportOptions: Bool {return self._producerTransportOptions != nil}
    /// Clears the value of `producerTransportOptions`. Subsequent reads from it will return its default value.
    mutating func clearProducerTransportOptions() {self._producerTransportOptions = nil}

    var unknownFields = SwiftProtobuf.UnknownStorage()

    init() {}

    fileprivate var _consumerTransportOptions: Protocol_Voice_V1_TransportOptions? = nil
    fileprivate var _producerTransportOptions: Protocol_Voice_V1_TransportOptions? = nil
  }

  /// Producer for voice created; consumer and producer transports are connected
  struct JoinedChannel {
    // SwiftProtobuf.Message conformance is added in an extension below. See the
    // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
    // methods supported on all messages.

    /// Consumer options for users that were already in the room
    var otherUsers: [Protocol_Voice_V1_UserConsumerOptions] = []

    var unknownFields = SwiftProtobuf.UnknownStorage()

    init() {}
  }

  /// Data for the user that joined the room and it's producer
  struct UserJoined {
    // SwiftProtobuf.Message conformance is added in an extension below. See the
    // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
    // methods supported on all messages.

    /// Consumer options for this user
    var data: Protocol_Voice_V1_UserConsumerOptions {
      get {return _data ?? Protocol_Voice_V1_UserConsumerOptions()}
      set {_data = newValue}
    }
    /// Returns true if `data` has been explicitly set.
    var hasData: Bool {return self._data != nil}
    /// Clears the value of `data`. Subsequent reads from it will return its default value.
    mutating func clearData() {self._data = nil}

    var unknownFields = SwiftProtobuf.UnknownStorage()

    init() {}

    fileprivate var _data: Protocol_Voice_V1_UserConsumerOptions? = nil
  }

  /// Data for the user that left the room and the producer
  struct UserLeft {
    // SwiftProtobuf.Message conformance is added in an extension below. See the
    // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
    // methods supported on all messages.

    /// ID of the user that left
    var userID: UInt64 = 0

    var unknownFields = SwiftProtobuf.UnknownStorage()

    init() {}
  }

  init() {}
}

// MARK: - Code below here is support for the SwiftProtobuf runtime.

fileprivate let _protobuf_package = "protocol.voice.v1"

extension Protocol_Voice_V1_UserConsumerOptions: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static let protoMessageName: String = _protobuf_package + ".UserConsumerOptions"
  static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .standard(proto: "user_id"),
    2: .standard(proto: "producer_id"),
    3: .standard(proto: "consumer_id"),
    4: .standard(proto: "rtp_parameters"),
  ]

  mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularUInt64Field(value: &self.userID) }()
      case 2: try { try decoder.decodeSingularStringField(value: &self.producerID) }()
      case 3: try { try decoder.decodeSingularStringField(value: &self.consumerID) }()
      case 4: try { try decoder.decodeSingularStringField(value: &self.rtpParameters) }()
      default: break
      }
    }
  }

  func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if self.userID != 0 {
      try visitor.visitSingularUInt64Field(value: self.userID, fieldNumber: 1)
    }
    if !self.producerID.isEmpty {
      try visitor.visitSingularStringField(value: self.producerID, fieldNumber: 2)
    }
    if !self.consumerID.isEmpty {
      try visitor.visitSingularStringField(value: self.consumerID, fieldNumber: 3)
    }
    if !self.rtpParameters.isEmpty {
      try visitor.visitSingularStringField(value: self.rtpParameters, fieldNumber: 4)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  static func ==(lhs: Protocol_Voice_V1_UserConsumerOptions, rhs: Protocol_Voice_V1_UserConsumerOptions) -> Bool {
    if lhs.userID != rhs.userID {return false}
    if lhs.producerID != rhs.producerID {return false}
    if lhs.consumerID != rhs.consumerID {return false}
    if lhs.rtpParameters != rhs.rtpParameters {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Protocol_Voice_V1_TransportOptions: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static let protoMessageName: String = _protobuf_package + ".TransportOptions"
  static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "id"),
    2: .standard(proto: "dtls_parameters"),
    3: .standard(proto: "ice_candidates"),
    4: .standard(proto: "ice_parameters"),
  ]

  mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularStringField(value: &self.id) }()
      case 2: try { try decoder.decodeSingularStringField(value: &self.dtlsParameters) }()
      case 3: try { try decoder.decodeRepeatedStringField(value: &self.iceCandidates) }()
      case 4: try { try decoder.decodeSingularStringField(value: &self.iceParameters) }()
      default: break
      }
    }
  }

  func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if !self.id.isEmpty {
      try visitor.visitSingularStringField(value: self.id, fieldNumber: 1)
    }
    if !self.dtlsParameters.isEmpty {
      try visitor.visitSingularStringField(value: self.dtlsParameters, fieldNumber: 2)
    }
    if !self.iceCandidates.isEmpty {
      try visitor.visitRepeatedStringField(value: self.iceCandidates, fieldNumber: 3)
    }
    if !self.iceParameters.isEmpty {
      try visitor.visitSingularStringField(value: self.iceParameters, fieldNumber: 4)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  static func ==(lhs: Protocol_Voice_V1_TransportOptions, rhs: Protocol_Voice_V1_TransportOptions) -> Bool {
    if lhs.id != rhs.id {return false}
    if lhs.dtlsParameters != rhs.dtlsParameters {return false}
    if lhs.iceCandidates != rhs.iceCandidates {return false}
    if lhs.iceParameters != rhs.iceParameters {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Protocol_Voice_V1_StreamMessageRequest: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static let protoMessageName: String = _protobuf_package + ".StreamMessageRequest"
  static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "initialize"),
    2: .standard(proto: "prepare_for_join_channel"),
    3: .standard(proto: "join_channel"),
    4: .standard(proto: "resume_consumer"),
  ]

  mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try {
        var v: Protocol_Voice_V1_StreamMessageRequest.Initialize?
        var hadOneofValue = false
        if let current = self.message {
          hadOneofValue = true
          if case .initialize(let m) = current {v = m}
        }
        try decoder.decodeSingularMessageField(value: &v)
        if let v = v {
          if hadOneofValue {try decoder.handleConflictingOneOf()}
          self.message = .initialize(v)
        }
      }()
      case 2: try {
        var v: Protocol_Voice_V1_StreamMessageRequest.PrepareForJoinChannel?
        var hadOneofValue = false
        if let current = self.message {
          hadOneofValue = true
          if case .prepareForJoinChannel(let m) = current {v = m}
        }
        try decoder.decodeSingularMessageField(value: &v)
        if let v = v {
          if hadOneofValue {try decoder.handleConflictingOneOf()}
          self.message = .prepareForJoinChannel(v)
        }
      }()
      case 3: try {
        var v: Protocol_Voice_V1_StreamMessageRequest.JoinChannel?
        var hadOneofValue = false
        if let current = self.message {
          hadOneofValue = true
          if case .joinChannel(let m) = current {v = m}
        }
        try decoder.decodeSingularMessageField(value: &v)
        if let v = v {
          if hadOneofValue {try decoder.handleConflictingOneOf()}
          self.message = .joinChannel(v)
        }
      }()
      case 4: try {
        var v: Protocol_Voice_V1_StreamMessageRequest.ResumeConsumer?
        var hadOneofValue = false
        if let current = self.message {
          hadOneofValue = true
          if case .resumeConsumer(let m) = current {v = m}
        }
        try decoder.decodeSingularMessageField(value: &v)
        if let v = v {
          if hadOneofValue {try decoder.handleConflictingOneOf()}
          self.message = .resumeConsumer(v)
        }
      }()
      default: break
      }
    }
  }

  func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    // The use of inline closures is to circumvent an issue where the compiler
    // allocates stack space for every case branch when no optimizations are
    // enabled. https://github.com/apple/swift-protobuf/issues/1034
    switch self.message {
    case .initialize?: try {
      guard case .initialize(let v)? = self.message else { preconditionFailure() }
      try visitor.visitSingularMessageField(value: v, fieldNumber: 1)
    }()
    case .prepareForJoinChannel?: try {
      guard case .prepareForJoinChannel(let v)? = self.message else { preconditionFailure() }
      try visitor.visitSingularMessageField(value: v, fieldNumber: 2)
    }()
    case .joinChannel?: try {
      guard case .joinChannel(let v)? = self.message else { preconditionFailure() }
      try visitor.visitSingularMessageField(value: v, fieldNumber: 3)
    }()
    case .resumeConsumer?: try {
      guard case .resumeConsumer(let v)? = self.message else { preconditionFailure() }
      try visitor.visitSingularMessageField(value: v, fieldNumber: 4)
    }()
    case nil: break
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  static func ==(lhs: Protocol_Voice_V1_StreamMessageRequest, rhs: Protocol_Voice_V1_StreamMessageRequest) -> Bool {
    if lhs.message != rhs.message {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Protocol_Voice_V1_StreamMessageRequest.Initialize: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static let protoMessageName: String = Protocol_Voice_V1_StreamMessageRequest.protoMessageName + ".Initialize"
  static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .standard(proto: "guild_id"),
    2: .standard(proto: "channel_id"),
  ]

  mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularUInt64Field(value: &self.guildID) }()
      case 2: try { try decoder.decodeSingularUInt64Field(value: &self.channelID) }()
      default: break
      }
    }
  }

  func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if self.guildID != 0 {
      try visitor.visitSingularUInt64Field(value: self.guildID, fieldNumber: 1)
    }
    if self.channelID != 0 {
      try visitor.visitSingularUInt64Field(value: self.channelID, fieldNumber: 2)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  static func ==(lhs: Protocol_Voice_V1_StreamMessageRequest.Initialize, rhs: Protocol_Voice_V1_StreamMessageRequest.Initialize) -> Bool {
    if lhs.guildID != rhs.guildID {return false}
    if lhs.channelID != rhs.channelID {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Protocol_Voice_V1_StreamMessageRequest.PrepareForJoinChannel: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static let protoMessageName: String = Protocol_Voice_V1_StreamMessageRequest.protoMessageName + ".PrepareForJoinChannel"
  static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .standard(proto: "rtp_capabilities"),
  ]

  mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularStringField(value: &self.rtpCapabilities) }()
      default: break
      }
    }
  }

  func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if !self.rtpCapabilities.isEmpty {
      try visitor.visitSingularStringField(value: self.rtpCapabilities, fieldNumber: 1)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  static func ==(lhs: Protocol_Voice_V1_StreamMessageRequest.PrepareForJoinChannel, rhs: Protocol_Voice_V1_StreamMessageRequest.PrepareForJoinChannel) -> Bool {
    if lhs.rtpCapabilities != rhs.rtpCapabilities {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Protocol_Voice_V1_StreamMessageRequest.JoinChannel: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static let protoMessageName: String = Protocol_Voice_V1_StreamMessageRequest.protoMessageName + ".JoinChannel"
  static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .standard(proto: "rtp_paramaters"),
    2: .standard(proto: "producer_dtls_paramaters"),
    3: .standard(proto: "consumer_dtls_paramaters"),
  ]

  mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularStringField(value: &self.rtpParamaters) }()
      case 2: try { try decoder.decodeSingularStringField(value: &self.producerDtlsParamaters) }()
      case 3: try { try decoder.decodeSingularStringField(value: &self.consumerDtlsParamaters) }()
      default: break
      }
    }
  }

  func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if !self.rtpParamaters.isEmpty {
      try visitor.visitSingularStringField(value: self.rtpParamaters, fieldNumber: 1)
    }
    if !self.producerDtlsParamaters.isEmpty {
      try visitor.visitSingularStringField(value: self.producerDtlsParamaters, fieldNumber: 2)
    }
    if !self.consumerDtlsParamaters.isEmpty {
      try visitor.visitSingularStringField(value: self.consumerDtlsParamaters, fieldNumber: 3)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  static func ==(lhs: Protocol_Voice_V1_StreamMessageRequest.JoinChannel, rhs: Protocol_Voice_V1_StreamMessageRequest.JoinChannel) -> Bool {
    if lhs.rtpParamaters != rhs.rtpParamaters {return false}
    if lhs.producerDtlsParamaters != rhs.producerDtlsParamaters {return false}
    if lhs.consumerDtlsParamaters != rhs.consumerDtlsParamaters {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Protocol_Voice_V1_StreamMessageRequest.ResumeConsumer: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static let protoMessageName: String = Protocol_Voice_V1_StreamMessageRequest.protoMessageName + ".ResumeConsumer"
  static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .standard(proto: "consumer_id"),
  ]

  mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularStringField(value: &self.consumerID) }()
      default: break
      }
    }
  }

  func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if !self.consumerID.isEmpty {
      try visitor.visitSingularStringField(value: self.consumerID, fieldNumber: 1)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  static func ==(lhs: Protocol_Voice_V1_StreamMessageRequest.ResumeConsumer, rhs: Protocol_Voice_V1_StreamMessageRequest.ResumeConsumer) -> Bool {
    if lhs.consumerID != rhs.consumerID {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Protocol_Voice_V1_StreamMessageResponse: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static let protoMessageName: String = _protobuf_package + ".StreamMessageResponse"
  static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "initialized"),
    2: .standard(proto: "prepared_for_join_channel"),
    3: .standard(proto: "joined_channel"),
    4: .standard(proto: "user_joined"),
    5: .standard(proto: "user_left"),
  ]

  mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try {
        var v: Protocol_Voice_V1_StreamMessageResponse.Initialized?
        var hadOneofValue = false
        if let current = self.message {
          hadOneofValue = true
          if case .initialized(let m) = current {v = m}
        }
        try decoder.decodeSingularMessageField(value: &v)
        if let v = v {
          if hadOneofValue {try decoder.handleConflictingOneOf()}
          self.message = .initialized(v)
        }
      }()
      case 2: try {
        var v: Protocol_Voice_V1_StreamMessageResponse.PreparedForJoinChannel?
        var hadOneofValue = false
        if let current = self.message {
          hadOneofValue = true
          if case .preparedForJoinChannel(let m) = current {v = m}
        }
        try decoder.decodeSingularMessageField(value: &v)
        if let v = v {
          if hadOneofValue {try decoder.handleConflictingOneOf()}
          self.message = .preparedForJoinChannel(v)
        }
      }()
      case 3: try {
        var v: Protocol_Voice_V1_StreamMessageResponse.JoinedChannel?
        var hadOneofValue = false
        if let current = self.message {
          hadOneofValue = true
          if case .joinedChannel(let m) = current {v = m}
        }
        try decoder.decodeSingularMessageField(value: &v)
        if let v = v {
          if hadOneofValue {try decoder.handleConflictingOneOf()}
          self.message = .joinedChannel(v)
        }
      }()
      case 4: try {
        var v: Protocol_Voice_V1_StreamMessageResponse.UserJoined?
        var hadOneofValue = false
        if let current = self.message {
          hadOneofValue = true
          if case .userJoined(let m) = current {v = m}
        }
        try decoder.decodeSingularMessageField(value: &v)
        if let v = v {
          if hadOneofValue {try decoder.handleConflictingOneOf()}
          self.message = .userJoined(v)
        }
      }()
      case 5: try {
        var v: Protocol_Voice_V1_StreamMessageResponse.UserLeft?
        var hadOneofValue = false
        if let current = self.message {
          hadOneofValue = true
          if case .userLeft(let m) = current {v = m}
        }
        try decoder.decodeSingularMessageField(value: &v)
        if let v = v {
          if hadOneofValue {try decoder.handleConflictingOneOf()}
          self.message = .userLeft(v)
        }
      }()
      default: break
      }
    }
  }

  func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    // The use of inline closures is to circumvent an issue where the compiler
    // allocates stack space for every case branch when no optimizations are
    // enabled. https://github.com/apple/swift-protobuf/issues/1034
    switch self.message {
    case .initialized?: try {
      guard case .initialized(let v)? = self.message else { preconditionFailure() }
      try visitor.visitSingularMessageField(value: v, fieldNumber: 1)
    }()
    case .preparedForJoinChannel?: try {
      guard case .preparedForJoinChannel(let v)? = self.message else { preconditionFailure() }
      try visitor.visitSingularMessageField(value: v, fieldNumber: 2)
    }()
    case .joinedChannel?: try {
      guard case .joinedChannel(let v)? = self.message else { preconditionFailure() }
      try visitor.visitSingularMessageField(value: v, fieldNumber: 3)
    }()
    case .userJoined?: try {
      guard case .userJoined(let v)? = self.message else { preconditionFailure() }
      try visitor.visitSingularMessageField(value: v, fieldNumber: 4)
    }()
    case .userLeft?: try {
      guard case .userLeft(let v)? = self.message else { preconditionFailure() }
      try visitor.visitSingularMessageField(value: v, fieldNumber: 5)
    }()
    case nil: break
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  static func ==(lhs: Protocol_Voice_V1_StreamMessageResponse, rhs: Protocol_Voice_V1_StreamMessageResponse) -> Bool {
    if lhs.message != rhs.message {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Protocol_Voice_V1_StreamMessageResponse.Initialized: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static let protoMessageName: String = Protocol_Voice_V1_StreamMessageResponse.protoMessageName + ".Initialized"
  static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .standard(proto: "rtp_capabilities"),
  ]

  mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularStringField(value: &self.rtpCapabilities) }()
      default: break
      }
    }
  }

  func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if !self.rtpCapabilities.isEmpty {
      try visitor.visitSingularStringField(value: self.rtpCapabilities, fieldNumber: 1)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  static func ==(lhs: Protocol_Voice_V1_StreamMessageResponse.Initialized, rhs: Protocol_Voice_V1_StreamMessageResponse.Initialized) -> Bool {
    if lhs.rtpCapabilities != rhs.rtpCapabilities {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Protocol_Voice_V1_StreamMessageResponse.PreparedForJoinChannel: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static let protoMessageName: String = Protocol_Voice_V1_StreamMessageResponse.protoMessageName + ".PreparedForJoinChannel"
  static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .standard(proto: "consumer_transport_options"),
    2: .standard(proto: "producer_transport_options"),
  ]

  mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularMessageField(value: &self._consumerTransportOptions) }()
      case 2: try { try decoder.decodeSingularMessageField(value: &self._producerTransportOptions) }()
      default: break
      }
    }
  }

  func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if let v = self._consumerTransportOptions {
      try visitor.visitSingularMessageField(value: v, fieldNumber: 1)
    }
    if let v = self._producerTransportOptions {
      try visitor.visitSingularMessageField(value: v, fieldNumber: 2)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  static func ==(lhs: Protocol_Voice_V1_StreamMessageResponse.PreparedForJoinChannel, rhs: Protocol_Voice_V1_StreamMessageResponse.PreparedForJoinChannel) -> Bool {
    if lhs._consumerTransportOptions != rhs._consumerTransportOptions {return false}
    if lhs._producerTransportOptions != rhs._producerTransportOptions {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Protocol_Voice_V1_StreamMessageResponse.JoinedChannel: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static let protoMessageName: String = Protocol_Voice_V1_StreamMessageResponse.protoMessageName + ".JoinedChannel"
  static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .standard(proto: "other_users"),
  ]

  mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeRepeatedMessageField(value: &self.otherUsers) }()
      default: break
      }
    }
  }

  func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if !self.otherUsers.isEmpty {
      try visitor.visitRepeatedMessageField(value: self.otherUsers, fieldNumber: 1)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  static func ==(lhs: Protocol_Voice_V1_StreamMessageResponse.JoinedChannel, rhs: Protocol_Voice_V1_StreamMessageResponse.JoinedChannel) -> Bool {
    if lhs.otherUsers != rhs.otherUsers {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Protocol_Voice_V1_StreamMessageResponse.UserJoined: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static let protoMessageName: String = Protocol_Voice_V1_StreamMessageResponse.protoMessageName + ".UserJoined"
  static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "data"),
  ]

  mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularMessageField(value: &self._data) }()
      default: break
      }
    }
  }

  func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if let v = self._data {
      try visitor.visitSingularMessageField(value: v, fieldNumber: 1)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  static func ==(lhs: Protocol_Voice_V1_StreamMessageResponse.UserJoined, rhs: Protocol_Voice_V1_StreamMessageResponse.UserJoined) -> Bool {
    if lhs._data != rhs._data {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Protocol_Voice_V1_StreamMessageResponse.UserLeft: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static let protoMessageName: String = Protocol_Voice_V1_StreamMessageResponse.protoMessageName + ".UserLeft"
  static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .standard(proto: "user_id"),
  ]

  mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularUInt64Field(value: &self.userID) }()
      default: break
      }
    }
  }

  func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if self.userID != 0 {
      try visitor.visitSingularUInt64Field(value: self.userID, fieldNumber: 1)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  static func ==(lhs: Protocol_Voice_V1_StreamMessageResponse.UserLeft, rhs: Protocol_Voice_V1_StreamMessageResponse.UserLeft) -> Bool {
    if lhs.userID != rhs.userID {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}
