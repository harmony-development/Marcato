// DO NOT EDIT.
// swift-format-ignore-file
//
// Generated by the Swift generator plugin for the protocol buffer compiler.
// Source: auth/v1/auth.proto
//
// For information on using the generated types, please see the documentation:
//   https://github.com/apple/swift-protobuf/

import Foundation
import SwiftProtobuf

// If the compiler emits an error on this type, it is because this file
// was generated by a version of the `protoc` Swift plug-in that is
// incompatible with the version of SwiftProtobuf to which you are linking.
// Please ensure that you are building against the same version of the API
// that was used to generate this file.
fileprivate struct _GeneratedWithProtocGenSwiftVersion: SwiftProtobuf.ProtobufAPIVersionCheck {
  struct _2: SwiftProtobuf.ProtobufAPIVersion_2 {}
  typealias Version = _2
}

/// Used in `BeginAuth` endpoint.
struct Protocol_Auth_V1_BeginAuthRequest {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  var unknownFields = SwiftProtobuf.UnknownStorage()

  init() {}
}

/// BeginAuthResponse
/// The return type of BeginAuth, containing the
/// auth_id that will be used for the authentication
/// section
struct Protocol_Auth_V1_BeginAuthResponse {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  /// auth_id: the ID of this auth session
  var authID: String = String()

  var unknownFields = SwiftProtobuf.UnknownStorage()

  init() {}
}

/// Session
/// Session contains the information for a new session;
/// the user_id you logged in as and the session_token
/// which should be passed to authorisation
struct Protocol_Auth_V1_Session {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  /// user_id: the ID of the user you logged in as
  var userID: UInt64 = 0

  /// session_token: the session token to use in authorization
  var sessionToken: String = String()

  var unknownFields = SwiftProtobuf.UnknownStorage()

  init() {}
}

/// AuthStep
/// A step in the authentication process
/// Contains a variety of different types of views
/// It is recommended to have a fallback_url specified
/// For non-trivial authentication procedures (such as captchas)
struct Protocol_Auth_V1_AuthStep {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  /// fallback_url: unused
  var fallbackURL: String = String()

  /// can_go_back: whether or not the client can request the
  /// server to send the previous step
  var canGoBack: Bool = false

  /// step: the current step
  var step: Protocol_Auth_V1_AuthStep.OneOf_Step? = nil

  /// choice: the user must pick a thing out of a list of options
  var choice: Protocol_Auth_V1_AuthStep.Choice {
    get {
      if case .choice(let v)? = step {return v}
      return Protocol_Auth_V1_AuthStep.Choice()
    }
    set {step = .choice(newValue)}
  }

  /// form: the user must complete a form
  var form: Protocol_Auth_V1_AuthStep.Form {
    get {
      if case .form(let v)? = step {return v}
      return Protocol_Auth_V1_AuthStep.Form()
    }
    set {step = .form(newValue)}
  }

  /// session: you've completed auth, and have a session
  var session: Protocol_Auth_V1_Session {
    get {
      if case .session(let v)? = step {return v}
      return Protocol_Auth_V1_Session()
    }
    set {step = .session(newValue)}
  }

  /// waiting: you're waiting on something
  var waiting: Protocol_Auth_V1_AuthStep.Waiting {
    get {
      if case .waiting(let v)? = step {return v}
      return Protocol_Auth_V1_AuthStep.Waiting()
    }
    set {step = .waiting(newValue)}
  }

  var unknownFields = SwiftProtobuf.UnknownStorage()

  /// step: the current step
  enum OneOf_Step: Equatable {
    /// choice: the user must pick a thing out of a list of options
    case choice(Protocol_Auth_V1_AuthStep.Choice)
    /// form: the user must complete a form
    case form(Protocol_Auth_V1_AuthStep.Form)
    /// session: you've completed auth, and have a session
    case session(Protocol_Auth_V1_Session)
    /// waiting: you're waiting on something
    case waiting(Protocol_Auth_V1_AuthStep.Waiting)

  #if !swift(>=4.1)
    static func ==(lhs: Protocol_Auth_V1_AuthStep.OneOf_Step, rhs: Protocol_Auth_V1_AuthStep.OneOf_Step) -> Bool {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch (lhs, rhs) {
      case (.choice, .choice): return {
        guard case .choice(let l) = lhs, case .choice(let r) = rhs else { preconditionFailure() }
        return l == r
      }()
      case (.form, .form): return {
        guard case .form(let l) = lhs, case .form(let r) = rhs else { preconditionFailure() }
        return l == r
      }()
      case (.session, .session): return {
        guard case .session(let l) = lhs, case .session(let r) = rhs else { preconditionFailure() }
        return l == r
      }()
      case (.waiting, .waiting): return {
        guard case .waiting(let l) = lhs, case .waiting(let r) = rhs else { preconditionFailure() }
        return l == r
      }()
      default: return false
      }
    }
  #endif
  }

  /// Choice
  /// A step which allows the user to choose from a range of options
  /// Allows you to show a heading by specifying title
  struct Choice {
    // SwiftProtobuf.Message conformance is added in an extension below. See the
    // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
    // methods supported on all messages.

    /// title: the title of the list of choices
    var title: String = String()

    /// options: a list of choices, one of these
    /// should be sent in nextstep
    var options: [String] = []

    var unknownFields = SwiftProtobuf.UnknownStorage()

    init() {}
  }

  /// Form
  /// A step which requires the user to input information
  /// Allows you to show a heading by specifying title
  struct Form {
    // SwiftProtobuf.Message conformance is added in an extension below. See the
    // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
    // methods supported on all messages.

    /// title: the title of this form
    var title: String = String()

    /// fields: all the fields in this form
    var fields: [Protocol_Auth_V1_AuthStep.Form.FormField] = []

    var unknownFields = SwiftProtobuf.UnknownStorage()

    /// FormField
    /// A field in the form, containing information on how it should
    /// be rendered
    /// Here is a list of form types that need to be supported:
    /// email: a field type that has to contain a valid email
    /// password: a field type that has to contain a password
    /// new-password: a field type for new passwords
    /// text: a field type that has to contain text
    /// number: a field type that has to contain a number
    struct FormField {
      // SwiftProtobuf.Message conformance is added in an extension below. See the
      // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
      // methods supported on all messages.

      /// name: the identifier for the form field
      var name: String = String()

      /// type: the type of the form field, as documented above
      var type: String = String()

      var unknownFields = SwiftProtobuf.UnknownStorage()

      init() {}
    }

    init() {}
  }

  /// Waiting
  /// A step which requires the user to perform an external action
  /// The title and description should explain to the user
  /// what they should do to complete this step
  struct Waiting {
    // SwiftProtobuf.Message conformance is added in an extension below. See the
    // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
    // methods supported on all messages.

    /// title: the title of this waiting screen
    var title: String = String()

    /// description: the explanation of what's being waited on
    var description_p: String = String()

    var unknownFields = SwiftProtobuf.UnknownStorage()

    init() {}
  }

  init() {}
}

/// NextStepRequest
/// contains the client's response to the server's challenge
/// This needs to be called first with no arguments to
/// receive the first step
struct Protocol_Auth_V1_NextStepRequest {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  /// auth_id: the authentication session you want
  /// the next step of
  var authID: String = String()

  /// step: the user's response to a step
  var step: Protocol_Auth_V1_NextStepRequest.OneOf_Step? = nil

  /// choice: the choice the user picked
  var choice: Protocol_Auth_V1_NextStepRequest.Choice {
    get {
      if case .choice(let v)? = step {return v}
      return Protocol_Auth_V1_NextStepRequest.Choice()
    }
    set {step = .choice(newValue)}
  }

  /// form: the form the user filled out
  var form: Protocol_Auth_V1_NextStepRequest.Form {
    get {
      if case .form(let v)? = step {return v}
      return Protocol_Auth_V1_NextStepRequest.Form()
    }
    set {step = .form(newValue)}
  }

  var unknownFields = SwiftProtobuf.UnknownStorage()

  /// step: the user's response to a step
  enum OneOf_Step: Equatable {
    /// choice: the choice the user picked
    case choice(Protocol_Auth_V1_NextStepRequest.Choice)
    /// form: the form the user filled out
    case form(Protocol_Auth_V1_NextStepRequest.Form)

  #if !swift(>=4.1)
    static func ==(lhs: Protocol_Auth_V1_NextStepRequest.OneOf_Step, rhs: Protocol_Auth_V1_NextStepRequest.OneOf_Step) -> Bool {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch (lhs, rhs) {
      case (.choice, .choice): return {
        guard case .choice(let l) = lhs, case .choice(let r) = rhs else { preconditionFailure() }
        return l == r
      }()
      case (.form, .form): return {
        guard case .form(let l) = lhs, case .form(let r) = rhs else { preconditionFailure() }
        return l == r
      }()
      default: return false
      }
    }
  #endif
  }

  /// A simple choice string indicating which option the user chose
  struct Choice {
    // SwiftProtobuf.Message conformance is added in an extension below. See the
    // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
    // methods supported on all messages.

    /// choice: the choice the user picked
    var choice: String = String()

    var unknownFields = SwiftProtobuf.UnknownStorage()

    init() {}
  }

  /// Form fields can either be bytes, string, or int64.
  struct FormFields {
    // SwiftProtobuf.Message conformance is added in an extension below. See the
    // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
    // methods supported on all messages.

    /// field: the data for a form field
    var field: Protocol_Auth_V1_NextStepRequest.FormFields.OneOf_Field? = nil

    /// bytes: the form field's data is a byte array
    var bytes: Data {
      get {
        if case .bytes(let v)? = field {return v}
        return Data()
      }
      set {field = .bytes(newValue)}
    }

    /// string: the form field's data is a string
    var string: String {
      get {
        if case .string(let v)? = field {return v}
        return String()
      }
      set {field = .string(newValue)}
    }

    /// number: the form field's data is a number
    var number: Int64 {
      get {
        if case .number(let v)? = field {return v}
        return 0
      }
      set {field = .number(newValue)}
    }

    var unknownFields = SwiftProtobuf.UnknownStorage()

    /// field: the data for a form field
    enum OneOf_Field: Equatable {
      /// bytes: the form field's data is a byte array
      case bytes(Data)
      /// string: the form field's data is a string
      case string(String)
      /// number: the form field's data is a number
      case number(Int64)

    #if !swift(>=4.1)
      static func ==(lhs: Protocol_Auth_V1_NextStepRequest.FormFields.OneOf_Field, rhs: Protocol_Auth_V1_NextStepRequest.FormFields.OneOf_Field) -> Bool {
        // The use of inline closures is to circumvent an issue where the compiler
        // allocates stack space for every case branch when no optimizations are
        // enabled. https://github.com/apple/swift-protobuf/issues/1034
        switch (lhs, rhs) {
        case (.bytes, .bytes): return {
          guard case .bytes(let l) = lhs, case .bytes(let r) = rhs else { preconditionFailure() }
          return l == r
        }()
        case (.string, .string): return {
          guard case .string(let l) = lhs, case .string(let r) = rhs else { preconditionFailure() }
          return l == r
        }()
        case (.number, .number): return {
          guard case .number(let l) = lhs, case .number(let r) = rhs else { preconditionFailure() }
          return l == r
        }()
        default: return false
        }
      }
    #endif
    }

    init() {}
  }

  /// An array of form fields, in the same order they came in from the server
  struct Form {
    // SwiftProtobuf.Message conformance is added in an extension below. See the
    // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
    // methods supported on all messages.

    /// fields: the fields the user filled out
    var fields: [Protocol_Auth_V1_NextStepRequest.FormFields] = []

    var unknownFields = SwiftProtobuf.UnknownStorage()

    init() {}
  }

  init() {}
}

/// Used in `NextStep` endpoint.
struct Protocol_Auth_V1_NextStepResponse {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  /// step: the next step in the authentication process
  var step: Protocol_Auth_V1_AuthStep {
    get {return _step ?? Protocol_Auth_V1_AuthStep()}
    set {_step = newValue}
  }
  /// Returns true if `step` has been explicitly set.
  var hasStep: Bool {return self._step != nil}
  /// Clears the value of `step`. Subsequent reads from it will return its default value.
  mutating func clearStep() {self._step = nil}

  var unknownFields = SwiftProtobuf.UnknownStorage()

  init() {}

  fileprivate var _step: Protocol_Auth_V1_AuthStep? = nil
}

/// StepBackRequest
/// A request to go back 1 step
struct Protocol_Auth_V1_StepBackRequest {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  /// auth_id: the authentication session the user
  /// wants to go back in
  var authID: String = String()

  var unknownFields = SwiftProtobuf.UnknownStorage()

  init() {}
}

/// Used in `StepBack` endpoint.
struct Protocol_Auth_V1_StepBackResponse {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  /// step: the previous step in the authentication process
  var step: Protocol_Auth_V1_AuthStep {
    get {return _step ?? Protocol_Auth_V1_AuthStep()}
    set {_step = newValue}
  }
  /// Returns true if `step` has been explicitly set.
  var hasStep: Bool {return self._step != nil}
  /// Clears the value of `step`. Subsequent reads from it will return its default value.
  mutating func clearStep() {self._step = nil}

  var unknownFields = SwiftProtobuf.UnknownStorage()

  init() {}

  fileprivate var _step: Protocol_Auth_V1_AuthStep? = nil
}

/// StreamStepsRequest
/// Required to be initiated by all authenticating clients
/// Allows the server to send steps
struct Protocol_Auth_V1_StreamStepsRequest {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  /// auth_id: the authorization session
  /// who's steps you want to stream
  var authID: String = String()

  var unknownFields = SwiftProtobuf.UnknownStorage()

  init() {}
}

/// Used in `StreamSteps` endpoint.
struct Protocol_Auth_V1_StreamStepsResponse {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  /// step: the next step in the authentication process
  var step: Protocol_Auth_V1_AuthStep {
    get {return _step ?? Protocol_Auth_V1_AuthStep()}
    set {_step = newValue}
  }
  /// Returns true if `step` has been explicitly set.
  var hasStep: Bool {return self._step != nil}
  /// Clears the value of `step`. Subsequent reads from it will return its default value.
  mutating func clearStep() {self._step = nil}

  var unknownFields = SwiftProtobuf.UnknownStorage()

  init() {}

  fileprivate var _step: Protocol_Auth_V1_AuthStep? = nil
}

/// The request to federate with a foreign server.
struct Protocol_Auth_V1_FederateRequest {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  /// target: the foreign server you want to
  /// federate with
  var target: String = String()

  var unknownFields = SwiftProtobuf.UnknownStorage()

  init() {}
}

/// The reply to a successful federation request,
/// containing the token you need to present to the
/// foreign server.
struct Protocol_Auth_V1_FederateResponse {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  /// A `harmonytypes.v1.Token` whose `data` field is a serialized `TokenData` message.
  /// It is signed with the homeserver's private key.
  var token: Protocol_Harmonytypes_V1_Token {
    get {return _token ?? Protocol_Harmonytypes_V1_Token()}
    set {_token = newValue}
  }
  /// Returns true if `token` has been explicitly set.
  var hasToken: Bool {return self._token != nil}
  /// Clears the value of `token`. Subsequent reads from it will return its default value.
  mutating func clearToken() {self._token = nil}

  var unknownFields = SwiftProtobuf.UnknownStorage()

  init() {}

  fileprivate var _token: Protocol_Harmonytypes_V1_Token? = nil
}

/// Used in `Key` endpoint.
struct Protocol_Auth_V1_KeyRequest {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  var unknownFields = SwiftProtobuf.UnknownStorage()

  init() {}
}

/// Contains a key's bytes.
struct Protocol_Auth_V1_KeyResponse {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  /// key: the bytes of the public key.
  var key: Data = Data()

  var unknownFields = SwiftProtobuf.UnknownStorage()

  init() {}
}

/// Log into a foreignserver using a token
/// from your homeserver, obtained through a FederateRequest
struct Protocol_Auth_V1_LoginFederatedRequest {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  /// A `harmonytypes.v1.Token` whose `data` field is a serialized `TokenData` message.
  /// It is signed with the homeserver's private key.
  var authToken: Protocol_Harmonytypes_V1_Token {
    get {return _authToken ?? Protocol_Harmonytypes_V1_Token()}
    set {_authToken = newValue}
  }
  /// Returns true if `authToken` has been explicitly set.
  var hasAuthToken: Bool {return self._authToken != nil}
  /// Clears the value of `authToken`. Subsequent reads from it will return its default value.
  mutating func clearAuthToken() {self._authToken = nil}

  /// domain: the homeserver that the auth token is from
  var domain: String = String()

  var unknownFields = SwiftProtobuf.UnknownStorage()

  init() {}

  fileprivate var _authToken: Protocol_Harmonytypes_V1_Token? = nil
}

/// Used in `LoginFederated` endpoint.
struct Protocol_Auth_V1_LoginFederatedResponse {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  /// The user's session.
  var session: Protocol_Auth_V1_Session {
    get {return _session ?? Protocol_Auth_V1_Session()}
    set {_session = newValue}
  }
  /// Returns true if `session` has been explicitly set.
  var hasSession: Bool {return self._session != nil}
  /// Clears the value of `session`. Subsequent reads from it will return its default value.
  mutating func clearSession() {self._session = nil}

  var unknownFields = SwiftProtobuf.UnknownStorage()

  init() {}

  fileprivate var _session: Protocol_Auth_V1_Session? = nil
}

/// Information sent by a client's homeserver, in a `harmonytypes.v1.Token`.
/// It will be sent to a foreignserver by the client.
struct Protocol_Auth_V1_TokenData {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  /// The client's user ID on the homeserver.
  var userID: UInt64 = 0

  /// The foreignserver's server name.
  var target: String = String()

  /// The username of the client.
  var username: String = String()

  /// The avatar of the client.
  var avatar: String = String()

  var unknownFields = SwiftProtobuf.UnknownStorage()

  init() {}
}

/// Used in `CheckLoggedIn` endpoint.
struct Protocol_Auth_V1_CheckLoggedInRequest {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  var unknownFields = SwiftProtobuf.UnknownStorage()

  init() {}
}

/// Used in `CheckLoggedIn` endpoint.
struct Protocol_Auth_V1_CheckLoggedInResponse {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  var unknownFields = SwiftProtobuf.UnknownStorage()

  init() {}
}

// MARK: - Code below here is support for the SwiftProtobuf runtime.

fileprivate let _protobuf_package = "protocol.auth.v1"

extension Protocol_Auth_V1_BeginAuthRequest: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static let protoMessageName: String = _protobuf_package + ".BeginAuthRequest"
  static let _protobuf_nameMap = SwiftProtobuf._NameMap()

  mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let _ = try decoder.nextFieldNumber() {
    }
  }

  func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    try unknownFields.traverse(visitor: &visitor)
  }

  static func ==(lhs: Protocol_Auth_V1_BeginAuthRequest, rhs: Protocol_Auth_V1_BeginAuthRequest) -> Bool {
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Protocol_Auth_V1_BeginAuthResponse: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static let protoMessageName: String = _protobuf_package + ".BeginAuthResponse"
  static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .standard(proto: "auth_id"),
  ]

  mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularStringField(value: &self.authID) }()
      default: break
      }
    }
  }

  func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if !self.authID.isEmpty {
      try visitor.visitSingularStringField(value: self.authID, fieldNumber: 1)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  static func ==(lhs: Protocol_Auth_V1_BeginAuthResponse, rhs: Protocol_Auth_V1_BeginAuthResponse) -> Bool {
    if lhs.authID != rhs.authID {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Protocol_Auth_V1_Session: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static let protoMessageName: String = _protobuf_package + ".Session"
  static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .standard(proto: "user_id"),
    2: .standard(proto: "session_token"),
  ]

  mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularUInt64Field(value: &self.userID) }()
      case 2: try { try decoder.decodeSingularStringField(value: &self.sessionToken) }()
      default: break
      }
    }
  }

  func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if self.userID != 0 {
      try visitor.visitSingularUInt64Field(value: self.userID, fieldNumber: 1)
    }
    if !self.sessionToken.isEmpty {
      try visitor.visitSingularStringField(value: self.sessionToken, fieldNumber: 2)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  static func ==(lhs: Protocol_Auth_V1_Session, rhs: Protocol_Auth_V1_Session) -> Bool {
    if lhs.userID != rhs.userID {return false}
    if lhs.sessionToken != rhs.sessionToken {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Protocol_Auth_V1_AuthStep: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static let protoMessageName: String = _protobuf_package + ".AuthStep"
  static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .standard(proto: "fallback_url"),
    2: .standard(proto: "can_go_back"),
    3: .same(proto: "choice"),
    4: .same(proto: "form"),
    5: .same(proto: "session"),
    6: .same(proto: "waiting"),
  ]

  mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularStringField(value: &self.fallbackURL) }()
      case 2: try { try decoder.decodeSingularBoolField(value: &self.canGoBack) }()
      case 3: try {
        var v: Protocol_Auth_V1_AuthStep.Choice?
        var hadOneofValue = false
        if let current = self.step {
          hadOneofValue = true
          if case .choice(let m) = current {v = m}
        }
        try decoder.decodeSingularMessageField(value: &v)
        if let v = v {
          if hadOneofValue {try decoder.handleConflictingOneOf()}
          self.step = .choice(v)
        }
      }()
      case 4: try {
        var v: Protocol_Auth_V1_AuthStep.Form?
        var hadOneofValue = false
        if let current = self.step {
          hadOneofValue = true
          if case .form(let m) = current {v = m}
        }
        try decoder.decodeSingularMessageField(value: &v)
        if let v = v {
          if hadOneofValue {try decoder.handleConflictingOneOf()}
          self.step = .form(v)
        }
      }()
      case 5: try {
        var v: Protocol_Auth_V1_Session?
        var hadOneofValue = false
        if let current = self.step {
          hadOneofValue = true
          if case .session(let m) = current {v = m}
        }
        try decoder.decodeSingularMessageField(value: &v)
        if let v = v {
          if hadOneofValue {try decoder.handleConflictingOneOf()}
          self.step = .session(v)
        }
      }()
      case 6: try {
        var v: Protocol_Auth_V1_AuthStep.Waiting?
        var hadOneofValue = false
        if let current = self.step {
          hadOneofValue = true
          if case .waiting(let m) = current {v = m}
        }
        try decoder.decodeSingularMessageField(value: &v)
        if let v = v {
          if hadOneofValue {try decoder.handleConflictingOneOf()}
          self.step = .waiting(v)
        }
      }()
      default: break
      }
    }
  }

  func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if !self.fallbackURL.isEmpty {
      try visitor.visitSingularStringField(value: self.fallbackURL, fieldNumber: 1)
    }
    if self.canGoBack != false {
      try visitor.visitSingularBoolField(value: self.canGoBack, fieldNumber: 2)
    }
    // The use of inline closures is to circumvent an issue where the compiler
    // allocates stack space for every case branch when no optimizations are
    // enabled. https://github.com/apple/swift-protobuf/issues/1034
    switch self.step {
    case .choice?: try {
      guard case .choice(let v)? = self.step else { preconditionFailure() }
      try visitor.visitSingularMessageField(value: v, fieldNumber: 3)
    }()
    case .form?: try {
      guard case .form(let v)? = self.step else { preconditionFailure() }
      try visitor.visitSingularMessageField(value: v, fieldNumber: 4)
    }()
    case .session?: try {
      guard case .session(let v)? = self.step else { preconditionFailure() }
      try visitor.visitSingularMessageField(value: v, fieldNumber: 5)
    }()
    case .waiting?: try {
      guard case .waiting(let v)? = self.step else { preconditionFailure() }
      try visitor.visitSingularMessageField(value: v, fieldNumber: 6)
    }()
    case nil: break
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  static func ==(lhs: Protocol_Auth_V1_AuthStep, rhs: Protocol_Auth_V1_AuthStep) -> Bool {
    if lhs.fallbackURL != rhs.fallbackURL {return false}
    if lhs.canGoBack != rhs.canGoBack {return false}
    if lhs.step != rhs.step {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Protocol_Auth_V1_AuthStep.Choice: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static let protoMessageName: String = Protocol_Auth_V1_AuthStep.protoMessageName + ".Choice"
  static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "title"),
    2: .same(proto: "options"),
  ]

  mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularStringField(value: &self.title) }()
      case 2: try { try decoder.decodeRepeatedStringField(value: &self.options) }()
      default: break
      }
    }
  }

  func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if !self.title.isEmpty {
      try visitor.visitSingularStringField(value: self.title, fieldNumber: 1)
    }
    if !self.options.isEmpty {
      try visitor.visitRepeatedStringField(value: self.options, fieldNumber: 2)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  static func ==(lhs: Protocol_Auth_V1_AuthStep.Choice, rhs: Protocol_Auth_V1_AuthStep.Choice) -> Bool {
    if lhs.title != rhs.title {return false}
    if lhs.options != rhs.options {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Protocol_Auth_V1_AuthStep.Form: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static let protoMessageName: String = Protocol_Auth_V1_AuthStep.protoMessageName + ".Form"
  static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "title"),
    2: .same(proto: "fields"),
  ]

  mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularStringField(value: &self.title) }()
      case 2: try { try decoder.decodeRepeatedMessageField(value: &self.fields) }()
      default: break
      }
    }
  }

  func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if !self.title.isEmpty {
      try visitor.visitSingularStringField(value: self.title, fieldNumber: 1)
    }
    if !self.fields.isEmpty {
      try visitor.visitRepeatedMessageField(value: self.fields, fieldNumber: 2)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  static func ==(lhs: Protocol_Auth_V1_AuthStep.Form, rhs: Protocol_Auth_V1_AuthStep.Form) -> Bool {
    if lhs.title != rhs.title {return false}
    if lhs.fields != rhs.fields {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Protocol_Auth_V1_AuthStep.Form.FormField: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static let protoMessageName: String = Protocol_Auth_V1_AuthStep.Form.protoMessageName + ".FormField"
  static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "name"),
    2: .same(proto: "type"),
  ]

  mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularStringField(value: &self.name) }()
      case 2: try { try decoder.decodeSingularStringField(value: &self.type) }()
      default: break
      }
    }
  }

  func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if !self.name.isEmpty {
      try visitor.visitSingularStringField(value: self.name, fieldNumber: 1)
    }
    if !self.type.isEmpty {
      try visitor.visitSingularStringField(value: self.type, fieldNumber: 2)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  static func ==(lhs: Protocol_Auth_V1_AuthStep.Form.FormField, rhs: Protocol_Auth_V1_AuthStep.Form.FormField) -> Bool {
    if lhs.name != rhs.name {return false}
    if lhs.type != rhs.type {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Protocol_Auth_V1_AuthStep.Waiting: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static let protoMessageName: String = Protocol_Auth_V1_AuthStep.protoMessageName + ".Waiting"
  static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "title"),
    2: .same(proto: "description"),
  ]

  mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularStringField(value: &self.title) }()
      case 2: try { try decoder.decodeSingularStringField(value: &self.description_p) }()
      default: break
      }
    }
  }

  func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if !self.title.isEmpty {
      try visitor.visitSingularStringField(value: self.title, fieldNumber: 1)
    }
    if !self.description_p.isEmpty {
      try visitor.visitSingularStringField(value: self.description_p, fieldNumber: 2)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  static func ==(lhs: Protocol_Auth_V1_AuthStep.Waiting, rhs: Protocol_Auth_V1_AuthStep.Waiting) -> Bool {
    if lhs.title != rhs.title {return false}
    if lhs.description_p != rhs.description_p {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Protocol_Auth_V1_NextStepRequest: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static let protoMessageName: String = _protobuf_package + ".NextStepRequest"
  static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .standard(proto: "auth_id"),
    2: .same(proto: "choice"),
    3: .same(proto: "form"),
  ]

  mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularStringField(value: &self.authID) }()
      case 2: try {
        var v: Protocol_Auth_V1_NextStepRequest.Choice?
        var hadOneofValue = false
        if let current = self.step {
          hadOneofValue = true
          if case .choice(let m) = current {v = m}
        }
        try decoder.decodeSingularMessageField(value: &v)
        if let v = v {
          if hadOneofValue {try decoder.handleConflictingOneOf()}
          self.step = .choice(v)
        }
      }()
      case 3: try {
        var v: Protocol_Auth_V1_NextStepRequest.Form?
        var hadOneofValue = false
        if let current = self.step {
          hadOneofValue = true
          if case .form(let m) = current {v = m}
        }
        try decoder.decodeSingularMessageField(value: &v)
        if let v = v {
          if hadOneofValue {try decoder.handleConflictingOneOf()}
          self.step = .form(v)
        }
      }()
      default: break
      }
    }
  }

  func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if !self.authID.isEmpty {
      try visitor.visitSingularStringField(value: self.authID, fieldNumber: 1)
    }
    // The use of inline closures is to circumvent an issue where the compiler
    // allocates stack space for every case branch when no optimizations are
    // enabled. https://github.com/apple/swift-protobuf/issues/1034
    switch self.step {
    case .choice?: try {
      guard case .choice(let v)? = self.step else { preconditionFailure() }
      try visitor.visitSingularMessageField(value: v, fieldNumber: 2)
    }()
    case .form?: try {
      guard case .form(let v)? = self.step else { preconditionFailure() }
      try visitor.visitSingularMessageField(value: v, fieldNumber: 3)
    }()
    case nil: break
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  static func ==(lhs: Protocol_Auth_V1_NextStepRequest, rhs: Protocol_Auth_V1_NextStepRequest) -> Bool {
    if lhs.authID != rhs.authID {return false}
    if lhs.step != rhs.step {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Protocol_Auth_V1_NextStepRequest.Choice: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static let protoMessageName: String = Protocol_Auth_V1_NextStepRequest.protoMessageName + ".Choice"
  static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "choice"),
  ]

  mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularStringField(value: &self.choice) }()
      default: break
      }
    }
  }

  func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if !self.choice.isEmpty {
      try visitor.visitSingularStringField(value: self.choice, fieldNumber: 1)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  static func ==(lhs: Protocol_Auth_V1_NextStepRequest.Choice, rhs: Protocol_Auth_V1_NextStepRequest.Choice) -> Bool {
    if lhs.choice != rhs.choice {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Protocol_Auth_V1_NextStepRequest.FormFields: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static let protoMessageName: String = Protocol_Auth_V1_NextStepRequest.protoMessageName + ".FormFields"
  static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "bytes"),
    2: .same(proto: "string"),
    3: .same(proto: "number"),
  ]

  mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try {
        var v: Data?
        try decoder.decodeSingularBytesField(value: &v)
        if let v = v {
          if self.field != nil {try decoder.handleConflictingOneOf()}
          self.field = .bytes(v)
        }
      }()
      case 2: try {
        var v: String?
        try decoder.decodeSingularStringField(value: &v)
        if let v = v {
          if self.field != nil {try decoder.handleConflictingOneOf()}
          self.field = .string(v)
        }
      }()
      case 3: try {
        var v: Int64?
        try decoder.decodeSingularInt64Field(value: &v)
        if let v = v {
          if self.field != nil {try decoder.handleConflictingOneOf()}
          self.field = .number(v)
        }
      }()
      default: break
      }
    }
  }

  func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    // The use of inline closures is to circumvent an issue where the compiler
    // allocates stack space for every case branch when no optimizations are
    // enabled. https://github.com/apple/swift-protobuf/issues/1034
    switch self.field {
    case .bytes?: try {
      guard case .bytes(let v)? = self.field else { preconditionFailure() }
      try visitor.visitSingularBytesField(value: v, fieldNumber: 1)
    }()
    case .string?: try {
      guard case .string(let v)? = self.field else { preconditionFailure() }
      try visitor.visitSingularStringField(value: v, fieldNumber: 2)
    }()
    case .number?: try {
      guard case .number(let v)? = self.field else { preconditionFailure() }
      try visitor.visitSingularInt64Field(value: v, fieldNumber: 3)
    }()
    case nil: break
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  static func ==(lhs: Protocol_Auth_V1_NextStepRequest.FormFields, rhs: Protocol_Auth_V1_NextStepRequest.FormFields) -> Bool {
    if lhs.field != rhs.field {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Protocol_Auth_V1_NextStepRequest.Form: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static let protoMessageName: String = Protocol_Auth_V1_NextStepRequest.protoMessageName + ".Form"
  static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "fields"),
  ]

  mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeRepeatedMessageField(value: &self.fields) }()
      default: break
      }
    }
  }

  func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if !self.fields.isEmpty {
      try visitor.visitRepeatedMessageField(value: self.fields, fieldNumber: 1)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  static func ==(lhs: Protocol_Auth_V1_NextStepRequest.Form, rhs: Protocol_Auth_V1_NextStepRequest.Form) -> Bool {
    if lhs.fields != rhs.fields {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Protocol_Auth_V1_NextStepResponse: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static let protoMessageName: String = _protobuf_package + ".NextStepResponse"
  static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "step"),
  ]

  mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularMessageField(value: &self._step) }()
      default: break
      }
    }
  }

  func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if let v = self._step {
      try visitor.visitSingularMessageField(value: v, fieldNumber: 1)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  static func ==(lhs: Protocol_Auth_V1_NextStepResponse, rhs: Protocol_Auth_V1_NextStepResponse) -> Bool {
    if lhs._step != rhs._step {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Protocol_Auth_V1_StepBackRequest: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static let protoMessageName: String = _protobuf_package + ".StepBackRequest"
  static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .standard(proto: "auth_id"),
  ]

  mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularStringField(value: &self.authID) }()
      default: break
      }
    }
  }

  func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if !self.authID.isEmpty {
      try visitor.visitSingularStringField(value: self.authID, fieldNumber: 1)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  static func ==(lhs: Protocol_Auth_V1_StepBackRequest, rhs: Protocol_Auth_V1_StepBackRequest) -> Bool {
    if lhs.authID != rhs.authID {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Protocol_Auth_V1_StepBackResponse: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static let protoMessageName: String = _protobuf_package + ".StepBackResponse"
  static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "step"),
  ]

  mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularMessageField(value: &self._step) }()
      default: break
      }
    }
  }

  func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if let v = self._step {
      try visitor.visitSingularMessageField(value: v, fieldNumber: 1)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  static func ==(lhs: Protocol_Auth_V1_StepBackResponse, rhs: Protocol_Auth_V1_StepBackResponse) -> Bool {
    if lhs._step != rhs._step {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Protocol_Auth_V1_StreamStepsRequest: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static let protoMessageName: String = _protobuf_package + ".StreamStepsRequest"
  static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .standard(proto: "auth_id"),
  ]

  mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularStringField(value: &self.authID) }()
      default: break
      }
    }
  }

  func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if !self.authID.isEmpty {
      try visitor.visitSingularStringField(value: self.authID, fieldNumber: 1)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  static func ==(lhs: Protocol_Auth_V1_StreamStepsRequest, rhs: Protocol_Auth_V1_StreamStepsRequest) -> Bool {
    if lhs.authID != rhs.authID {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Protocol_Auth_V1_StreamStepsResponse: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static let protoMessageName: String = _protobuf_package + ".StreamStepsResponse"
  static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "step"),
  ]

  mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularMessageField(value: &self._step) }()
      default: break
      }
    }
  }

  func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if let v = self._step {
      try visitor.visitSingularMessageField(value: v, fieldNumber: 1)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  static func ==(lhs: Protocol_Auth_V1_StreamStepsResponse, rhs: Protocol_Auth_V1_StreamStepsResponse) -> Bool {
    if lhs._step != rhs._step {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Protocol_Auth_V1_FederateRequest: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static let protoMessageName: String = _protobuf_package + ".FederateRequest"
  static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "target"),
  ]

  mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularStringField(value: &self.target) }()
      default: break
      }
    }
  }

  func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if !self.target.isEmpty {
      try visitor.visitSingularStringField(value: self.target, fieldNumber: 1)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  static func ==(lhs: Protocol_Auth_V1_FederateRequest, rhs: Protocol_Auth_V1_FederateRequest) -> Bool {
    if lhs.target != rhs.target {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Protocol_Auth_V1_FederateResponse: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static let protoMessageName: String = _protobuf_package + ".FederateResponse"
  static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "token"),
  ]

  mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularMessageField(value: &self._token) }()
      default: break
      }
    }
  }

  func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if let v = self._token {
      try visitor.visitSingularMessageField(value: v, fieldNumber: 1)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  static func ==(lhs: Protocol_Auth_V1_FederateResponse, rhs: Protocol_Auth_V1_FederateResponse) -> Bool {
    if lhs._token != rhs._token {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Protocol_Auth_V1_KeyRequest: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static let protoMessageName: String = _protobuf_package + ".KeyRequest"
  static let _protobuf_nameMap = SwiftProtobuf._NameMap()

  mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let _ = try decoder.nextFieldNumber() {
    }
  }

  func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    try unknownFields.traverse(visitor: &visitor)
  }

  static func ==(lhs: Protocol_Auth_V1_KeyRequest, rhs: Protocol_Auth_V1_KeyRequest) -> Bool {
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Protocol_Auth_V1_KeyResponse: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static let protoMessageName: String = _protobuf_package + ".KeyResponse"
  static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "key"),
  ]

  mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularBytesField(value: &self.key) }()
      default: break
      }
    }
  }

  func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if !self.key.isEmpty {
      try visitor.visitSingularBytesField(value: self.key, fieldNumber: 1)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  static func ==(lhs: Protocol_Auth_V1_KeyResponse, rhs: Protocol_Auth_V1_KeyResponse) -> Bool {
    if lhs.key != rhs.key {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Protocol_Auth_V1_LoginFederatedRequest: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static let protoMessageName: String = _protobuf_package + ".LoginFederatedRequest"
  static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .standard(proto: "auth_token"),
    2: .same(proto: "domain"),
  ]

  mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularMessageField(value: &self._authToken) }()
      case 2: try { try decoder.decodeSingularStringField(value: &self.domain) }()
      default: break
      }
    }
  }

  func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if let v = self._authToken {
      try visitor.visitSingularMessageField(value: v, fieldNumber: 1)
    }
    if !self.domain.isEmpty {
      try visitor.visitSingularStringField(value: self.domain, fieldNumber: 2)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  static func ==(lhs: Protocol_Auth_V1_LoginFederatedRequest, rhs: Protocol_Auth_V1_LoginFederatedRequest) -> Bool {
    if lhs._authToken != rhs._authToken {return false}
    if lhs.domain != rhs.domain {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Protocol_Auth_V1_LoginFederatedResponse: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static let protoMessageName: String = _protobuf_package + ".LoginFederatedResponse"
  static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "session"),
  ]

  mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularMessageField(value: &self._session) }()
      default: break
      }
    }
  }

  func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if let v = self._session {
      try visitor.visitSingularMessageField(value: v, fieldNumber: 1)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  static func ==(lhs: Protocol_Auth_V1_LoginFederatedResponse, rhs: Protocol_Auth_V1_LoginFederatedResponse) -> Bool {
    if lhs._session != rhs._session {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Protocol_Auth_V1_TokenData: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static let protoMessageName: String = _protobuf_package + ".TokenData"
  static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .standard(proto: "user_id"),
    2: .same(proto: "target"),
    3: .same(proto: "username"),
    4: .same(proto: "avatar"),
  ]

  mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularUInt64Field(value: &self.userID) }()
      case 2: try { try decoder.decodeSingularStringField(value: &self.target) }()
      case 3: try { try decoder.decodeSingularStringField(value: &self.username) }()
      case 4: try { try decoder.decodeSingularStringField(value: &self.avatar) }()
      default: break
      }
    }
  }

  func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if self.userID != 0 {
      try visitor.visitSingularUInt64Field(value: self.userID, fieldNumber: 1)
    }
    if !self.target.isEmpty {
      try visitor.visitSingularStringField(value: self.target, fieldNumber: 2)
    }
    if !self.username.isEmpty {
      try visitor.visitSingularStringField(value: self.username, fieldNumber: 3)
    }
    if !self.avatar.isEmpty {
      try visitor.visitSingularStringField(value: self.avatar, fieldNumber: 4)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  static func ==(lhs: Protocol_Auth_V1_TokenData, rhs: Protocol_Auth_V1_TokenData) -> Bool {
    if lhs.userID != rhs.userID {return false}
    if lhs.target != rhs.target {return false}
    if lhs.username != rhs.username {return false}
    if lhs.avatar != rhs.avatar {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Protocol_Auth_V1_CheckLoggedInRequest: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static let protoMessageName: String = _protobuf_package + ".CheckLoggedInRequest"
  static let _protobuf_nameMap = SwiftProtobuf._NameMap()

  mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let _ = try decoder.nextFieldNumber() {
    }
  }

  func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    try unknownFields.traverse(visitor: &visitor)
  }

  static func ==(lhs: Protocol_Auth_V1_CheckLoggedInRequest, rhs: Protocol_Auth_V1_CheckLoggedInRequest) -> Bool {
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Protocol_Auth_V1_CheckLoggedInResponse: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static let protoMessageName: String = _protobuf_package + ".CheckLoggedInResponse"
  static let _protobuf_nameMap = SwiftProtobuf._NameMap()

  mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let _ = try decoder.nextFieldNumber() {
    }
  }

  func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    try unknownFields.traverse(visitor: &visitor)
  }

  static func ==(lhs: Protocol_Auth_V1_CheckLoggedInResponse, rhs: Protocol_Auth_V1_CheckLoggedInResponse) -> Bool {
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}
